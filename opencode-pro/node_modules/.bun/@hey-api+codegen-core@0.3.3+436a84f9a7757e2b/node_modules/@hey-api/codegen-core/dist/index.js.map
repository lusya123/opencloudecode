{"version":3,"file":"index.js","names":["names: Array<string>","typeNames: Array<string>","binding: IBinding & Pick<Required<IBinding>, 'aliases' | 'from'>","result","result: IFileOut | undefined","id","sets: Array<Set<SymbolId>>","stub: ISymbolOut","result: ISymbolOut","entries: Array<IndexEntry>","path","extension","files: Map<number, IOutput>"],"sources":["../src/bindings/utils.ts","../src/bimap/bimap.ts","../src/files/registry.ts","../src/renderer/utils.ts","../src/symbols/registry.ts","../src/project/project.ts"],"sourcesContent":["import type { IFileOut } from '../files/types';\nimport type { ISymbolOut } from '../symbols/types';\nimport type { IBinding } from './types';\n\nexport const createBinding = ({\n  file,\n  modulePath,\n  symbol,\n  symbolFile,\n}: {\n  file: IFileOut;\n  modulePath: string;\n  symbol: ISymbolOut;\n  symbolFile: IFileOut;\n}): IBinding => {\n  const names: Array<string> = [];\n  const typeNames: Array<string> = [];\n  const binding: IBinding & Pick<Required<IBinding>, 'aliases' | 'from'> = {\n    aliases: {},\n    from: modulePath,\n  };\n  if (symbol.importKind) {\n    if (symbol.importKind === 'default') {\n      binding.defaultBinding = symbol.placeholder;\n      if (symbol.kind === 'type') {\n        binding.typeDefaultBinding = true;\n      }\n    } else if (symbol.importKind === 'namespace') {\n      binding.namespaceBinding = symbol.placeholder;\n      if (symbol.kind === 'type') {\n        binding.typeNamespaceBinding = true;\n      }\n    }\n  }\n  // default to named binding\n  if (\n    symbol.importKind === 'named' ||\n    (!names.length && !binding.defaultBinding && !binding.namespaceBinding)\n  ) {\n    let name = symbol.placeholder;\n    const fileResolvedName = file.resolvedNames.get(symbol.id);\n    if (fileResolvedName) {\n      const symbolFileResolvedName = symbolFile.resolvedNames.get(symbol.id);\n      if (symbolFileResolvedName) {\n        if (symbolFileResolvedName !== fileResolvedName) {\n          name = symbolFileResolvedName;\n          binding.aliases[name] = fileResolvedName;\n        }\n      } else if (symbol.name && fileResolvedName !== symbol.name) {\n        name = symbol.name;\n        binding.aliases[name] = symbol.placeholder;\n      }\n    }\n    names.push(name);\n    if (symbol.kind === 'type') {\n      typeNames.push(name);\n    }\n  }\n  // cast type names to names to allow for cleaner API,\n  // otherwise users would have to define the same values twice\n  for (const typeName of typeNames) {\n    if (!names.includes(typeName)) {\n      names.push(typeName);\n    }\n  }\n  binding.names = names;\n  binding.typeNames = typeNames;\n  return binding;\n};\n\nexport const mergeBindings = (target: IBinding, source: IBinding): void => {\n  target.aliases = { ...target.aliases, ...source.aliases };\n  if (source.defaultBinding !== undefined) {\n    target.defaultBinding = source.defaultBinding;\n  }\n  target.names = [\n    ...new Set([...(target.names ?? []), ...(source.names ?? [])]),\n  ];\n  if (source.namespaceBinding !== undefined) {\n    target.namespaceBinding = source.namespaceBinding;\n  }\n  if (source.typeDefaultBinding !== undefined) {\n    target.typeDefaultBinding = source.typeDefaultBinding;\n  }\n  target.typeNames = [\n    ...new Set([...(target.typeNames ?? []), ...(source.typeNames ?? [])]),\n  ];\n  if (source.typeNamespaceBinding !== undefined) {\n    target.typeNamespaceBinding = source.typeNamespaceBinding;\n  }\n};\n","import type { IBiMap } from './types';\n\nexport class BiMap<Key, Value> implements IBiMap<Key, Value> {\n  private map = new Map<Key, Value>();\n  private reverse = new Map<Value, Key>();\n\n  delete(key: Key): boolean {\n    const value = this.map.get(key);\n    if (value !== undefined) {\n      this.reverse.delete(value);\n    }\n    return this.map.delete(key);\n  }\n\n  deleteValue(value: Value): boolean {\n    const key = this.reverse.get(value);\n    if (key !== undefined) {\n      this.map.delete(key);\n    }\n    return this.reverse.delete(value);\n  }\n\n  entries(): IterableIterator<[Key, Value]> {\n    return this.map.entries();\n  }\n\n  get(key: Key): Value | undefined {\n    return this.map.get(key);\n  }\n\n  getKey(value: Value): Key | undefined {\n    return this.reverse.get(value);\n  }\n\n  hasKey(key: Key): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(value: Value): boolean {\n    return this.reverse.has(value);\n  }\n\n  keys(): IterableIterator<Key> {\n    return this.map.keys();\n  }\n\n  set(key: Key, value: Value): this {\n    const oldValue = this.map.get(key);\n    if (oldValue !== undefined && oldValue !== value) {\n      this.reverse.delete(oldValue);\n    }\n    const oldKey = this.reverse.get(value);\n    if (oldKey !== undefined && oldKey !== key) {\n      this.map.delete(oldKey);\n    }\n    this.map.set(key, value);\n    this.reverse.set(value, key);\n    return this;\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  values(): IterableIterator<Value> {\n    return this.map.values();\n  }\n\n  [Symbol.iterator](): IterableIterator<[Key, Value]> {\n    return this.map[Symbol.iterator]();\n  }\n}\n","import { BiMap } from '../bimap/bimap';\nimport type {\n  IFileIdentifier,\n  IFileIn,\n  IFileOut,\n  IFileRegistry,\n} from './types';\n\nexport class FileRegistry implements IFileRegistry {\n  private _id: number = 0;\n  private referenceOrder: Set<number> = new Set();\n  private registerOrder: Set<number> = new Set();\n  private selectorToId: Map<string, number> = new Map();\n  private values: Map<number, IFileOut> = new Map();\n\n  get(identifier: IFileIdentifier): IFileOut | undefined {\n    const file = this.identifierToFile(identifier);\n\n    if (file.id !== undefined) {\n      return this.values.get(file.id);\n    }\n\n    const selector =\n      file.selector !== undefined ? JSON.stringify(file.selector) : undefined;\n\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        return this.values.get(id);\n      }\n    }\n\n    return;\n  }\n\n  get id(): number {\n    return this._id++;\n  }\n\n  private identifierToFile(\n    identifier: IFileIdentifier,\n  ): Pick<IFileIn, 'id' | 'selector'> {\n    return typeof identifier === 'number'\n      ? { id: identifier }\n      : { selector: identifier };\n  }\n\n  isRegistered(identifier: IFileIdentifier): boolean {\n    const file = this.get(identifier);\n    return file ? this.registerOrder.has(file.id) : false;\n  }\n\n  reference(identifier: IFileIdentifier): IFileOut {\n    const file = this.identifierToFile(identifier);\n    return this.register(file);\n  }\n\n  *referenced(): IterableIterator<IFileOut> {\n    for (const id of this.referenceOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n\n  register(file: IFileIn): IFileOut {\n    if (file.id !== undefined) {\n      const result = this.values.get(file.id);\n      if (!result) {\n        throw new Error(\n          `File with ID ${file.id} not found. To register a new file, leave the ID undefined.`,\n        );\n      }\n      return result;\n    }\n\n    const hasOtherKeys = Object.keys(file).some(\n      (key) => !['id', 'selector'].includes(key),\n    );\n\n    let result: IFileOut | undefined;\n\n    const selector =\n      file.selector !== undefined ? JSON.stringify(file.selector) : undefined;\n    if (selector) {\n      const id = this.selectorToId.get(selector);\n      if (id !== undefined) {\n        result = this.values.get(id);\n        if (!result) {\n          throw new Error(\n            `File with ID ${id} not found. The selector ${selector} matched an ID, but there was no result. This is likely an issue with the application logic.`,\n          );\n        }\n        if (!hasOtherKeys) {\n          return result;\n        }\n      }\n    }\n\n    const id = result?.id !== undefined ? result.id : this.id;\n    result = {\n      ...result,\n      ...file, // clone to avoid mutation\n      id,\n      resolvedNames: result?.resolvedNames ?? new BiMap(),\n      symbols: result?.symbols ?? {\n        body: [],\n        exports: [],\n        imports: [],\n      },\n    };\n    this.values.set(id, result);\n\n    if (hasOtherKeys) {\n      this.registerOrder.add(id);\n      if (this.referenceOrder.has(id)) {\n        this.referenceOrder.delete(id);\n      }\n    } else {\n      this.referenceOrder.add(id);\n    }\n\n    if (selector) {\n      this.selectorToId.set(selector, id);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<IFileOut> {\n    for (const id of this.registerOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n}\n","/**\n * Wraps an ID in namespace to avoid collisions when replacing it.\n *\n * @param symbolId Stringified symbol ID to use.\n * @returns The wrapped placeholder ID.\n */\nexport const wrapId = (symbolId: string): string => `_heyapi_${symbolId}_`;\n\n/**\n * Unwraps an ID from namespace.\n *\n * @param wrappedId The wrapped placeholder ID.\n * @returns Stringified ID to use.\n */\nconst unwrapId = (wrappedId: string): string =>\n  wrappedId.slice('_heyapi_'.length, -1);\n\n/**\n * Returns a RegExp instance to match ID placeholders.\n *\n * @returns RegExp instance to match ID placeholders.\n */\nconst createPlaceholderRegExp = (): RegExp => new RegExp(wrapId('\\\\d+'), 'g');\n\n/**\n *\n * @param source The source string to replace.\n * @param replacerFn Accepts a symbol ID, returns resolved symbol name.\n * @returns The replaced source string.\n */\nexport const renderIds = (\n  source: string,\n  replacerFn: (symbolId: number) => string | undefined,\n): string =>\n  source.replace(createPlaceholderRegExp(), (match) => {\n    const symbolId = Number.parseInt(unwrapId(match), 10);\n    return replacerFn(symbolId) || match;\n  });\n","import type { ISymbolMeta } from '../extensions/types';\nimport { wrapId } from '../renderer/utils';\nimport type {\n  ISymbolIdentifier,\n  ISymbolIn,\n  ISymbolOut,\n  ISymbolRegistry,\n} from './types';\n\ntype IndexEntry = [string, unknown];\ntype IndexKeySpace = ReadonlyArray<IndexEntry>;\ntype QueryCacheKey = string;\ntype SymbolId = number;\n\nexport class SymbolRegistry implements ISymbolRegistry {\n  private _id: SymbolId = 0;\n  private indices: Map<IndexEntry[0], Map<IndexEntry[1], Set<SymbolId>>> =\n    new Map();\n  private nodes: Map<SymbolId, unknown> = new Map();\n  private queryCache: Map<QueryCacheKey, ReadonlyArray<SymbolId>> = new Map();\n  private queryCacheDependencies: Map<QueryCacheKey, Set<QueryCacheKey>> =\n    new Map();\n  private registerOrder: Set<SymbolId> = new Set();\n  private stubCache: Map<QueryCacheKey, SymbolId> = new Map();\n  private stubs: Set<SymbolId> = new Set();\n  private values: Map<SymbolId, ISymbolOut> = new Map();\n\n  get(identifier: ISymbolIdentifier): ISymbolOut | undefined {\n    return typeof identifier === 'number'\n      ? this.values.get(identifier)\n      : this.query(identifier)[0];\n  }\n\n  getValue(symbolId: SymbolId): unknown {\n    return this.nodes.get(symbolId);\n  }\n\n  hasValue(symbolId: SymbolId): boolean {\n    return this.nodes.has(symbolId);\n  }\n\n  get id(): SymbolId {\n    return this._id++;\n  }\n\n  isRegistered(identifier: ISymbolIdentifier): boolean {\n    const symbol = this.get(identifier);\n    return symbol ? this.registerOrder.has(symbol.id) : false;\n  }\n\n  query(filter: ISymbolMeta): ReadonlyArray<ISymbolOut> {\n    const cacheKey = this.buildCacheKey(filter);\n    const cachedIds = this.queryCache.get(cacheKey);\n    if (cachedIds) {\n      return cachedIds.map((symbolId) => this.values.get(symbolId)!);\n    }\n    const sets: Array<Set<SymbolId>> = [];\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    const cacheDependencies = new Set<QueryCacheKey>();\n    let missed = false;\n    for (const indexEntry of indexKeySpace) {\n      cacheDependencies.add(this.serializeIndexEntry(indexEntry));\n      const values = this.indices.get(indexEntry[0]);\n      if (!values) {\n        missed = true;\n        break;\n      }\n      const set = values.get(indexEntry[1]);\n      if (!set) {\n        missed = true;\n        break;\n      }\n      sets.push(set);\n    }\n    if (missed || !sets.length) {\n      this.queryCacheDependencies.set(cacheKey, cacheDependencies);\n      this.queryCache.set(cacheKey, []);\n      return [];\n    }\n    let result = new Set(sets[0]);\n    for (const set of sets.slice(1)) {\n      result = new Set([...result].filter((symbolId) => set.has(symbolId)));\n    }\n    const resultIds = [...result];\n    this.queryCacheDependencies.set(cacheKey, cacheDependencies);\n    this.queryCache.set(cacheKey, resultIds);\n    return resultIds.map((symbolId) => this.values.get(symbolId)!);\n  }\n\n  reference(meta: ISymbolMeta): ISymbolOut {\n    const [registered] = this.query(meta);\n    if (registered) return registered;\n    const cacheKey = this.buildCacheKey(meta);\n    const cachedId = this.stubCache.get(cacheKey);\n    if (cachedId !== undefined) return this.values.get(cachedId)!;\n    const id = this.id;\n    const stub: ISymbolOut = {\n      id,\n      meta,\n      placeholder: wrapId(String(id)),\n    };\n    this.values.set(stub.id, stub);\n    this.stubs.add(stub.id);\n    this.stubCache.set(cacheKey, stub.id);\n    return stub;\n  }\n\n  register(symbol: ISymbolIn): ISymbolOut {\n    const id = symbol.id !== undefined ? symbol.id : this.id;\n    const result: ISymbolOut = {\n      ...symbol, // clone to avoid mutation\n      id,\n      placeholder: symbol.placeholder ?? wrapId(String(id)),\n    };\n    this.values.set(result.id, result);\n    this.registerOrder.add(result.id);\n    if (result.meta) {\n      const indexKeySpace = this.buildIndexKeySpace(result.meta);\n      this.indexSymbol(result.id, indexKeySpace);\n      this.invalidateCache(indexKeySpace);\n      this.replaceStubs(result, indexKeySpace);\n    }\n    return result;\n  }\n\n  *registered(): IterableIterator<ISymbolOut> {\n    for (const id of this.registerOrder.values()) {\n      yield this.values.get(id)!;\n    }\n  }\n\n  setValue(symbolId: SymbolId, value: unknown): Map<SymbolId, unknown> {\n    return this.nodes.set(symbolId, value);\n  }\n\n  private buildCacheKey(filter: ISymbolMeta): QueryCacheKey {\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    return indexKeySpace\n      .map((indexEntry) => this.serializeIndexEntry(indexEntry))\n      .sort() // ensure order-insensitivity\n      .join('|');\n  }\n\n  private buildIndexKeySpace(meta: ISymbolMeta, prefix = ''): IndexKeySpace {\n    const entries: Array<IndexEntry> = [];\n    for (const [key, value] of Object.entries(meta)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        entries.push(...this.buildIndexKeySpace(value as ISymbolMeta, path));\n      } else {\n        entries.push([path, value]);\n      }\n    }\n    return entries;\n  }\n\n  private indexSymbol(symbolId: SymbolId, indexKeySpace: IndexKeySpace): void {\n    for (const [key, value] of indexKeySpace) {\n      if (!this.indices.has(key)) this.indices.set(key, new Map());\n      const values = this.indices.get(key)!;\n      const set = values.get(value) ?? new Set();\n      set.add(symbolId);\n      values.set(value, set);\n    }\n  }\n\n  private invalidateCache(indexKeySpace: IndexKeySpace): void {\n    const changed = indexKeySpace.map((indexEntry) =>\n      this.serializeIndexEntry(indexEntry),\n    );\n    for (const [\n      cacheKey,\n      cacheDependencies,\n    ] of this.queryCacheDependencies.entries()) {\n      for (const key of changed) {\n        if (cacheDependencies.has(key)) {\n          this.queryCacheDependencies.delete(cacheKey);\n          this.queryCache.delete(cacheKey);\n          break;\n        }\n      }\n    }\n  }\n\n  private isSubset(sub: IndexKeySpace, sup: IndexKeySpace): boolean {\n    const supMap = new Map(sup);\n    for (const [key, value] of sub) {\n      if (!supMap.has(key) || supMap.get(key) !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private replaceStubs(symbol: ISymbolOut, indexKeySpace: IndexKeySpace): void {\n    for (const stubId of this.stubs.values()) {\n      const stub = this.values.get(stubId);\n      if (\n        stub?.meta &&\n        this.isSubset(this.buildIndexKeySpace(stub.meta), indexKeySpace)\n      ) {\n        const cacheKey = this.buildCacheKey(stub.meta);\n        this.stubCache.delete(cacheKey);\n        this.values.set(stubId, Object.assign(stub, symbol));\n        this.stubs.delete(stubId);\n      }\n    }\n  }\n\n  private serializeIndexEntry(indexEntry: IndexEntry): string {\n    return `${indexEntry[0]}:${JSON.stringify(indexEntry[1])}`;\n  }\n}\n","import path from 'node:path';\n\nimport type { IProjectRenderMeta } from '../extensions/types';\nimport { FileRegistry } from '../files/registry';\nimport type { IFileOut, IFileSelector } from '../files/types';\nimport type { IOutput } from '../output/types';\nimport type { IRenderer } from '../renderer/types';\nimport { SymbolRegistry } from '../symbols/registry';\nimport type { ISymbolOut } from '../symbols/types';\nimport type { IProject } from './types';\n\nconst externalSourceSymbol = '@';\n\nexport class Project implements IProject {\n  private symbolIdToFileIds: Map<number, Set<number>> = new Map();\n\n  readonly defaultFileName: string;\n  readonly files = new FileRegistry();\n  readonly fileName?: (name: string) => string;\n  readonly renderers: Record<string, IRenderer> = {};\n  readonly root: string;\n  readonly symbols = new SymbolRegistry();\n\n  constructor({\n    defaultFileName,\n    fileName,\n    renderers,\n    root,\n  }: Pick<IProject, 'defaultFileName' | 'fileName' | 'renderers' | 'root'>) {\n    this.defaultFileName = defaultFileName ?? 'main';\n    this.fileName = typeof fileName === 'string' ? () => fileName : fileName;\n    this.renderers = renderers;\n    this.root = root;\n  }\n\n  private getRenderer(file: IFileOut): IRenderer | undefined {\n    return file.extension ? this.renderers[file.extension] : undefined;\n  }\n\n  private prepareFiles(): void {\n    // TODO: infer extension from symbols\n    const extension = '.ts';\n    for (const symbol of this.symbols.registered()) {\n      const selector = this.symbolToFileSelector(symbol);\n      const file = this.files.reference(selector);\n      file.symbols.body.push(symbol.id);\n      // update symbol->files map\n      const symbolIdToFileIds =\n        this.symbolIdToFileIds.get(symbol.id) ?? new Set();\n      symbolIdToFileIds.add(file.id);\n      this.symbolIdToFileIds.set(symbol.id, symbolIdToFileIds);\n      // update re-exports\n      if (symbol.exportFrom) {\n        for (const exportFrom of symbol.exportFrom) {\n          const exportSelector = [exportFrom];\n          const exportFile = this.files.reference(exportSelector);\n          if (exportFile.id !== file.id) {\n            exportFile.symbols.exports.push(symbol.id);\n          }\n        }\n      }\n    }\n    for (const file of this.files.referenced()) {\n      if (!file.selector) continue;\n      if (file.selector[0] === externalSourceSymbol) {\n        const filePath = file.selector[1];\n        if (!filePath) {\n          this.files.register({\n            external: true,\n            selector: file.selector,\n          });\n          continue;\n        }\n        const extension = path.extname(filePath);\n        if (!extension) {\n          this.files.register({\n            external: true,\n            path: filePath,\n            selector: file.selector,\n          });\n          continue;\n        }\n        this.files.register({\n          extension,\n          external: true,\n          path: filePath,\n          selector: file.selector,\n        });\n        continue;\n      }\n      const dirs = file.selector.slice(0, -1);\n      let name = file.selector[file.selector.length - 1]!;\n      name = this.fileName?.(name) || name;\n      this.files.register({\n        extension,\n        name,\n        path: path.resolve(this.root, ...dirs, `${name}${extension}`),\n        selector: file.selector,\n      });\n    }\n\n    // TODO: track symbol dependencies and inject imports into files\n    // based on symbol references so the render step can just render\n  }\n\n  render(meta?: IProjectRenderMeta): ReadonlyArray<IOutput> {\n    this.prepareFiles();\n    const files: Map<number, IOutput> = new Map();\n    for (const file of this.files.registered()) {\n      if (file.external || !file.path) continue;\n      const renderer = this.getRenderer(file);\n      if (!renderer) continue;\n      files.set(file.id, {\n        content: renderer.renderSymbols(file, this, meta),\n        path: file.path,\n      });\n    }\n    for (const [fileId, value] of files.entries()) {\n      const file = this.files.get(fileId)!;\n      const renderer = this.getRenderer(file)!;\n      const content = renderer.renderFile(value.content, file, this, meta);\n      if (content) {\n        files.set(file.id, { ...value, content });\n      } else {\n        files.delete(file.id);\n      }\n    }\n    return Array.from(files.values());\n  }\n\n  symbolIdToFiles(symbolId: number): ReadonlyArray<IFileOut> {\n    const fileIds = this.symbolIdToFileIds.get(symbolId);\n    return Array.from(fileIds ?? []).map((fileId) => this.files.get(fileId)!);\n  }\n\n  private symbolToFileSelector(symbol: ISymbolOut): IFileSelector {\n    if (symbol.external) {\n      return [externalSourceSymbol, symbol.external];\n    }\n    const filePath = symbol.getFilePath?.(symbol);\n    if (filePath) {\n      return filePath.split('/');\n    }\n    return [this.defaultFileName];\n  }\n}\n"],"mappings":"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"}