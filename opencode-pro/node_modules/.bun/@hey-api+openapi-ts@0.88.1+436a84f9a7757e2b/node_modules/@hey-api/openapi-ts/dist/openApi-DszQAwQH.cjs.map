{"version":3,"file":"openApi-DszQAwQH.cjs","names":["__filename","__dirname","path","fs","ts","fs","path","path","colors","registryRegExp","getRegistryUrl","parseShorthand","queryParams: string | undefined","registryRegExp","getRegistryUrl","namespace","parseShorthand","defaultWatch: Watch","inputs: Array<Input>","input: Input","logs: Config['logs']","a: Partial<UserConfig>","b: Partial<UserConfig>","merged: UserConfig","valueToObject: ValueToObject","mappers","ts","path","fs","fields","defaultValue","defaultConfig","uniqueItems: Array<IR.SchemaObject>","typeIds: Array<string>","path","result: OperationResponsesMap","errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","defaultResponse: IR.ResponseObject | undefined","result: R | void | undefined","ts","ts","ts","ts","modifiers: Array<ts.Modifier>","ts","ts","typeExprFactory: TypeExprFactory | undefined","typeIdxFactory: TypeIdxFactory | undefined","typeOfExprFactory: TypeOfExprFactory | undefined","typeOperatorFactory: TypeOperatorFactory | undefined","typeQueryFactory: TypeQueryFactory | undefined","ts","base","ts","ts","ts","ts","ts","entries: Record<string, string>","ts","ts","ts","ts","base","ts","ts","asFactory: AsFactory | undefined","ts","ts","ts","ts","ts","ts","ts","ts","attrFactory: AttrFactory | undefined","awaitFactory: AwaitFactory | undefined","callFactory: CallFactory | undefined","returnFactory: ReturnFactory | undefined","ts","base","ts","ts","ts","ts","ts","ts","missing: Array<string>","ts","ts","ts","normalized: Array<string | ts.Expression>","ts","spans: Array<ts.TemplateSpan>","ts","ts","ts","ts","elseNode: ts.Statement | undefined","ts","ts","ts","ts","flat: Array<ts.TypeNode>","ts","ts","ts","missing: Array<string>","ts","ts","ts","fromValue","ts","base","ts","ts","missing: Array<string>","ts","missing: Array<string>","flat: Array<ts.TypeNode>","ts","ts","normalized: Array<string | ts.TypeNode>","ts","spans: Array<ts.TemplateLiteralTypeSpan>","exprValue","typeValue","auth: Array<Auth>","path","nameToLocations: Record<string, Set<Location>>","signatureParameters: SignatureParameters","fields: Array<Field>","signatureParameter: SignatureParameter","className: string | undefined","methodName: string | undefined","classCandidates: Array<string>","path","dataType","result: OperationParameters","query: SymbolMeta","responseTypeValue: ReturnType<typeof getResponseType> | undefined","statements: Array<ReturnType<typeof $.return | typeof $.const>>","args: Array<ReturnType<typeof $.expr>>","config: Array<ReturnType<typeof $.object>>","clientExpression: ReturnType<typeof $.attr | typeof $.binary>","EOL","comments: Array<string>","createHttpRequests: AngularCommonPlugin['Handler']","methodAccess: ReturnType<typeof $.attr | typeof $.call>","createHttpResources: AngularCommonPlugin['Handler']","handler: AngularCommonPlugin['Handler']","defaultConfig: AngularCommonPlugin['Config']","defineConfig","__filename","__dirname","path","renamed: Map<string, string> | undefined","fs","dirPath","errorResponse: Url","path","createClient: PluginHandler","defaultConfig: HeyApiClientAngularPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientAxiosPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientFetchPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientKyPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNextPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNuxtPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientOfetchPlugin['Config']","defineConfig","defaultConfig","satisfies: typeof semver.satisfies","handler: HeyApiSchemasPlugin['Handler']","defaultConfig: HeyApiSchemasPlugin['Config']","defineConfig","defaultConfig","p","m","t","g","node","handlerV1: HeyApiSdkPlugin['Handler']","handler: HeyApiSdkPlugin['Handler']","handlerV1","defaultConfig: HeyApiSdkPlugin['Config']","defineConfig","defaultConfig","bigIntExpressions: ExpressionTransformer","dateExpressions: ExpressionTransformer","ts","query: SymbolMeta","nodes: Array<ts.Expression | ts.Statement | Expr>","arrayNodes: Array<ts.Expression | ts.Statement | Expr>","handler: HeyApiTransformersPlugin['Handler']","defaultConfig: HeyApiTransformersPlugin['Config']","defineConfig","defaultConfig","types: Array<TypeTsDsl>","comments: Array<string>","typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  >","key: string | undefined","node","type","irSchema: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","operationToDataType","data: IR.SchemaObject","dataRequired: Array<string>","irSchemaToAst","node","data: IR.SchemaObject","dataRequired: Array<string>","node","irSchemaToAst","arrayToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","booleanToAst","enumToAst","irSchemaToAst","neverToAst","nullToAst","numberToAst","objectToAst","indexSchemas: Array<IR.SchemaObject>","irSchemaToAst","p","stringToAst","query: SymbolMeta","queryTypeId: SymbolMeta","symbolTypeId","tupleToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","irSchemaWithTypeToAst","handleComponent","handlerV1: HeyApiTypeScriptPlugin['Handler']","servers: Array<IR.ServerObject>","webhookNames: Array<string>","Api","irSchemaToAstV1","handler: HeyApiTypeScriptPlugin['Handler']","handlerV1","defaultConfig: HeyApiTypeScriptPlugin['Config']","Api","defineConfig","defaultConfig","handleMeta","useTypeData","useTypeError","typeErrorName: string | undefined","useTypeResponse","createMutationOptions","useTypeData","useTypeError","useTypeResponse","fnOptions","statements: Array<ReturnType<typeof $.var | typeof $.return>>","handleMeta","TOptionsType","createQueryKeyFunction","createQueryKeyLiteral","tagsExpression: ReturnType<typeof $.array> | undefined","createQueryKeyType","queryKeyStatement","useTypeData","optionsParamName","createQueryOptions","keyExpression: ReturnType<typeof $.call>","queryKeyStatement","tagsExpr: ReturnType<typeof $.array> | undefined","useTypeData","statements: Array<ReturnType<typeof $.return | typeof $.const>>","handleMeta","handlerV0: PiniaColadaPlugin['Handler']","queryFn: string","handler: PiniaColadaPlugin['Handler']","defaultConfig: PiniaColadaPlugin['Config']","handler","defineConfig","defaultConfig","typeErrorName: string | undefined","tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined","statements: Array<TsDsl<any>>","fnOptions","statements: Array<TsDsl<any>>","optionsParamName","statements: Array<TsDsl<any>>","handlerV5: PluginHandler","queryFn: string","handler: PluginHandler","defaultConfig: TanStackAngularQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackReactQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSolidQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSvelteQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackVueQueryPlugin['Config']","handler","defineConfig","defaultConfig","Api","identifiers","exportAst","identifiers","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaToAst","stringToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaWithTypeToAst","nullToAst","objectToAst","stringToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","handleComponent","handlerV2: ArktypePlugin['Handler']","handler: ArktypePlugin['Handler']","handlerV2","defaultConfig: ArktypePlugin['Config']","Api","fields","defaultValue","defineConfig","defaultConfig","errorsTypeReference: ReturnType<typeof $.type> | undefined","responsesTypeReference: ReturnType<typeof $.type> | undefined","handler: FastifyPlugin['Handler']","defaultConfig: FastifyPlugin['Config']","defineConfig","defaultConfig","statements: Array<TsDsl<any>>","handlerV2: SwrPlugin['Handler']","queryFn: string","handler: SwrPlugin['Handler']","defaultConfig: SwrPlugin['Config']","handler","defineConfig","defaultConfig","identifiers","defaultValidatorResolver","identifiers","args: ValidatorResolverArgs","Api","identifiers","exportAst","v","identifiers","numberParameter","irOperationToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","irWebhookToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","identifiers","arrayToAst","result: Omit<Ast, 'typeName'>","identifiers","unknownToAst","irSchemaToAst","booleanToAst","pipes: Array<ReturnType<typeof $.call>>","identifiers","enumToAst","enumMembers: Array<ReturnType<typeof $.literal>>","unknownToAst","identifiers","neverToAst","identifiers","nullToAst","identifiers","numberToAst","literalValue: ReturnType<typeof $.fromValue>","identifiers","pipes: Array<ReturnType<typeof $.call>>","numberParameter","defaultObjectBaseResolver","identifiers","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","pipes: Array<ReturnType<typeof $.call>>","irSchemaToAst","additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined","args: ObjectBaseResolverArgs","defaultFormatResolver","identifiers","stringToAst","pipes: Array<ReturnType<typeof $.call>>","args: FormatResolverArgs","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaToAst","unknownToAst","undefinedToAst","identifiers","voidToAst","identifiers","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Ast","query: SymbolMeta","identifiers","irSchemaWithTypeToAst","callParameter: ReturnType<typeof $.fromValue> | undefined","numberParameter","handleComponent","handlerV1: ValibotPlugin['Handler']","handler: ValibotPlugin['Handler']","defaultConfig: ValibotPlugin['Config']","Api","defineConfig","defaultConfig","defaultValidatorResolver","args: ValidatorResolverArgs","defaultValidatorResolver","args: ValidatorResolverArgs","args: ValidatorResolverArgs","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","result: Partial<Omit<Ast, 'typeName'>>","arrayToAst","result: Partial<Omit<Ast, 'typeName'>>","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.expr | typeof $.call>","checks: Array<ReturnType<typeof $.call>>","booleanToAst","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","enumToAst","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","unknownToAst","neverToAst","result: Partial<Omit<Ast, 'typeName'>>","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","numberToAst","result: Partial<Omit<Ast, 'typeName'>>","checks: Array<ReturnType<typeof $.call>>","defaultObjectBaseResolver","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaToAst","additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined","args: ObjectBaseResolverArgs","defaultFormatResolver","stringToAst","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","args: FormatResolverArgs","checks: Array<ReturnType<typeof $.call>>","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","result: Partial<Omit<Ast, 'typeName'>>","voidToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","schema","handleComponent","handlerMini: ZodPlugin['Handler']","unknownToAst","arrayToAst","arrayExpression: ReturnType<typeof $.call> | undefined","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","booleanToAst","chain: ReturnType<typeof $.call>","enumToAst","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","unknownToAst","enumExpression: ReturnType<typeof $.call>","neverToAst","nullToAst","numberToAst","defaultObjectBaseResolver","objectToAst","irSchemaToAst","additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined","result: Partial<Omit<Ast, 'typeName'>>","args: ObjectBaseResolverArgs","defaultFormatResolver","stringToAst","chain: ReturnType<typeof $.call>","args: FormatResolverArgs","tupleToAst","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","handleComponent","handlerV3: ZodPlugin['Handler']","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined","args: ObjectBaseResolverArgs","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","args: FormatResolverArgs","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","ast: Partial<Ast>","query: SymbolMeta","schema","handlerV4: ZodPlugin['Handler']","handler: ZodPlugin['Handler']","defaultConfig: ZodPlugin['Config']","colors","fields","defaultValue","defaultConfig","defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n}","angularCommon","heyApiClientAngular","heyApiClientAxios","heyApiClientFetch","heyApiClientKy","heyApiClientNext","heyApiClientNuxt","heyApiClientOfetch","heyApiSchemas","heyApiSdk","heyApiTransformers","heyApiTypeScript","piniaColada","tanStackAngularQuery","tanStackReactQuery","tanStackSolidQuery","tanStackSvelteQuery","tanStackVueQuery","plugins: Config['plugins']","context: PluginContext","userPlugin","defaultConfig","defaultPlugin","userPluginsConfig: Config['plugins']","definedPlugins: UserConfig['plugins']","configs: Array<UserConfig>","dependencies: Record<string, string>","configurationFile: string | undefined","colors","results: Array<ArrayOnly<ConfigResult>>","errors: Array<Error>","path","plugins: Pick<Config, 'plugins' | 'pluginOrder'>","config: Config","joinedValues","values: string[]","search: string[]","entries: Array<[string, string]>","arrayBuffer: ArrayBuffer | undefined","hasChanged: boolean | undefined","response: Response | undefined","ts","imports: Map<string, Binding>","exports: Map<string, Binding>","exports","path","lines: Array<string>","specifiers: Array<ts.ExportSpecifier>","namespaceBinding: string | undefined","finalAlias: string | undefined","name","specifiers: Array<ts.ImportSpecifier>","defaultBinding: ts.Identifier | undefined","namedImports: Array<{\n          isTypeOnly: boolean;\n          name: string;\n          propertyName: ts.ModuleExportName | undefined;\n        }>","isTypeOnly","base","declIndex: Map<string, number>","walkDeclarations: WalkFn","walkTopological: WalkFn","order: Array<string>","getGroup: GetPointerPriorityFn","walk: WalkFn","matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind>","patterns: Record<IrTopLevelKind, RegExp>","kind","kindPriority: KindPriority","partial: Partial<KindPriority>","getIrPointerPriority: GetPointerPriorityFn","defaultGetKind: Required<Required<Hooks>['operations']>['getKind']","callback: (event: WalkEvent<TKind>) => void","events: ReadonlyArray<TKind>","options: WalkOptions<TKind>","event: WalkEvent | undefined","baseEvent: BaseEvent","symbolIn: SymbolIn","path","result: EventHooks","Project","base","result: string","path","namespace","keys: Array<string>","regexps: Array<RegExp>","path","filters: Filters","dependencies: Set<string> | undefined","resourceMetadata: ResourceMetadata","path","namespace","base","path","walkSchemas","path","rootEnums: Record<string, unknown>","rootEnumSignatures: Record<string, string>","inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }>","signatureToName: Record<string, string | undefined>","signatureToSchema: Record<string, unknown>","path","childResult: Partial<PointerDependenciesResult>","worklist: Set<string>","graph: Graph","walk","path","deprecated: boolean | undefined","tags: Set<string> | undefined","cache: Cache","path","originals: OriginalSchemas","split: SplitSchemas","deepEqual","walk","path","colors","filterSpec","filtered: typeof spec.definitions","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","values: Array<string>","getSchemaType","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseEnum","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseRef","irSchema","parseNullableType","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","name","getSchemaType","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","requestBodyObject: IRBodyObject","requestBodyObjectRequired: Array<string>","schema: SchemaObject","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","irSecuritySchemeObject: IR.SecurityObject | undefined","parsePathOperation","path","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","parseServers","schemes: ReadonlyArray<string>","path","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","commonOperation: OperationObject","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >","parametersArrayToObject","filterSpec","filtered: typeof spec.components.parameters","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseAnyOf","parseEnum","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseOneOf","parseRef","irSchema","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","refSchema: SchemaObject | ReferenceObject | undefined","mediaTypeObjects","content","name","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","parsePathOperation","path","defaultAllowReserved","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","mediaTypeObjects","content","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","parseParameter","requestBodyToIrRequestBody","mediaTypeObjects","content","irRequestBody: IR.RequestBodyObject","schemaToIrSchema","parseRequestBody","parseServers","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    }","parametersArrayToObject","filtered: typeof spec.components.parameters","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","objects: Array<Content>","schemaItems: Array<IR.SchemaObject>","schemaProperties: Record<string, IR.SchemaObject>","patternProperties: Record<string, IR.SchemaObject>","irSchema: IR.SchemaObject","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","nestedItems: Array<IR.SchemaObject>","enumType: SchemaType<SchemaObject> | undefined","irSchema","irRefSchema: IR.SchemaObject","typeIrSchema: IR.SchemaObject","refSchema: SchemaObject | undefined","content","name","schema","irOperation: IR.OperationObject","content","securitySchemeObjects: Map<string, IR.SecurityObject>","path","parametersObject: IR.ParametersObject","content","finalSchema: SchemaObject","irParameter: IR.ParameterObject","content","irRequestBody: IR.RequestBodyObject","issues: Array<ValidatorIssue>","path","state: Parameters<typeof parseWebhookOperation>[0]['state']","operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    >","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >"],"sources":["../src/generate/tsConfig.ts","../src/generate/utils.ts","../src/error.ts","../src/utils/input/heyApi.ts","../src/utils/input/readme.ts","../src/utils/input/scalar.ts","../src/utils/input/index.ts","../src/config/input.ts","../src/config/logs.ts","../src/config/merge.ts","../src/config/utils/config.ts","../src/config/output.ts","../src/config/packages.ts","../src/config/parser.ts","../src/plugins/shared/utils/config.ts","../src/utils/stringCase.ts","../src/openApi/shared/utils/name.ts","../src/ir/parameter.ts","../src/ir/schema.ts","../src/ir/utils.ts","../src/ir/operation.ts","../src/openApi/common/parser/sanitize.ts","../src/plugins/@hey-api/client-core/utils.ts","../src/plugins/shared/utils/refs.ts","../src/ts-dsl/base.ts","../src/ts-dsl/expr/id.ts","../src/ts-dsl/layout/newline.ts","../src/ts-dsl/mixins/apply.ts","../src/ts-dsl/mixins/args.ts","../src/ts-dsl/decl/decorator.ts","../src/ts-dsl/mixins/decorator.ts","../src/ts-dsl/layout/doc.ts","../src/ts-dsl/mixins/doc.ts","../src/ts-dsl/mixins/modifiers.ts","../src/ts-dsl/type/param.ts","../src/ts-dsl/mixins/type-params.ts","../src/ts-dsl/mixins/value.ts","../src/ts-dsl/mixins/type-args.ts","../src/ts-dsl/mixins/type-expr.ts","../src/ts-dsl/type/attr.ts","../src/ts-dsl/type/expr.ts","../src/ts-dsl/decl/field.ts","../src/ts-dsl/stmt/stmt.ts","../src/ts-dsl/mixins/do.ts","../src/ts-dsl/mixins/optional.ts","../src/ts-dsl/token.ts","../src/ts-dsl/decl/pattern.ts","../src/ts-dsl/mixins/pattern.ts","../src/ts-dsl/decl/param.ts","../src/ts-dsl/mixins/param.ts","../src/ts-dsl/decl/init.ts","../src/ts-dsl/decl/method.ts","../src/ts-dsl/decl/class.ts","../src/utils/regexp.ts","../src/ts-dsl/expr/prefix.ts","../src/ts-dsl/mixins/as.ts","../src/ts-dsl/expr/literal.ts","../src/ts-dsl/utils/prop.ts","../src/ts-dsl/decl/member.ts","../src/ts-dsl/decl/enum.ts","../src/ts-dsl/decl/func.ts","../src/ts-dsl/decl/getter.ts","../src/ts-dsl/decl/setter.ts","../src/ts-dsl/mixins/layout.ts","../src/ts-dsl/expr/array.ts","../src/ts-dsl/mixins/expr.ts","../src/ts-dsl/expr/as.ts","../src/ts-dsl/expr/binary.ts","../src/ts-dsl/mixins/operator.ts","../src/ts-dsl/expr/attr.ts","../src/ts-dsl/expr/await.ts","../src/ts-dsl/expr/call.ts","../src/ts-dsl/expr/expr.ts","../src/ts-dsl/layout/hint.ts","../src/ts-dsl/mixins/hint.ts","../src/ts-dsl/expr/prop.ts","../src/ts-dsl/expr/object.ts","../src/ts-dsl/expr/fromValue.ts","../src/ts-dsl/expr/new.ts","../src/ts-dsl/expr/regexp.ts","../src/ts-dsl/expr/template.ts","../src/ts-dsl/expr/ternary.ts","../src/ts-dsl/expr/typeof.ts","../src/ts-dsl/layout/note.ts","../src/ts-dsl/stmt/if.ts","../src/ts-dsl/stmt/return.ts","../src/ts-dsl/stmt/throw.ts","../src/ts-dsl/stmt/var.ts","../src/ts-dsl/type/alias.ts","../src/ts-dsl/type/and.ts","../src/ts-dsl/type/literal.ts","../src/ts-dsl/type/idx-sig.ts","../src/ts-dsl/type/prop.ts","../src/ts-dsl/type/object.ts","../src/ts-dsl/type/tuple.ts","../src/ts-dsl/type/fromValue.ts","../src/ts-dsl/type/func.ts","../src/ts-dsl/type/idx.ts","../src/ts-dsl/type/mapped.ts","../src/ts-dsl/type/operator.ts","../src/ts-dsl/type/or.ts","../src/ts-dsl/type/query.ts","../src/ts-dsl/type/template.ts","../src/ts-dsl/index.ts","../src/utils/transform.ts","../src/plugins/@hey-api/sdk/shared/auth.ts","../src/plugins/@hey-api/sdk/shared/constants.ts","../src/utils/ref.ts","../src/plugins/@hey-api/sdk/shared/signature.ts","../src/plugins/@hey-api/sdk/shared/validator.ts","../src/plugins/@hey-api/sdk/shared/operation.ts","../src/utils/escape.ts","../src/plugins/shared/utils/operation.ts","../src/plugins/@angular/common/httpRequests.ts","../src/plugins/@angular/common/httpResources.ts","../src/plugins/@angular/common/plugin.ts","../src/plugins/@angular/common/config.ts","../src/plugins/@hey-api/client-core/config.ts","../src/generate/client.ts","../src/utils/url.ts","../src/plugins/@hey-api/client-core/client.ts","../src/plugins/@hey-api/client-core/createClientConfig.ts","../src/plugins/@hey-api/client-core/plugin.ts","../src/plugins/@hey-api/client-angular/config.ts","../src/plugins/@hey-api/client-axios/config.ts","../src/plugins/@hey-api/client-fetch/config.ts","../src/plugins/@hey-api/client-ky/config.ts","../src/plugins/@hey-api/client-next/config.ts","../src/plugins/@hey-api/client-nuxt/config.ts","../src/plugins/@hey-api/client-ofetch/config.ts","../src/config/utils/package.ts","../src/openApi/shared/utils/identifier.ts","../src/plugins/@hey-api/schemas/plugin.ts","../src/plugins/@hey-api/schemas/config.ts","../src/plugins/@hey-api/sdk/shared/class.ts","../src/plugins/@hey-api/sdk/shared/functions.ts","../src/plugins/@hey-api/sdk/shared/typeOptions.ts","../src/plugins/@hey-api/sdk/v1/plugin.ts","../src/plugins/@hey-api/sdk/plugin.ts","../src/plugins/@hey-api/sdk/config.ts","../src/plugins/@hey-api/transformers/expressions.ts","../src/plugins/@hey-api/transformers/plugin.ts","../src/plugins/@hey-api/transformers/config.ts","../src/plugins/@hey-api/typescript/shared/clientOptions.ts","../src/plugins/shared/utils/schema.ts","../src/plugins/@hey-api/typescript/shared/export.ts","../src/plugins/@hey-api/typescript/shared/operation.ts","../src/plugins/@hey-api/typescript/shared/webhook.ts","../src/plugins/@hey-api/typescript/shared/webhooks.ts","../src/plugins/@hey-api/typescript/v1/toAst/array.ts","../src/plugins/@hey-api/typescript/v1/toAst/boolean.ts","../src/plugins/@hey-api/typescript/v1/toAst/enum.ts","../src/plugins/@hey-api/typescript/v1/toAst/never.ts","../src/plugins/@hey-api/typescript/v1/toAst/null.ts","../src/plugins/@hey-api/typescript/v1/toAst/number.ts","../src/plugins/@hey-api/typescript/v1/toAst/object.ts","../src/plugins/@hey-api/typescript/v1/toAst/string.ts","../src/plugins/@hey-api/typescript/v1/toAst/tuple.ts","../src/plugins/@hey-api/typescript/v1/toAst/undefined.ts","../src/plugins/@hey-api/typescript/v1/toAst/unknown.ts","../src/plugins/@hey-api/typescript/v1/toAst/void.ts","../src/plugins/@hey-api/typescript/v1/toAst/index.ts","../src/plugins/@hey-api/typescript/v1/plugin.ts","../src/plugins/@hey-api/typescript/api.ts","../src/plugins/@hey-api/typescript/plugin.ts","../src/plugins/@hey-api/typescript/config.ts","../src/plugins/@pinia/colada/meta.ts","../src/plugins/@pinia/colada/useType.ts","../src/plugins/@pinia/colada/utils.ts","../src/plugins/@pinia/colada/mutationOptions.ts","../src/plugins/@pinia/colada/queryKey.ts","../src/plugins/@pinia/colada/queryOptions.ts","../src/plugins/@pinia/colada/v0/plugin.ts","../src/plugins/@pinia/colada/plugin.ts","../src/plugins/@pinia/colada/config.ts","../src/plugins/@tanstack/query-core/shared/useType.ts","../src/plugins/@tanstack/query-core/queryKey.ts","../src/plugins/@tanstack/query-core/shared/meta.ts","../src/plugins/@tanstack/query-core/v5/infiniteQueryOptions.ts","../src/plugins/@tanstack/query-core/v5/mutationOptions.ts","../src/plugins/@tanstack/query-core/v5/queryOptions.ts","../src/plugins/@tanstack/query-core/v5/useQuery.ts","../src/plugins/@tanstack/query-core/v5/plugin.ts","../src/plugins/@tanstack/query-core/plugin.ts","../src/plugins/@tanstack/angular-query-experimental/config.ts","../src/plugins/@tanstack/react-query/config.ts","../src/plugins/@tanstack/solid-query/config.ts","../src/plugins/@tanstack/svelte-query/config.ts","../src/plugins/@tanstack/vue-query/config.ts","../src/plugins/arktype/v2/api.ts","../src/plugins/arktype/api.ts","../src/plugins/arktype/constants.ts","../src/plugins/arktype/shared/export.ts","../src/plugins/arktype/v2/toAst/null.ts","../src/plugins/arktype/v2/toAst/object.ts","../src/plugins/arktype/v2/toAst/string.ts","../src/plugins/arktype/v2/toAst/index.ts","../src/plugins/arktype/v2/plugin.ts","../src/plugins/arktype/plugin.ts","../src/plugins/arktype/config.ts","../src/plugins/fastify/plugin.ts","../src/plugins/fastify/config.ts","../src/plugins/swr/v2/useSwr.ts","../src/plugins/swr/v2/plugin.ts","../src/plugins/swr/plugin.ts","../src/plugins/swr/config.ts","../src/plugins/valibot/v1/constants.ts","../src/plugins/valibot/v1/api.ts","../src/plugins/valibot/api.ts","../src/plugins/valibot/shared/pipesToAst.ts","../src/plugins/valibot/shared/export.ts","../src/plugins/valibot/shared/numbers.ts","../src/plugins/valibot/shared/operation.ts","../src/plugins/valibot/shared/webhook.ts","../src/plugins/valibot/v1/toAst/unknown.ts","../src/plugins/valibot/v1/toAst/array.ts","../src/plugins/valibot/v1/toAst/boolean.ts","../src/plugins/valibot/v1/toAst/enum.ts","../src/plugins/valibot/v1/toAst/never.ts","../src/plugins/valibot/v1/toAst/null.ts","../src/plugins/valibot/v1/toAst/number.ts","../src/plugins/valibot/v1/toAst/object.ts","../src/plugins/valibot/v1/toAst/string.ts","../src/plugins/valibot/v1/toAst/tuple.ts","../src/plugins/valibot/v1/toAst/undefined.ts","../src/plugins/valibot/v1/toAst/void.ts","../src/plugins/valibot/v1/toAst/index.ts","../src/plugins/valibot/v1/plugin.ts","../src/plugins/valibot/plugin.ts","../src/plugins/valibot/config.ts","../src/plugins/zod/constants.ts","../src/plugins/zod/mini/api.ts","../src/plugins/zod/v3/api.ts","../src/plugins/zod/v4/api.ts","../src/plugins/zod/api.ts","../src/plugins/zod/shared/export.ts","../src/plugins/zod/shared/module.ts","../src/plugins/zod/shared/numbers.ts","../src/plugins/zod/shared/operation.ts","../src/plugins/zod/shared/webhook.ts","../src/plugins/zod/mini/toAst/unknown.ts","../src/plugins/zod/mini/toAst/array.ts","../src/plugins/zod/mini/toAst/boolean.ts","../src/plugins/zod/mini/toAst/enum.ts","../src/plugins/zod/mini/toAst/never.ts","../src/plugins/zod/mini/toAst/null.ts","../src/plugins/zod/mini/toAst/number.ts","../src/plugins/zod/mini/toAst/object.ts","../src/plugins/zod/mini/toAst/string.ts","../src/plugins/zod/mini/toAst/tuple.ts","../src/plugins/zod/mini/toAst/undefined.ts","../src/plugins/zod/mini/toAst/void.ts","../src/plugins/zod/mini/toAst/index.ts","../src/plugins/zod/mini/plugin.ts","../src/plugins/zod/v3/toAst/unknown.ts","../src/plugins/zod/v3/toAst/array.ts","../src/plugins/zod/v3/toAst/boolean.ts","../src/plugins/zod/v3/toAst/enum.ts","../src/plugins/zod/v3/toAst/never.ts","../src/plugins/zod/v3/toAst/null.ts","../src/plugins/zod/v3/toAst/number.ts","../src/plugins/zod/v3/toAst/object.ts","../src/plugins/zod/v3/toAst/string.ts","../src/plugins/zod/v3/toAst/tuple.ts","../src/plugins/zod/v3/toAst/undefined.ts","../src/plugins/zod/v3/toAst/void.ts","../src/plugins/zod/v3/toAst/index.ts","../src/plugins/zod/v3/plugin.ts","../src/plugins/zod/v4/toAst/unknown.ts","../src/plugins/zod/v4/toAst/array.ts","../src/plugins/zod/v4/toAst/boolean.ts","../src/plugins/zod/v4/toAst/enum.ts","../src/plugins/zod/v4/toAst/never.ts","../src/plugins/zod/v4/toAst/null.ts","../src/plugins/zod/v4/toAst/number.ts","../src/plugins/zod/v4/toAst/object.ts","../src/plugins/zod/v4/toAst/string.ts","../src/plugins/zod/v4/toAst/tuple.ts","../src/plugins/zod/v4/toAst/undefined.ts","../src/plugins/zod/v4/toAst/void.ts","../src/plugins/zod/v4/toAst/index.ts","../src/plugins/zod/v4/plugin.ts","../src/plugins/zod/plugin.ts","../src/plugins/zod/config.ts","../src/plugins/config.ts","../src/config/plugins.ts","../src/config/init.ts","../src/plugins/@hey-api/client-core/bundle/params.ts","../src/plugins/@hey-api/client-core/bundle/pathSerializer.ts","../src/plugins/@hey-api/client-fetch/bundle/utils.ts","../src/getSpec.ts","../src/generate/renderer.ts","../src/utils/minHeap.ts","../src/graph/walk.ts","../src/ir/graph.ts","../src/plugins/shared/utils/instance.ts","../src/ir/context.ts","../src/openApi/shared/utils/operation.ts","../src/openApi/shared/utils/filter.ts","../src/openApi/shared/graph/meta.ts","../src/openApi/shared/utils/schema.ts","../src/openApi/shared/utils/schemaChildRelationships.ts","../src/openApi/shared/utils/transforms.ts","../src/openApi/shared/transforms/utils.ts","../src/openApi/shared/transforms/enums.ts","../src/openApi/shared/transforms/propertiesRequiredByDefault.ts","../src/openApi/shared/utils/deepEqual.ts","../src/openApi/shared/utils/graph.ts","../src/openApi/shared/transforms/readWrite.ts","../src/openApi/shared/transforms/index.ts","../src/openApi/shared/utils/parameter.ts","../src/openApi/shared/utils/validator.ts","../src/openApi/2.0.x/parser/filter.ts","../src/ir/mediaType.ts","../src/openApi/2.0.x/parser/mediaType.ts","../src/ir/pagination.ts","../src/openApi/shared/utils/discriminator.ts","../src/openApi/2.0.x/parser/schema.ts","../src/openApi/2.0.x/parser/pagination.ts","../src/openApi/2.0.x/parser/operation.ts","../src/openApi/2.0.x/parser/parameter.ts","../src/openApi/2.0.x/parser/server.ts","../src/openApi/2.0.x/parser/validate.ts","../src/openApi/2.0.x/parser/index.ts","../src/openApi/3.0.x/parser/filter.ts","../src/openApi/3.0.x/parser/mediaType.ts","../src/openApi/3.0.x/parser/schema.ts","../src/openApi/3.0.x/parser/pagination.ts","../src/openApi/3.0.x/parser/operation.ts","../src/openApi/3.0.x/parser/parameter.ts","../src/openApi/3.0.x/parser/requestBody.ts","../src/openApi/3.0.x/parser/server.ts","../src/openApi/3.0.x/parser/validate.ts","../src/openApi/3.0.x/parser/index.ts","../src/openApi/3.1.x/parser/filter.ts","../src/openApi/3.1.x/parser/mediaType.ts","../src/openApi/3.1.x/parser/schema.ts","../src/openApi/3.1.x/parser/pagination.ts","../src/openApi/3.1.x/parser/operation.ts","../src/openApi/3.1.x/parser/parameter.ts","../src/openApi/3.1.x/parser/requestBody.ts","../src/openApi/3.1.x/parser/server.ts","../src/openApi/3.1.x/parser/validate.ts","../src/openApi/3.1.x/parser/webhook.ts","../src/openApi/3.1.x/parser/index.ts","../src/openApi/index.ts"],"sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport ts from 'typescript';\n\nimport type { UserOutput } from '~/types/output';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport const findPackageJson = (): unknown | undefined => {\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files.filter((file) => file === 'package.json');\n\n    if (candidates[0]) {\n      const packageJsonPath = path.join(dir, candidates[0]);\n      return JSON.parse(\n        fs.readFileSync(packageJsonPath, {\n          encoding: 'utf8',\n        }),\n      );\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return;\n};\n\nexport const loadPackageJson = () => {\n  const packageJson = findPackageJson();\n\n  const safePackage = {\n    bugs: {\n      url: '',\n    },\n    name: '',\n    version: '',\n  };\n\n  if (packageJson && typeof packageJson === 'object') {\n    if ('name' in packageJson && typeof packageJson.name === 'string') {\n      safePackage.name = packageJson.name;\n    }\n\n    if ('version' in packageJson && typeof packageJson.version === 'string') {\n      safePackage.version = packageJson.version;\n    }\n\n    if (\n      'bugs' in packageJson &&\n      packageJson.bugs &&\n      typeof packageJson.bugs === 'object'\n    ) {\n      if (\n        'url' in packageJson.bugs &&\n        typeof packageJson.bugs.url === 'string'\n      ) {\n        safePackage.bugs.url = packageJson.bugs.url;\n        if (safePackage.bugs.url && !safePackage.bugs.url.endsWith('/')) {\n          safePackage.bugs.url += '/';\n        }\n      }\n    }\n  }\n\n  return safePackage;\n};\n\nexport const findTsConfigPath = (\n  tsConfigPath?: UserOutput['tsConfigPath'],\n): string | null => {\n  if (tsConfigPath === null) {\n    return null;\n  }\n\n  if (tsConfigPath) {\n    const resolved = path.isAbsolute(tsConfigPath)\n      ? tsConfigPath\n      : path.resolve(__dirname, tsConfigPath);\n    return fs.existsSync(resolved) ? resolved : null;\n  }\n\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files\n      .filter((file) => file.startsWith('tsconfig') && file.endsWith('.json'))\n      .sort((file) => (file === 'tsconfig.json' ? -1 : 1));\n\n    if (candidates[0]) {\n      return path.join(dir, candidates[0]);\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return null;\n};\n\nexport const loadTsConfig = (\n  configPath: string | null,\n): ts.ParsedCommandLine | null => {\n  if (!configPath) {\n    return null;\n  }\n\n  const raw = ts.readConfigFile(configPath, ts.sys.readFile);\n\n  if (raw.error) {\n    throw new Error(`Couldn't read tsconfig from path: ${configPath}`);\n  }\n\n  return ts.parseJsonConfigFileContent(\n    raw.config,\n    ts.sys,\n    path.dirname(configPath),\n  );\n};\n","import type { PathLike } from 'node:fs';\nimport fs from 'node:fs';\n\nexport const ensureDirSync = (path: PathLike) => {\n  if (!fs.existsSync(path)) {\n    fs.mkdirSync(path, { recursive: true });\n  }\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { loadPackageJson } from '~/generate/tsConfig';\nimport { ensureDirSync } from '~/generate/utils';\n\ntype IJobError = {\n  error: Error;\n  jobIndex: number;\n};\n\n/**\n * Represents a single configuration error.\n *\n * Used for reporting issues with a specific config instance.\n */\nexport class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Aggregates multiple config errors with their job indices for reporting.\n */\nexport class ConfigValidationError extends Error {\n  readonly errors: ReadonlyArray<IJobError>;\n\n  constructor(errors: Array<IJobError>) {\n    super(\n      `Found ${errors.length} configuration ${errors.length === 1 ? 'error' : 'errors'}.`,\n    );\n    this.name = 'ConfigValidationError';\n    this.errors = errors;\n  }\n}\n\n/**\n * Represents a runtime error originating from a specific job.\n *\n * Used for reporting job-level failures that are not config validation errors.\n */\nexport class JobError extends Error {\n  readonly originalError: IJobError;\n\n  constructor(message: string, error: IJobError) {\n    super(message);\n    this.name = 'JobError';\n    this.originalError = error;\n  }\n}\n\nexport class HeyApiError extends Error {\n  args: ReadonlyArray<unknown>;\n  event: string;\n  pluginName: string;\n\n  constructor({\n    args,\n    error,\n    event,\n    name,\n    pluginName,\n  }: {\n    args: unknown[];\n    error: Error;\n    event: string;\n    name: string;\n    pluginName: string;\n  }) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    super(message);\n\n    this.args = args;\n    this.cause = error.cause;\n    this.event = event;\n    this.name = name || error.name;\n    this.pluginName = pluginName;\n    this.stack = error.stack;\n  }\n}\n\nexport const logCrashReport = (\n  error: unknown,\n  logsDir: string,\n): string | undefined => {\n  if (error instanceof ConfigError || error instanceof ConfigValidationError) {\n    return;\n  }\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  const logName = `openapi-ts-error-${Date.now()}.log`;\n  const fullDir = path.resolve(process.cwd(), logsDir);\n  ensureDirSync(fullDir);\n  const logPath = path.resolve(fullDir, logName);\n\n  let logContent = `[${new Date().toISOString()}] `;\n\n  if (error instanceof HeyApiError) {\n    logContent += `${error.name} during event \"${error.event}\"\\n`;\n    if (error.pluginName) {\n      logContent += `Plugin: ${error.pluginName}\\n`;\n    }\n    logContent += `Arguments: ${JSON.stringify(error.args, null, 2)}\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  logContent += `Error: ${message}\\n`;\n  if (stack) {\n    logContent += `Stack:\\n${stack}\\n`;\n  }\n\n  fs.writeFileSync(logPath, logContent);\n\n  return logPath;\n};\n\nexport const openGitHubIssueWithCrashReport = async (error: unknown) => {\n  const packageJson = loadPackageJson();\n  if (!packageJson.bugs.url) return;\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  let body = '';\n\n  if (error instanceof HeyApiError) {\n    if (error.pluginName) {\n      body += `**Plugin**: \\`${error.pluginName}\\`\\n`;\n    }\n    body += `**Event**: \\`${error.event}\\`\\n`;\n    body += `**Arguments**:\\n\\`\\`\\`ts\\n${JSON.stringify(error.args, null, 2)}\\n\\`\\`\\`\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  body += `**Error**: \\`${message}\\`\\n`;\n  if (stack) {\n    body += `\\n**Stack Trace**:\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\``;\n  }\n\n  const search = new URLSearchParams({\n    body,\n    labels: 'bug üî•',\n    title: 'Crash Report',\n  });\n  const url = `${packageJson.bugs.url}new?${search.toString()}`;\n  const open = (await import('open')).default;\n  await open(url);\n};\n\nexport const printCrashReport = ({\n  error,\n  logPath,\n}: {\n  error: unknown;\n  logPath: string | undefined;\n}) => {\n  if (error instanceof ConfigValidationError && error.errors.length) {\n    const groupByJob = new Map<number, Array<Error>>();\n    for (const { error: err, jobIndex } of error.errors) {\n      if (!groupByJob.has(jobIndex)) {\n        groupByJob.set(jobIndex, []);\n      }\n      groupByJob.get(jobIndex)!.push(err);\n    }\n\n    for (const [jobIndex, errors] of groupByJob.entries()) {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      const count = errors.length;\n      const baseString = colors.red(\n        `Found ${count} configuration ${count === 1 ? 'error' : 'errors'}:`,\n      );\n      console.error(`${jobPrefix}‚ùóÔ∏è ${baseString}`);\n      errors.forEach((err, index) => {\n        const itemPrefixStr = `  [${index + 1}] `;\n        const itemPrefix = colors.red(itemPrefixStr);\n        console.error(`${jobPrefix}${itemPrefix}${colors.white(err.message)}`);\n      });\n    }\n  } else {\n    let jobPrefix = colors.gray('[root] ');\n    if (error instanceof JobError) {\n      jobPrefix = colors.gray(`[Job ${error.originalError.jobIndex + 1}] `);\n      error = error.originalError.error;\n    }\n\n    const baseString = colors.red('Failed with the message:');\n    console.error(`${jobPrefix}‚ùå ${baseString}`);\n    const itemPrefixStr = `  `;\n    const itemPrefix = colors.red(itemPrefixStr);\n    console.error(\n      `${jobPrefix}${itemPrefix}${typeof error === 'string' ? error : error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  if (logPath) {\n    const jobPrefix = colors.gray('[root] ');\n    console.error(\n      `${jobPrefix}${colors.cyan('üìÑ Crash log saved to:')} ${colors.gray(logPath)}`,\n    );\n  }\n};\n\nexport const shouldReportCrash = async ({\n  error,\n  isInteractive,\n}: {\n  error: unknown;\n  isInteractive: boolean | undefined;\n}): Promise<boolean> => {\n  if (\n    !isInteractive ||\n    error instanceof ConfigError ||\n    error instanceof ConfigValidationError\n  ) {\n    return false;\n  }\n\n  return new Promise((resolve) => {\n    const jobPrefix = colors.gray('[root] ');\n    console.log(\n      `${jobPrefix}${colors.yellow('üì¢ Open a GitHub issue with crash details? (y/N):')}`,\n    );\n    process.stdin.setEncoding('utf8');\n    process.stdin.once('data', (data: string) => {\n      resolve(data.trim().toLowerCase() === 'y');\n    });\n  });\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Hey API Registry input formats:\n//   - {organization}/{project}?{queryParams}\nconst registryRegExp = /^([\\w-]+)\\/([\\w-]+)(?:\\?([\\w=&.-]*))?$/;\n\nexport const heyApiRegistryBaseUrl = 'https://get.heyapi.dev';\n\n/**\n * Creates a full Hey API Registry URL.\n *\n * @param organization - Hey API organization slug\n * @param project - Hey API project slug\n * @param queryParams - Optional query parameters\n * @returns The full Hey API registry URL.\n */\nexport const getRegistryUrl = (\n  organization: string,\n  project: string,\n  queryParams?: string,\n): string =>\n  `${heyApiRegistryBaseUrl}/${organization}/${project}${queryParams ? `?${queryParams}` : ''}`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n  queryParams?: string;\n}\n\n/**\n * Parses a Hey API input string and extracts components.\n *\n * @param input - Hey API configuration input\n * @returns Parsed Hey API input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (\n  input: Input & {\n    path: string;\n  },\n): Parsed => {\n  let organization = input.organization;\n  let project = input.project;\n  let queryParams: string | undefined;\n\n  if (input.path) {\n    const match = input.path.match(registryRegExp);\n\n    if (!match) {\n      throw new Error(\n        `Invalid Hey API shorthand format. Expected \"organization/project?queryParams\" or \"organization/project\", received: ${input.path}`,\n      );\n    }\n\n    organization = match[1];\n    project = match[2];\n    queryParams = match[3];\n  }\n\n  if (!organization) {\n    throw new Error('The Hey API organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Hey API project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    queryParams,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Hey API shorthand string to the corresponding API URL.\n *\n * @param input - Hey API configuration input\n * @returns The Hey API Registry URL\n */\nexport const inputToHeyApiPath = (\n  input: Input & {\n    path: string;\n  },\n): Partial<Input> => {\n  const parsed = parseShorthand(input);\n  return {\n    path: getRegistryUrl(\n      parsed.organization,\n      parsed.project,\n      parsed.queryParams,\n    ),\n    registry: 'hey-api',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match ReadMe API Registry input formats:\n//   - @{organization}/{project}#{uuid}\n//   - {uuid}\nconst registryRegExp = /^(@([\\w-]+)\\/([\\w\\-.]+)#)?([\\w-]+)$/;\n\n/**\n * Creates a full ReadMe API Registry URL.\n *\n * @param uuid - ReadMe UUID\n * @returns The full ReadMe API registry URL.\n */\nexport const getRegistryUrl = (uuid: string): string =>\n  `https://dash.readme.com/api/v1/api-registry/${uuid}`;\n\nexport interface Parsed {\n  organization?: string;\n  project?: string;\n  uuid: string;\n}\n\nconst namespace = 'readme';\n\n/**\n * Parses a ReadMe input string and extracts components.\n *\n * @param shorthand - ReadMe format string (@org/project#uuid or uuid)\n * @returns Parsed ReadMe input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid ReadMe shorthand format. Expected \"${namespace}:@organization/project#uuid\" or \"${namespace}:uuid\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, , organization, project, uuid] = match;\n\n  if (!uuid) {\n    throw new Error('The ReadMe UUID cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    uuid,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a ReadMe shorthand string to the corresponding API URL.\n *\n * @param input - ReadMe format string\n * @returns The ReadMe API Registry URL\n */\nexport const inputToReadmePath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.uuid),\n    registry: 'readme',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Scalar API Registry input formats:\n//   - @{organization}/{project}\nconst registryRegExp = /^(@[\\w-]+)\\/([\\w.-]+)$/;\n\n/**\n * Creates a full Scalar API Registry URL.\n *\n * @param organization - Scalar organization slug\n * @param project - Scalar project slug\n * @returns The full Scalar API registry URL.\n */\nexport const getRegistryUrl = (organization: string, project: string): string =>\n  `https://registry.scalar.com/${organization}/apis/${project}/latest?format=json`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n}\n\nconst namespace = 'scalar';\n\n/**\n * Parses a Scalar input string and extracts components.\n *\n * @param shorthand - Scalar format string (@org/project)\n * @returns Parsed Scalar input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid Scalar shorthand format. Expected \"${namespace}:@organization/project\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, organization, project] = match;\n\n  if (!organization) {\n    throw new Error('The Scalar organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Scalar project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Scalar shorthand string to the corresponding API URL.\n *\n * @param input - Scalar format string\n * @returns The Scalar API Registry URL\n */\nexport const inputToScalarPath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.organization, parsed.project),\n    registry: 'scalar',\n  };\n};\n","import type { Input } from '~/types/input';\n\nimport { heyApiRegistryBaseUrl, inputToHeyApiPath } from './heyApi';\nimport { inputToReadmePath } from './readme';\nimport { inputToScalarPath } from './scalar';\n\nexport const inputToApiRegistry = (\n  input: Input & {\n    path: string;\n  },\n) => {\n  if (input.path.startsWith('readme:')) {\n    Object.assign(input, inputToReadmePath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('scalar:')) {\n    Object.assign(input, inputToScalarPath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('.')) {\n    return;\n  }\n\n  if (input.path.startsWith(heyApiRegistryBaseUrl)) {\n    input.path = input.path.slice(heyApiRegistryBaseUrl.length + 1);\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n\n  const parts = input.path.split('/');\n  if (parts.length === 2 && parts.filter(Boolean).length === 2) {\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n};\n","import type { Config, UserConfig } from '~/types/config';\nimport type { Input, Watch } from '~/types/input';\nimport { inputToApiRegistry } from '~/utils/input';\nimport { heyApiRegistryBaseUrl } from '~/utils/input/heyApi';\n\nconst defaultWatch: Watch = {\n  enabled: false,\n  interval: 1_000,\n  timeout: 60_000,\n};\n\n// watch only remote files\nconst getWatch = (input: Pick<Input, 'path' | 'watch'>): Watch => {\n  let watch = { ...defaultWatch };\n\n  // we cannot watch spec passed as an object\n  if (typeof input.path !== 'string') {\n    return watch;\n  }\n\n  if (typeof input.watch === 'boolean') {\n    watch.enabled = input.watch;\n  } else if (typeof input.watch === 'number') {\n    watch.enabled = true;\n    watch.interval = input.watch;\n  } else if (input.watch) {\n    watch = {\n      ...watch,\n      ...input.watch,\n    };\n  }\n\n  return watch;\n};\n\nexport const getInput = (userConfig: UserConfig): Config['input'] => {\n  const userInputs =\n    userConfig.input instanceof Array ? userConfig.input : [userConfig.input];\n\n  const inputs: Array<Input> = [];\n\n  for (const userInput of userInputs) {\n    let input: Input = {\n      path: '',\n      watch: defaultWatch,\n    };\n\n    if (typeof userInput === 'string') {\n      input.path = userInput;\n    } else if (\n      userInput &&\n      (userInput.path !== undefined || userInput.organization !== undefined)\n    ) {\n      // @ts-expect-error\n      input = {\n        ...input,\n        path: heyApiRegistryBaseUrl,\n        ...userInput,\n      };\n\n      if (input.watch !== undefined) {\n        input.watch = getWatch(input);\n      }\n    } else {\n      input = {\n        ...input,\n        path: userInput,\n      };\n    }\n\n    if (typeof input.path === 'string') {\n      inputToApiRegistry(input as Input & { path: string });\n    }\n\n    if (\n      userConfig.watch !== undefined &&\n      input.watch.enabled === defaultWatch.enabled &&\n      input.watch.interval === defaultWatch.interval &&\n      input.watch.timeout === defaultWatch.timeout\n    ) {\n      input.watch = getWatch({\n        path: input.path,\n        // @ts-expect-error\n        watch: userConfig.watch,\n      });\n    }\n\n    if (input.path) {\n      inputs.push(input);\n    }\n  }\n\n  return inputs;\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nexport const getLogs = (\n  userConfig: Pick<UserConfig, 'logs'> | undefined,\n): Config['logs'] => {\n  let logs: Config['logs'] = {\n    file: true,\n    level: 'info',\n    path: process.cwd(),\n  };\n\n  if (typeof userConfig?.logs === 'string') {\n    logs.path = userConfig.logs;\n  } else {\n    logs = {\n      ...logs,\n      ...userConfig?.logs,\n    };\n  }\n\n  return logs;\n};\n","import type { UserConfig } from '~/types/config';\n\nconst mergeObjects = (\n  objA: Record<string, unknown> | undefined,\n  objB: Record<string, unknown> | undefined,\n): Record<string, unknown> => {\n  const a = objA || {};\n  const b = objB || {};\n  return {\n    ...a,\n    ...b,\n  };\n};\n\nexport const mergeConfigs = (\n  configA: UserConfig | undefined,\n  configB: UserConfig | undefined,\n): UserConfig => {\n  const a: Partial<UserConfig> = configA || {};\n  const b: Partial<UserConfig> = configB || {};\n  const merged: UserConfig = {\n    ...(a as UserConfig),\n    ...(b as UserConfig),\n  };\n  if (typeof merged.logs === 'object') {\n    merged.logs = mergeObjects(\n      a.logs as Record<string, unknown>,\n      b.logs as Record<string, unknown>,\n    );\n  }\n  return merged;\n};\n","type ObjectType<T> =\n  Extract<T, Record<string, any>> extends never\n    ? Record<string, any>\n    : Extract<T, Record<string, any>>;\n\ntype NotArray<T> = T extends any[] ? never : T;\ntype NotFunction<T> = T extends (...args: any[]) => any ? never : T;\ntype PlainObject<T> = T extends object\n  ? NotFunction<T> extends never\n    ? never\n    : NotArray<T> extends never\n      ? never\n      : T\n  : never;\n\ntype MappersType<T> = {\n  boolean: T extends boolean\n    ? (value: boolean) => Partial<ObjectType<T>>\n    : never;\n  function: T extends (...args: any[]) => any\n    ? (value: (...args: any[]) => any) => Partial<ObjectType<T>>\n    : never;\n  number: T extends number ? (value: number) => Partial<ObjectType<T>> : never;\n  object?: PlainObject<T> extends never\n    ? never\n    : (\n        value: Partial<PlainObject<T>>,\n        defaultValue: PlainObject<T>,\n      ) => Partial<ObjectType<T>>;\n  string: T extends string ? (value: string) => Partial<ObjectType<T>> : never;\n} extends infer U\n  ? { [K in keyof U as U[K] extends never ? never : K]: U[K] }\n  : never;\n\ntype IsObjectOnly<T> = T extends Record<string, any> | undefined\n  ? Extract<\n      T,\n      string | boolean | number | ((...args: any[]) => any)\n    > extends never\n    ? true\n    : false\n  : false;\n\nexport type ValueToObject = <\n  T extends\n    | undefined\n    | string\n    | boolean\n    | number\n    | ((...args: any[]) => any)\n    | Record<string, any>,\n>(\n  args: {\n    defaultValue: ObjectType<T>;\n    value: T;\n  } & (IsObjectOnly<T> extends true\n    ? {\n        mappers?: MappersType<T>;\n      }\n    : {\n        mappers: MappersType<T>;\n      }),\n) => PlainObject<T>;\n\nconst isPlainObject = (value: unknown): value is Record<string, any> =>\n  typeof value === 'object' &&\n  value !== null &&\n  !Array.isArray(value) &&\n  typeof value !== 'function';\n\nconst mergeResult = <T>(\n  result: ObjectType<T>,\n  mapped: Record<string, any>,\n): ObjectType<T> => {\n  for (const [key, value] of Object.entries(mapped)) {\n    if (value !== undefined && value !== '') {\n      (result as Record<string, any>)[key] = value;\n    }\n  }\n  return result;\n};\n\nexport const valueToObject: ValueToObject = ({\n  defaultValue,\n  mappers,\n  value,\n}) => {\n  let result = { ...defaultValue };\n\n  switch (typeof value) {\n    case 'boolean':\n      if (mappers && 'boolean' in mappers) {\n        const mapper = mappers.boolean as (\n          value: boolean,\n        ) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'function':\n      if (mappers && 'function' in mappers) {\n        const mapper = mappers.function as (\n          value: (...args: any[]) => any,\n        ) => Record<string, any>;\n        result = mergeResult(result, mapper(value as (...args: any[]) => any));\n      }\n      break;\n    case 'number':\n      if (mappers && 'number' in mappers) {\n        const mapper = mappers.number as (value: number) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'string':\n      if (mappers && 'string' in mappers) {\n        const mapper = mappers.string as (value: string) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'object':\n      if (isPlainObject(value)) {\n        if (\n          mappers &&\n          'object' in mappers &&\n          typeof mappers.object === 'function'\n        ) {\n          const mapper = mappers.object as (\n            value: Record<string, any>,\n            defaultValue: ObjectType<any>,\n          ) => Partial<ObjectType<any>>;\n          result = mergeResult(result, mapper(value, defaultValue));\n        } else {\n          result = mergeResult(result, value);\n        }\n      }\n      break;\n  }\n\n  return result as any;\n};\n","import ts from 'typescript';\n\nimport { findTsConfigPath, loadTsConfig } from '~/generate/tsConfig';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const getOutput = (userConfig: UserConfig): Config['output'] => {\n  if (userConfig.output instanceof Array) {\n    throw new Error(\n      'Unexpected array of outputs in user configuration. This should have been expanded already.',\n    );\n  }\n\n  const output = valueToObject({\n    defaultValue: {\n      clean: true,\n      fileName: {\n        case: 'preserve',\n        name: '{{name}}',\n        suffix: '.gen',\n      },\n      format: null,\n      indexFile: true,\n      lint: null,\n      path: '',\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        fileName: valueToObject({\n          defaultValue: {\n            ...(defaultValue.fileName as Extract<\n              typeof defaultValue.fileName,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: fields.fileName,\n        }),\n      }),\n      string: (path) => ({ path }),\n    },\n    value: userConfig.output,\n  }) as Config['output'];\n  output.tsConfig = loadTsConfig(findTsConfigPath(output.tsConfigPath));\n  if (\n    output.importFileExtension === undefined &&\n    output.tsConfig?.options.moduleResolution ===\n      ts.ModuleResolutionKind.NodeNext\n  ) {\n    output.importFileExtension = '.js';\n  }\n  if (\n    output.importFileExtension &&\n    !output.importFileExtension.startsWith('.')\n  ) {\n    output.importFileExtension = `.${output.importFileExtension}`;\n  }\n  return output;\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Finds and reads the project's package.json file by searching upwards from the config file location,\n * or from process.cwd() if no config file is provided.\n * This ensures we get the correct dependencies even in monorepo setups.\n *\n * @param configFilePath - The path to the configuration file (e.g., openapi-ts.config.ts)\n * @returns An object containing all project dependencies (dependencies, devDependencies, peerDependencies, optionalDependencies)\n */\nexport const getProjectDependencies = (\n  configFilePath?: string,\n): Record<string, string> => {\n  let currentDir = configFilePath\n    ? path.dirname(configFilePath)\n    : process.cwd();\n\n  while (currentDir !== path.dirname(currentDir)) {\n    const packageJsonPath = path.join(currentDir, 'package.json');\n\n    if (fs.existsSync(packageJsonPath)) {\n      try {\n        const packageJson = JSON.parse(\n          fs.readFileSync(packageJsonPath, 'utf8'),\n        );\n        return {\n          ...packageJson.dependencies,\n          ...packageJson.devDependencies,\n          ...packageJson.peerDependencies,\n          ...packageJson.optionalDependencies,\n        };\n      } catch {\n        // Silently ignore JSON parsing errors and continue searching\n      }\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  return {};\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const defaultPaginationKeywords = [\n  'after',\n  'before',\n  'cursor',\n  'offset',\n  'page',\n  'start',\n] as const;\n\nexport const getParser = (userConfig: UserConfig): Config['parser'] => {\n  const parser = valueToObject({\n    defaultValue: {\n      hooks: {},\n      pagination: {\n        keywords: defaultPaginationKeywords,\n      },\n      transforms: {\n        enums: {\n          case: 'PascalCase',\n          enabled: false,\n          mode: 'root',\n          name: '{{name}}Enum',\n        },\n        propertiesRequiredByDefault: false,\n        readWrite: {\n          enabled: true,\n          requests: {\n            case: 'preserve',\n            name: '{{name}}Writable',\n          },\n          responses: {\n            case: 'preserve',\n            name: '{{name}}',\n          },\n        },\n      },\n      validate_EXPERIMENTAL: false,\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        pagination: valueToObject({\n          defaultValue: {\n            ...(defaultValue.pagination as Extract<\n              typeof defaultValue.pagination,\n              Record<string, unknown>\n            >),\n          },\n          value: fields.pagination,\n        }),\n        transforms: valueToObject({\n          defaultValue: {\n            ...(defaultValue.transforms as Extract<\n              typeof defaultValue.transforms,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            object: (fields, defaultValue) => ({\n              ...fields,\n              enums: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.enums as Extract<\n                    typeof defaultValue.enums,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.enums !== undefined\n                      ? Boolean(fields.enums)\n                      : (\n                          defaultValue.enums as Extract<\n                            typeof defaultValue.enums,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  string: (mode) => ({ mode }),\n                },\n                value: fields.enums,\n              }),\n              propertiesRequiredByDefault:\n                fields.propertiesRequiredByDefault !== undefined\n                  ? fields.propertiesRequiredByDefault\n                  : defaultValue.propertiesRequiredByDefault,\n              readWrite: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.readWrite as Extract<\n                    typeof defaultValue.readWrite,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.readWrite !== undefined\n                      ? Boolean(fields.readWrite)\n                      : (\n                          defaultValue.readWrite as Extract<\n                            typeof defaultValue.readWrite,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  object: (fields, defaultValue) => ({\n                    ...fields,\n                    requests: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.requests as Extract<\n                          typeof defaultValue.requests,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.requests,\n                    }),\n                    responses: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.responses as Extract<\n                          typeof defaultValue.responses,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.responses,\n                    }),\n                  }),\n                },\n                value: fields.readWrite,\n              }),\n            }),\n          },\n          value: fields.transforms,\n        }),\n        validate_EXPERIMENTAL:\n          fields.validate_EXPERIMENTAL === true\n            ? 'warn'\n            : fields.validate_EXPERIMENTAL,\n      }),\n    },\n    value: userConfig.parser,\n  });\n  return parser as Config['parser'];\n};\n","import type { Plugin } from '~/plugins';\n\nexport const definePluginConfig =\n  <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) =>\n  (\n    userConfig?: Omit<T['config'], 'name'>,\n  ): Omit<Plugin.Config<T>, 'name'> & {\n    /**\n     * Cast name to `any` so it doesn't throw type error in `plugins` array.\n     * We could allow any `string` as plugin `name` in the object syntax, but\n     * that TypeScript trick would cause all string methods to appear as\n     * suggested auto completions, which is undesirable.\n     */\n    name: any;\n  } => ({\n    ...defaultConfig,\n    config: {\n      ...defaultConfig.config,\n      ...userConfig,\n    },\n  });\n\n/**\n * Reusable mappers for `enabled` and `name` fields.\n */\nexport const mappers = {\n  boolean: (enabled: boolean) => ({ enabled }),\n  function: (name: (...args: any[]) => any) => ({ name }),\n  string: (name: string) => ({ name }),\n} as const;\n","import type { StringCase } from '~/types/case';\n\nconst uppercaseRegExp = /[\\p{Lu}]/u;\nconst lowercaseRegExp = /[\\p{Ll}]/u;\nconst identifierRegExp = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst separatorsRegExp = /[_.\\- `\\\\[\\]{}\\\\/]+/;\n\nconst leadingSeparatorsRegExp = new RegExp(`^${separatorsRegExp.source}`);\nconst separatorsAndIdentifierRegExp = new RegExp(\n  `${separatorsRegExp.source}${identifierRegExp.source}`,\n  'gu',\n);\nconst numbersAndIdentifierRegExp = new RegExp(\n  `\\\\d+${identifierRegExp.source}`,\n  'gu',\n);\n\nconst preserveCase = ({\n  case: _case,\n  string,\n}: {\n  readonly case: StringCase;\n  string: string;\n}) => {\n  let isLastCharLower = false;\n  let isLastCharUpper = false;\n  let isLastLastCharUpper = false;\n  let isLastLastCharPreserved = false;\n\n  const separator =\n    _case === 'snake_case' || _case === 'SCREAMING_SNAKE_CASE' ? '_' : '-';\n\n  for (let index = 0; index < string.length; index++) {\n    const character = string[index]!;\n    isLastLastCharPreserved =\n      index > 2 ? string[index - 3] === separator : true;\n\n    let nextIndex = index + 1;\n    let nextCharacter = string[nextIndex];\n    separatorsRegExp.lastIndex = 0;\n    while (nextCharacter && separatorsRegExp.test(nextCharacter)) {\n      nextIndex += 1;\n      nextCharacter = string[nextIndex];\n    }\n    const isSeparatorBeforeNextCharacter = nextIndex !== index + 1;\n\n    lowercaseRegExp.lastIndex = 0;\n    uppercaseRegExp.lastIndex = 0;\n    if (\n      uppercaseRegExp.test(character) &&\n      (isLastCharLower ||\n        (nextCharacter &&\n          !isSeparatorBeforeNextCharacter &&\n          nextCharacter !== 's' &&\n          lowercaseRegExp.test(nextCharacter)))\n    ) {\n      // insert separator behind character\n      string = `${string.slice(0, index)}${separator}${string.slice(index)}`;\n      index++;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = false;\n      isLastCharUpper = true;\n    } else if (\n      isLastCharUpper &&\n      isLastLastCharUpper &&\n      lowercaseRegExp.test(character) &&\n      !isLastLastCharPreserved &&\n      // naive detection of plurals\n      !(\n        character === 's' &&\n        (!nextCharacter || nextCharacter.toLocaleLowerCase() !== nextCharacter)\n      )\n    ) {\n      // insert separator 2 characters behind\n      string = `${string.slice(0, index - 1)}${separator}${string.slice(index - 1)}`;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = true;\n      isLastCharUpper = false;\n    } else {\n      const characterLower = character.toLocaleLowerCase();\n      const characterUpper = character.toLocaleUpperCase();\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower =\n        characterLower === character && characterUpper !== character;\n      isLastCharUpper =\n        characterUpper === character && characterLower !== character;\n    }\n  }\n\n  return string;\n};\n\nexport const stringCase = ({\n  case: _case,\n  stripLeadingSeparators = true,\n  value,\n}: {\n  readonly case: StringCase | undefined;\n  /**\n   * If leading separators have a semantic meaning, we might not want to\n   * remove them.\n   */\n  stripLeadingSeparators?: boolean;\n  value: string;\n}): string => {\n  let result = value.trim();\n\n  if (!result.length) {\n    return '';\n  }\n\n  if (!_case || _case === 'preserve') {\n    return result;\n  }\n\n  if (result.length === 1) {\n    separatorsRegExp.lastIndex = 0;\n    if (separatorsRegExp.test(result)) {\n      return '';\n    }\n\n    return _case === 'PascalCase' || _case === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n  }\n\n  const hasUpperCase = result !== result.toLocaleLowerCase();\n\n  if (hasUpperCase) {\n    result = preserveCase({ case: _case, string: result });\n  }\n\n  if (stripLeadingSeparators || result[0] !== value[0]) {\n    result = result.replace(leadingSeparatorsRegExp, '');\n  }\n\n  result =\n    _case === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n\n  if (_case === 'PascalCase') {\n    result = `${result.charAt(0).toLocaleUpperCase()}${result.slice(1)}`;\n  }\n\n  if (_case === 'snake_case' || _case === 'SCREAMING_SNAKE_CASE') {\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (offset === 0 && !stripLeadingSeparators) {\n          return match;\n        }\n        return `_${identifier}`;\n      },\n    );\n\n    if (result[result.length - 1] === '_') {\n      // strip trailing underscore\n      result = result.slice(0, result.length - 1);\n    }\n  } else {\n    separatorsAndIdentifierRegExp.lastIndex = 0;\n    numbersAndIdentifierRegExp.lastIndex = 0;\n\n    result = result.replaceAll(\n      numbersAndIdentifierRegExp,\n      (match, _, offset) => {\n        if (['_', '-', '.'].includes(result.charAt(offset + match.length))) {\n          return match;\n        }\n\n        return match.toLocaleUpperCase();\n      },\n    );\n\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (\n          offset === 0 &&\n          !stripLeadingSeparators &&\n          match[0] &&\n          value.startsWith(match[0])\n        ) {\n          return match;\n        }\n        return identifier.toLocaleUpperCase();\n      },\n    );\n  }\n\n  return result;\n};\n","import { stringCase } from '~/utils/stringCase';\n\nimport type { StringCase, StringName } from '../../../types/case';\n\nexport const buildName = ({\n  config,\n  name,\n}: {\n  config: {\n    case: StringCase;\n    name?: StringName;\n  };\n  name: string;\n}): string => {\n  if (typeof config.name === 'function') {\n    name = config.name(name);\n  } else if (config.name) {\n    const separator = config.case === 'preserve' ? '' : '-';\n    name = config.name.replace('{{name}}', `${separator}${name}${separator}`);\n  }\n\n  return stringCase({ case: config.case, value: name });\n};\n","import type { Context } from './context';\nimport type { Pagination } from './pagination';\nimport type { IR } from './types';\n\nconst getPaginationSchema = ({\n  context,\n  parameter,\n}: {\n  context: Context;\n  parameter: IR.ParameterObject;\n}): IR.SchemaObject | undefined => {\n  if (!parameter.pagination) {\n    return;\n  }\n\n  if (parameter.pagination === true) {\n    return parameter.schema;\n  }\n\n  let schema = parameter.schema;\n  if (schema.$ref) {\n    schema = context.resolveIrRef<IR.SchemaObject>(schema.$ref);\n  }\n\n  return schema.properties![parameter.pagination]!;\n};\n\nexport const hasParameterGroupObjectRequired = (\n  parameterGroup?: Record<string, IR.ParameterObject>,\n): boolean => {\n  for (const name in parameterGroup) {\n    if (parameterGroup[name]!.required) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const hasParametersObjectRequired = (\n  parameters: IR.ParametersObject | undefined,\n): boolean => {\n  if (!parameters) {\n    return false;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.cookie)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.header)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.path)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.query)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const parameterWithPagination = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters: IR.ParametersObject | undefined;\n}): Pagination | undefined => {\n  if (!parameters) {\n    return;\n  }\n\n  for (const name in parameters.cookie) {\n    const parameter = parameters.cookie[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.header) {\n    const parameter = parameters.header[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.path) {\n    const parameter = parameters.path[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.query) {\n    const parameter = parameters.query[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  return;\n};\n","import type { IR } from './types';\n\n/**\n * Ensure we don't produce redundant types, e.g. string | string.\n */\nexport const deduplicateSchema = <T extends IR.SchemaObject>({\n  detectFormat = true,\n  schema,\n}: {\n  detectFormat?: boolean;\n  schema: T;\n}): T => {\n  if (!schema.items) {\n    return schema;\n  }\n\n  const uniqueItems: Array<IR.SchemaObject> = [];\n  const typeIds: Array<string> = [];\n\n  for (const item of schema.items) {\n    // skip nested schemas for now, handle if necessary\n    if ((!item.type && item.items) || schema.type === 'tuple') {\n      uniqueItems.push(item);\n      continue;\n    }\n\n    if (\n      // no `type` might still include `$ref` or `const`\n      !item.type ||\n      item.type === 'boolean' ||\n      item.type === 'integer' ||\n      item.type === 'null' ||\n      item.type === 'number' ||\n      item.type === 'string' ||\n      item.type === 'unknown' ||\n      item.type === 'void'\n    ) {\n      // const needs namespace to handle empty string values, otherwise\n      // fallback would equal an actual value and we would skip an item\n      const constant = item.const !== undefined ? `const-${item.const}` : '';\n      const format =\n        item.format !== undefined && detectFormat\n          ? `format-${item.format}`\n          : '';\n\n      // Include validation constraints in the type ID to avoid incorrect deduplication\n      const constraints = [\n        item.minLength !== undefined ? `minLength-${item.minLength}` : '',\n        item.maxLength !== undefined ? `maxLength-${item.maxLength}` : '',\n        item.minimum !== undefined ? `minimum-${item.minimum}` : '',\n        item.maximum !== undefined ? `maximum-${item.maximum}` : '',\n        item.exclusiveMinimum !== undefined\n          ? `exclusiveMinimum-${item.exclusiveMinimum}`\n          : '',\n        item.exclusiveMaximum !== undefined\n          ? `exclusiveMaximum-${item.exclusiveMaximum}`\n          : '',\n        item.minItems !== undefined ? `minItems-${item.minItems}` : '',\n        item.maxItems !== undefined ? `maxItems-${item.maxItems}` : '',\n        item.pattern !== undefined ? `pattern-${item.pattern}` : '',\n      ].join('');\n\n      const typeId = `${item.$ref ?? ''}${item.type ?? ''}${constant}${format}${constraints}`;\n      if (!typeIds.includes(typeId)) {\n        typeIds.push(typeId);\n        uniqueItems.push(item);\n      }\n      continue;\n    }\n\n    uniqueItems.push(item);\n  }\n\n  let result = { ...schema };\n  result.items = uniqueItems;\n\n  if (\n    result.items.length <= 1 &&\n    result.type !== 'array' &&\n    result.type !== 'enum' &&\n    result.type !== 'tuple'\n  ) {\n    // bring the only item up to clean up the schema\n    const liftedSchema = result.items[0];\n    delete result.logicalOperator;\n    delete result.items;\n    result = {\n      ...result,\n      ...liftedSchema,\n    };\n  }\n\n  // exclude unknown if it's the only type left\n  if (result.type === 'unknown') {\n    return {} as T;\n  }\n\n  return result;\n};\n","import type { IR } from './types';\n\n/**\n * Simply adds `items` to the schema. Also handles setting the logical operator\n * and avoids setting it for a single item or tuples.\n */\nexport const addItemsToSchema = ({\n  items,\n  logicalOperator = 'or',\n  mutateSchemaOneItem = false,\n  schema,\n}: {\n  items: Array<IR.SchemaObject>;\n  logicalOperator?: IR.SchemaObject['logicalOperator'];\n  mutateSchemaOneItem?: boolean;\n  schema: IR.SchemaObject;\n}) => {\n  if (!items.length) {\n    return schema;\n  }\n\n  if (schema.type === 'tuple') {\n    schema.items = items;\n    return schema;\n  }\n\n  if (items.length !== 1) {\n    schema.items = items;\n    schema.logicalOperator = logicalOperator;\n    return schema;\n  }\n\n  if (mutateSchemaOneItem) {\n    // bring composition up to avoid extraneous brackets\n    schema = {\n      ...schema,\n      ...items[0],\n    };\n    return schema;\n  }\n\n  schema.items = items;\n  return schema;\n};\n","import type { Context } from './context';\nimport type { Pagination } from './pagination';\nimport {\n  hasParametersObjectRequired,\n  parameterWithPagination,\n} from './parameter';\nimport { deduplicateSchema } from './schema';\nimport type { IR } from './types';\nimport { addItemsToSchema } from './utils';\n\nexport const hasOperationDataRequired = (\n  operation: IR.OperationObject,\n): boolean => {\n  if (hasParametersObjectRequired(operation.parameters)) {\n    return true;\n  }\n\n  if (operation.body?.required) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const createOperationKey = ({\n  method,\n  path,\n}: {\n  method: string;\n  path: string;\n}) => `${method.toUpperCase()} ${path}`;\n\nexport const operationPagination = ({\n  context,\n  operation,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n}): Pagination | undefined => {\n  const body = operation.body;\n\n  if (!body || !body.pagination) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  if (body.pagination === true) {\n    return {\n      in: 'body',\n      name: 'body',\n      schema: body.schema,\n    };\n  }\n\n  const schema = body.schema;\n  const resolvedSchema = schema.$ref\n    ? context.resolveIrRef<IR.RequestBodyObject | IR.SchemaObject>(schema.$ref)\n    : schema;\n\n  const finalSchema =\n    'schema' in resolvedSchema ? resolvedSchema.schema : resolvedSchema;\n  const paginationProp = finalSchema?.properties?.[body.pagination];\n\n  if (!paginationProp) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  return {\n    in: 'body',\n    name: body.pagination,\n    schema: paginationProp,\n  };\n};\n\ntype StatusGroup = '1XX' | '2XX' | '3XX' | '4XX' | '5XX' | 'default';\n\nexport const statusCodeToGroup = ({\n  statusCode,\n}: {\n  statusCode: string;\n}): StatusGroup => {\n  switch (statusCode) {\n    case '1XX':\n      return '1XX';\n    case '2XX':\n      return '2XX';\n    case '3XX':\n      return '3XX';\n    case '4XX':\n      return '4XX';\n    case '5XX':\n      return '5XX';\n    case 'default':\n      return 'default';\n    default:\n      return `${statusCode[0]}XX` as StatusGroup;\n  }\n};\n\ninterface OperationResponsesMap {\n  /**\n   * A deduplicated union of all error types. Unknown types are omitted.\n   */\n  error?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each error type.\n   */\n  errors?: IR.SchemaObject;\n  /**\n   * A deduplicated union of all response types. Unknown types are omitted.\n   */\n  response?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each response type.\n   */\n  responses?: IR.SchemaObject;\n}\n\nexport const operationResponsesMap = (\n  operation: IR.OperationObject,\n): OperationResponsesMap => {\n  const result: OperationResponsesMap = {};\n\n  if (!operation.responses) {\n    return result;\n  }\n\n  const errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  const responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  // store default response to be evaluated last\n  let defaultResponse: IR.ResponseObject | undefined;\n\n  for (const name in operation.responses) {\n    const response = operation.responses[name]!;\n\n    switch (statusCodeToGroup({ statusCode: name })) {\n      case '1XX':\n      case '3XX':\n        // TODO: parser - handle informational and redirection status codes\n        break;\n      case '2XX':\n        responses.properties[name] = response.schema;\n        break;\n      case '4XX':\n      case '5XX':\n        errors.properties[name] = response.schema;\n        break;\n      case 'default':\n        defaultResponse = response;\n        break;\n    }\n  }\n\n  // infer default response type\n  if (defaultResponse) {\n    let inferred = false;\n\n    // assume default is intended for success if none exists yet\n    if (!Object.keys(responses.properties).length) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    const description = (\n      defaultResponse.schema.description ?? ''\n    ).toLocaleLowerCase();\n    const $ref = (defaultResponse.schema.$ref ?? '').toLocaleLowerCase();\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const successKeywords = ['success'];\n    if (\n      successKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const errorKeywords = ['error', 'problem'];\n    if (\n      errorKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      errors.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // if no keyword match, assume default schema is intended for error\n    if (!inferred) {\n      errors.properties.default = defaultResponse.schema;\n    }\n  }\n\n  const errorKeys = Object.keys(errors.properties);\n  if (errorKeys.length) {\n    errors.required = errorKeys;\n    result.errors = errors;\n\n    let errorUnion = addItemsToSchema({\n      items: Object.values(errors.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    errorUnion = deduplicateSchema({ schema: errorUnion });\n    if (Object.keys(errorUnion).length && errorUnion.type !== 'unknown') {\n      result.error = errorUnion;\n    }\n  }\n\n  const responseKeys = Object.keys(responses.properties);\n  if (responseKeys.length) {\n    responses.required = responseKeys;\n    result.responses = responses;\n\n    let responseUnion = addItemsToSchema({\n      items: Object.values(responses.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    responseUnion = deduplicateSchema({ schema: responseUnion });\n    if (Object.keys(responseUnion).length && responseUnion.type !== 'unknown') {\n      result.response = responseUnion;\n    }\n  }\n\n  return result;\n};\n","/**\n * Sanitizes namespace identifiers so they are valid TypeScript identifiers of a certain form.\n *\n * 1: Remove any leading characters that are illegal as starting character of a typescript identifier.\n * 2: Replace illegal characters in remaining part of type name with hyphen (-).\n *\n * Step 1 should perhaps instead also replace illegal characters with underscore, or prefix with it, like sanitizeEnumName\n * does. The way this is now one could perhaps end up removing all characters, if all are illegal start characters. It\n * would be sort of a breaking change to do so, though, previously generated code might change then.\n *\n * JavaScript identifier regexp pattern retrieved from https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n *\n * The output of this is expected to be converted to PascalCase\n */\nexport const sanitizeNamespaceIdentifier = (name: string) =>\n  name\n    .replace(/^[^\\p{ID_Start}]+/u, '')\n    .replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '-')\n    .replace(/[$+]/g, '-');\n","import type { PluginClientNames } from '~/plugins/types';\nimport type { Config } from '~/types/config';\n\nexport const getClientBaseUrlKey = (config: Config) => {\n  const client = getClientPlugin(config);\n  if (\n    client.name === '@hey-api/client-axios' ||\n    client.name === '@hey-api/client-nuxt'\n  ) {\n    return 'baseURL';\n  }\n  return 'baseUrl';\n};\n\nexport const getClientPlugin = (\n  config: Config,\n): Config['plugins'][PluginClientNames] & { name: PluginClientNames } => {\n  for (const name of config.pluginOrder) {\n    const plugin = config.plugins[name];\n    if (plugin?.tags?.includes('client')) {\n      return plugin as Config['plugins'][PluginClientNames] & {\n        name: PluginClientNames;\n      };\n    }\n  }\n\n  return {\n    config: {\n      // @ts-expect-error\n      name: '',\n    },\n    // @ts-expect-error\n    name: '',\n  };\n};\n","import type { FromRefs, ToRefs } from '../types/refs';\n\n/**\n * Wraps a single value in a Ref object.\n *\n * @example\n * ```ts\n * const r = toRef(123); // { value: 123 }\n * console.log(r.value); // 123\n * ```\n */\nexport const toRef = <T>(value: T): { value: T } => ({ value });\n\n/**\n * Unwraps a single Ref object to its value.\n *\n * @example\n * ```ts\n * const r = { value: 42 };\n * const n = fromRef(r); // 42\n * console.log(n); // 42\n * ```\n */\nexport const fromRef = <T>(ref: { value: T }): T => ref.value;\n\n/**\n * Converts an object of Refs back to a plain object (unwraps all refs).\n *\n * @example\n * ```ts\n * const refs = { a: { value: 1 }, b: { value: \"x\" } };\n * const plain = fromRefs(refs); // { a: 1, b: \"x\" }\n * ```\n */\nexport const fromRefs = <T extends ToRefs<Record<string, unknown>>>(\n  obj: T,\n): FromRefs<T> => {\n  const result = {} as FromRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = fromRef(obj[key]!) as (typeof result)[typeof key];\n    }\n  }\n  return result;\n};\n\n/**\n * Converts a plain object to an object of Refs (deep, per property).\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"x\" };\n * const refs = toRefs(obj); // { a: { value: 1 }, b: { value: \"x\" } }\n * ```\n */\nexport const toRefs = <T extends Record<string, unknown>>(\n  obj: T,\n): ToRefs<T> => {\n  const result = {} as ToRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = toRef(obj[key]);\n    }\n  }\n  return result;\n};\n","import ts from 'typescript';\n\nexport type MaybeArray<T> = T | ReadonlyArray<T>;\n\nexport interface ITsDsl<T extends ts.Node = ts.Node> {\n  $render(): T;\n}\n\nexport abstract class TsDsl<T extends ts.Node = ts.Node> implements ITsDsl<T> {\n  abstract $render(): T;\n\n  /** Conditionally applies a callback to this builder. */\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (self: T, v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (self: T, v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: () => R | void,\n    ifFalse?: () => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: any,\n    ifFalse?: any,\n  ): R | T {\n    if (value) {\n      // Try calling with (self, value), then (value), then ()\n      let result: R | void | undefined;\n      try {\n        result = ifTrue?.(this, value as Exclude<V, false | null | undefined>);\n      } catch {\n        // ignore and try other signatures\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.(value as Exclude<V, false | null | undefined>);\n        } catch {\n          // ignore and try zero-arg\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.();\n        } catch {\n          // swallow\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    if (ifFalse) {\n      let result: R | void | undefined;\n      try {\n        result = ifFalse?.(this, value as Extract<V, false | null | undefined>);\n      } catch {\n        // ignore\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.(value as Extract<V, false | null | undefined>);\n        } catch {\n          // ignore\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.();\n        } catch {\n          // ignore\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    return this;\n  }\n\n  protected $maybeId<T extends string | ts.Expression>(\n    expr: T,\n  ): T extends string ? ts.Identifier : T {\n    return (\n      typeof expr === 'string' ? ts.factory.createIdentifier(expr) : expr\n    ) as T extends string ? ts.Identifier : T;\n  }\n\n  protected $node<I>(value: I): NodeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as NodeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return ts.factory.createIdentifier(value) as NodeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => this.unwrap(item)) as NodeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as NodeOfMaybe<I>;\n  }\n\n  protected $type<I>(\n    value: I,\n    args?: ReadonlyArray<ts.TypeNode>,\n  ): TypeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return ts.factory.createTypeReferenceNode(value, args) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'boolean') {\n      const literal = value\n        ? ts.factory.createTrue()\n        : ts.factory.createFalse();\n      return ts.factory.createLiteralTypeNode(literal) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'number') {\n      return ts.factory.createLiteralTypeNode(\n        ts.factory.createNumericLiteral(value),\n      ) as TypeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => this.$type(item, args)) as TypeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as TypeOfMaybe<I>;\n  }\n\n  protected unwrap<I>(value: I): I extends TsDsl<infer N> ? N : I {\n    return (\n      value instanceof TsDsl ? value.$render() : value\n    ) as I extends TsDsl<infer N> ? N : I;\n  }\n}\n\ntype NodeOfMaybe<I> = undefined extends I\n  ? NodeOf<NonNullable<I>> | undefined\n  : NodeOf<I>;\n\ntype NodeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<U extends TsDsl<infer N> ? N : U>\n    : I extends string\n      ? ts.Expression\n      : I extends TsDsl<infer N>\n        ? N\n        : I extends ts.Node\n          ? I\n          : never;\n\nexport type MaybeTsDsl<T> =\n  T extends TsDsl<infer U>\n    ? U | TsDsl<U>\n    : T extends ts.Node\n      ? T | TsDsl<T>\n      : never;\n\nexport abstract class TypeTsDsl<\n  T extends\n    | ts.LiteralTypeNode\n    | ts.QualifiedName\n    | ts.TypeElement\n    | ts.TypeNode\n    | ts.TypeParameterDeclaration = ts.TypeNode,\n> extends TsDsl<T> {}\n\ntype TypeOfMaybe<I> = undefined extends I\n  ? TypeOf<NonNullable<I>> | undefined\n  : TypeOf<I>;\n\ntype TypeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<TypeOf<U>>\n    : I extends string\n      ? ts.TypeNode\n      : I extends boolean\n        ? ts.LiteralTypeNode\n        : I extends TsDsl<infer N>\n          ? N\n          : I extends ts.TypeNode\n            ? I\n            : never;\n","import ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nexport class IdTsDsl extends TsDsl<ts.Identifier> {\n  protected name: string;\n\n  constructor(name: string) {\n    super();\n    this.name = name;\n  }\n\n  $render(): ts.Identifier {\n    return ts.factory.createIdentifier(this.name);\n  }\n}\n","import type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class NewlineTsDsl extends TsDsl<ts.Identifier> {\n  $render(): ts.Identifier {\n    return this.$node(new IdTsDsl('\\n'));\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-function-type */\nexport function mixin(target: Function, ...sources: ReadonlyArray<Function>) {\n  const targetProto = target.prototype;\n  for (const src of sources) {\n    let resolvedSource = src;\n    if (typeof src === 'function') {\n      try {\n        const candidate = src(target);\n        if (candidate?.prototype) {\n          resolvedSource = candidate;\n        }\n      } catch {\n        // noop\n      }\n    }\n    const sourceProto = resolvedSource.prototype;\n    if (!sourceProto) continue;\n    for (const [key, descriptor] of Object.entries(\n      Object.getOwnPropertyDescriptors(sourceProto),\n    )) {\n      if (key === 'constructor') continue;\n      if (key === '$render' && !descriptor.value.mixin) continue;\n      Object.defineProperty(targetProto, key, descriptor);\n    }\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\n/**\n * Adds `.arg()` and `.args()` for managing expression arguments in call-like nodes.\n */\nexport class ArgsMixin extends TsDsl {\n  protected _args?: Array<string | MaybeTsDsl<ts.Expression>>;\n\n  /** Adds a single expression argument. */\n  arg(arg: string | MaybeTsDsl<ts.Expression>): this {\n    (this._args ??= []).push(arg);\n    return this;\n  }\n\n  /** Adds one or more expression arguments. */\n  args(...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>): this {\n    (this._args ??= []).push(...args);\n    return this;\n  }\n\n  /** Renders the arguments into an array of `Expression`s. */\n  protected $args(): ReadonlyArray<ts.Expression> {\n    if (!this._args) return [];\n    return this.$node(this._args).map((arg) => this.$maybeId(arg));\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { ArgsMixin } from '../mixins/args';\n\nexport class DecoratorTsDsl extends TsDsl<ts.Decorator> {\n  protected name: string | ts.Expression;\n\n  constructor(\n    name: string | ts.Expression,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ) {\n    super();\n    this.name = name;\n    this.args(...args);\n  }\n\n  $render(): ts.Decorator {\n    const args = this.$args();\n    return ts.factory.createDecorator(\n      args.length\n        ? ts.factory.createCallExpression(\n            this.$maybeId(this.name),\n            undefined,\n            args,\n          )\n        : this.$maybeId(this.name),\n    );\n  }\n}\n\nexport interface DecoratorTsDsl extends ArgsMixin {}\nmixin(DecoratorTsDsl, ArgsMixin);\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DecoratorTsDsl } from '../decl/decorator';\n\nexport class DecoratorMixin extends TsDsl {\n  protected decorators?: Array<DecoratorTsDsl>;\n\n  /** Adds a decorator (e.g. `@sealed({ in: 'root' })`). */\n  decorator(\n    name: string | ts.Expression,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ): this {\n    (this.decorators ??= []).push(new DecoratorTsDsl(name, ...args));\n    return this;\n  }\n\n  /** Renders the decorators into an array of `ts.Decorator`s. */\n  protected $decorators(): ReadonlyArray<ts.Decorator> {\n    if (!this.decorators) return [];\n    return this.$node(this.decorators);\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class DocTsDsl extends TsDsl<ts.Node> {\n  protected _lines: Array<string> = [];\n\n  constructor(lines?: MaybeArray<string>, fn?: (d: DocTsDsl) => void) {\n    super();\n    if (lines) {\n      if (typeof lines === 'string') {\n        this.add(lines);\n      } else {\n        this.add(...lines);\n      }\n    }\n    fn?.(this);\n  }\n\n  add(...lines: ReadonlyArray<string>): this {\n    this._lines.push(...lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.filter((line) => Boolean(line) || line === '');\n    if (!lines.length) return node;\n\n    const jsdocTexts = lines.map((line) =>\n      ts.factory.createJSDocText(`${line}\\n`),\n    );\n\n    const jsdoc = ts.factory.createJSDocComment(\n      ts.factory.createNodeArray(jsdocTexts),\n      undefined,\n    );\n\n    const cleanedJsdoc = ts\n      .createPrinter()\n      .printNode(\n        ts.EmitHint.Unspecified,\n        jsdoc,\n        node.getSourceFile?.() ??\n          ts.createSourceFile('', '', ts.ScriptTarget.Latest),\n      )\n      .replace('/*', '')\n      .replace('*  */', '');\n\n    ts.addSyntheticLeadingComment(\n      node,\n      ts.SyntaxKind.MultiLineCommentTrivia,\n      cleanedJsdoc,\n      true,\n    );\n\n    return node;\n  }\n\n  $render(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { ITsDsl, MaybeArray } from '../base';\nimport { DocTsDsl } from '../layout/doc';\n\nexport function DocMixin<\n  TBase extends new (...args: ReadonlyArray<any>) => ITsDsl,\n>(Base: TBase) {\n  const $renderBase = Base.prototype.$render;\n\n  class Mixin extends Base {\n    _doc?: DocTsDsl;\n\n    doc(lines?: MaybeArray<string>, fn?: (d: DocTsDsl) => void): this {\n      this._doc = new DocTsDsl(lines, fn);\n      return this;\n    }\n\n    override $render(...args: Parameters<ITsDsl['$render']>) {\n      const node = $renderBase.apply(this, args);\n      return this._doc ? this._doc.apply(node) : node;\n    }\n  }\n\n  // @ts-expect-error\n  Mixin.prototype.$render.mixin = true;\n\n  return Mixin;\n}\n\nexport type DocMixin = InstanceType<ReturnType<typeof DocMixin>>;\n","import ts from 'typescript';\n\nimport type { TsDsl } from '../base';\n\n/**\n * Creates an accessor for adding TypeScript modifiers to a parent DSL node.\n *\n * @param parent - The parent DSL node to which modifiers will be added.\n * @returns An object with a `list` method that returns the collected modifiers.\n */\nexport function createModifierAccessor<Parent extends TsDsl>(parent: Parent) {\n  const modifiers: Array<ts.Modifier> = [];\n\n  /**\n   * Adds a modifier of the specified kind to the modifiers list if the condition is true.\n   *\n   * @param kind - The syntax kind of the modifier to add.\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The parent DSL node for chaining.\n   */\n  function _m(kind: ts.ModifierSyntaxKind, condition = true): Parent {\n    if (condition) {\n      modifiers.push(ts.factory.createModifier(kind));\n    }\n    return parent;\n  }\n\n  Object.assign(parent, { _m }); // attaches to parent\n\n  /**\n   * Returns the list of collected modifiers.\n   *\n   * @returns Array of TypeScript modifiers.\n   */\n  function list() {\n    return modifiers;\n  }\n\n  return { list };\n}\n\ntype Target = object & {\n  _m?(kind: ts.ModifierSyntaxKind, condition?: boolean): unknown;\n};\n\n/**\n * Mixin that adds an `abstract` modifier to a node.\n */\nexport class AbstractMixin {\n  /**\n   * Adds the `abstract` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  abstract<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.AbstractKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds an `async` modifier to a node.\n */\nexport class AsyncMixin {\n  /**\n   * Adds the `async` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  async<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.AsyncKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `const` modifier to a node.\n */\nexport class ConstMixin {\n  /**\n   * Adds the `const` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  const<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.ConstKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `declare` modifier to a node.\n */\nexport class DeclareMixin {\n  /**\n   * Adds the `declare` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  declare<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.DeclareKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `default` modifier to a node.\n */\nexport class DefaultMixin {\n  /**\n   * Adds the `default` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  default<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.DefaultKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds an `export` modifier to a node.\n */\nexport class ExportMixin {\n  /**\n   * Adds the `export` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  export<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.ExportKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds an `override` modifier to a node.\n */\nexport class OverrideMixin {\n  /**\n   * Adds the `override` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  override<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.OverrideKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `private` modifier to a node.\n */\nexport class PrivateMixin {\n  /**\n   * Adds the `private` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  private<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.PrivateKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `protected` modifier to a node.\n */\nexport class ProtectedMixin {\n  /**\n   * Adds the `protected` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  protected<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.ProtectedKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `public` modifier to a node.\n */\nexport class PublicMixin {\n  /**\n   * Adds the `public` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  public<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.PublicKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `readonly` modifier to a node.\n */\nexport class ReadonlyMixin {\n  /**\n   * Adds the `readonly` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  readonly<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.ReadonlyKeyword, condition) as T;\n  }\n}\n\n/**\n * Mixin that adds a `static` modifier to a node.\n */\nexport class StaticMixin {\n  /**\n   * Adds the `static` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  static<T extends Target>(this: T, condition: boolean = true): T {\n    return this._m!(ts.SyntaxKind.StaticKeyword, condition) as T;\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\n\nexport class TypeParamTsDsl extends TypeTsDsl<ts.TypeParameterDeclaration> {\n  protected name?: string | ts.Identifier;\n  protected constraint?: string | MaybeTsDsl<TypeTsDsl> | boolean;\n  protected defaultValue?: string | MaybeTsDsl<TypeTsDsl> | boolean;\n\n  constructor(\n    name?: string | ts.Identifier,\n    fn?: (name: TypeParamTsDsl) => void,\n  ) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  default(value: string | MaybeTsDsl<TypeTsDsl> | boolean): this {\n    this.defaultValue = value;\n    return this;\n  }\n\n  extends(constraint: string | MaybeTsDsl<TypeTsDsl> | boolean): this {\n    this.constraint = constraint;\n    return this;\n  }\n\n  $render(): ts.TypeParameterDeclaration {\n    if (!this.name) throw new Error('Missing type name');\n    return ts.factory.createTypeParameterDeclaration(\n      undefined,\n      this.$maybeId(this.name),\n      this.$type(this.constraint),\n      this.$type(this.defaultValue),\n    );\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeParamTsDsl } from '../type/param';\n\nexport class TypeParamsMixin extends TsDsl {\n  protected _generics?: Array<string | MaybeTsDsl<TypeParamTsDsl>>;\n\n  /** Adds a single type parameter (e.g. `T` in `Array<T>`). */\n  generic(...args: ConstructorParameters<typeof TypeParamTsDsl>): this {\n    const g = new TypeParamTsDsl(...args);\n    (this._generics ??= []).push(g);\n    return this;\n  }\n\n  /** Adds type parameters (e.g. `Map<string, T>`). */\n  generics(...args: ReadonlyArray<string | MaybeTsDsl<TypeParamTsDsl>>): this {\n    (this._generics ??= []).push(...args);\n    return this;\n  }\n\n  /** Returns the type parameters as an array of ts.TypeParameterDeclaration nodes. */\n  protected $generics():\n    | ReadonlyArray<ts.TypeParameterDeclaration>\n    | undefined {\n    return this._generics?.map((g) => {\n      const node = typeof g === 'string' ? new TypeParamTsDsl(g) : g;\n      return this.$node(node);\n    });\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport class ValueMixin extends TsDsl {\n  protected value?: string | MaybeTsDsl<ts.Expression>;\n\n  /** Sets the initializer expression (e.g. `= expr`). */\n  assign<T extends this>(this: T, expr: string | MaybeTsDsl<ts.Expression>): T {\n    this.value = expr;\n    return this;\n  }\n\n  protected $value(): ts.Expression | undefined {\n    return this.$node(this.value);\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport class TypeArgsMixin extends TsDsl {\n  protected _generics?: Array<string | MaybeTsDsl<TypeTsDsl>>;\n\n  /** Adds a single type argument (e.g. `string` in `Foo<string>`). */\n  generic(arg: string | MaybeTsDsl<TypeTsDsl>): this {\n    (this._generics ??= []).push(arg);\n    return this;\n  }\n\n  /** Adds type arguments (e.g. `Map<string, number>`). */\n  generics(...args: ReadonlyArray<string | MaybeTsDsl<TypeTsDsl>>): this {\n    (this._generics ??= []).push(...args);\n    return this;\n  }\n\n  /** Returns the type arguments as an array of ts.TypeNode nodes. */\n  protected $generics(): ReadonlyArray<ts.TypeNode> | undefined {\n    return this.$type(this._generics);\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport type { TypeOfExprTsDsl } from '../expr/typeof';\nimport type { TypeExprTsDsl } from '../type/expr';\nimport type { TypeIdxTsDsl } from '../type/idx';\nimport type { TypeOperatorTsDsl } from '../type/operator';\nimport type { TypeQueryTsDsl } from '../type/query';\n\ntype TypeExprFactory = (\n  nameOrFn?: string | ((t: TypeExprTsDsl) => void),\n  fn?: (t: TypeExprTsDsl) => void,\n) => TypeExprTsDsl;\nlet typeExprFactory: TypeExprFactory | undefined;\n/** Registers the TypeExpr DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessTypeExprFactory(\n  factory: TypeExprFactory,\n): void {\n  typeExprFactory = factory;\n}\n\ntype TypeIdxFactory = (\n  expr: MaybeTsDsl<TypeTsDsl>,\n  index: string | number | MaybeTsDsl<ts.TypeNode>,\n) => TypeIdxTsDsl;\nlet typeIdxFactory: TypeIdxFactory | undefined;\n/** Registers the TypeIdxTsDsl DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessTypeIdxFactory(\n  factory: TypeIdxFactory,\n): void {\n  typeIdxFactory = factory;\n}\n\ntype TypeOfExprFactory = (\n  expr: string | MaybeTsDsl<ts.Expression>,\n) => TypeOfExprTsDsl;\nlet typeOfExprFactory: TypeOfExprFactory | undefined;\n/** Registers the TypeOfExpr DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessTypeOfExprFactory(\n  factory: TypeOfExprFactory,\n): void {\n  typeOfExprFactory = factory;\n}\n\ntype TypeOperatorFactory = () => TypeOperatorTsDsl;\nlet typeOperatorFactory: TypeOperatorFactory | undefined;\n/** Registers the TypeOperatorTsDsl DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessTypeOperatorFactory(\n  factory: TypeOperatorFactory,\n): void {\n  typeOperatorFactory = factory;\n}\n\ntype TypeQueryFactory = (\n  expr: string | MaybeTsDsl<TypeTsDsl | ts.Expression>,\n) => TypeQueryTsDsl;\nlet typeQueryFactory: TypeQueryFactory | undefined;\n/** Registers the TypeQuery DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessTypeQueryFactory(\n  factory: TypeQueryFactory,\n): void {\n  typeQueryFactory = factory;\n}\n\nexport class TypeExprMixin {\n  /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n  idx(\n    this: MaybeTsDsl<TypeTsDsl>,\n    index: string | number | MaybeTsDsl<ts.TypeNode>,\n  ): TypeIdxTsDsl {\n    return typeIdxFactory!(this, index);\n  }\n\n  /** Shorthand: builds `keyof T`. */\n  keyof(this: MaybeTsDsl<TypeTsDsl>): TypeOperatorTsDsl {\n    return typeOperatorFactory!().keyof(this);\n  }\n\n  /** Shorthand: builds `readonly T`. */\n  readonly(this: MaybeTsDsl<TypeTsDsl>): TypeOperatorTsDsl {\n    return typeOperatorFactory!().readonly(this);\n  }\n\n  /** Create a TypeExpr DSL node representing ReturnType<this>. */\n  returnType(this: MaybeTsDsl<ts.Expression>): TypeExprTsDsl {\n    return typeExprFactory!('ReturnType').generic(typeQueryFactory!(this));\n  }\n\n  /** Create a TypeOfExpr DSL node representing typeof this. */\n  typeofExpr(this: MaybeTsDsl<ts.Expression>): TypeOfExprTsDsl {\n    return typeOfExprFactory!(this);\n  }\n\n  /** Create a TypeQuery DSL node representing typeof this. */\n  typeofType(this: MaybeTsDsl<TypeTsDsl | ts.Expression>): TypeQueryTsDsl {\n    return typeQueryFactory!(this);\n  }\n\n  /**\n   * Create a `typeof` operator that narrows its return type based on the receiver.\n   *\n   * - If `this` is a `TsDsl<ts.Expression>` ‚Üí returns TypeOfExprTsDsl\n   * - If `this` is a `TsDsl<TypeTsDsl>`     ‚Üí returns TypeQueryTsDsl\n   * - If `this` is a raw ts.Expression      ‚Üí returns TypeOfExprTsDsl\n   * - Otherwise                             ‚Üí returns TypeQueryTsDsl\n   */\n  typeof<T extends MaybeTsDsl<TypeTsDsl | ts.Expression>>(\n    this: T,\n  ): T extends MaybeTsDsl<ts.Expression>\n    ? TypeOfExprTsDsl\n    : T extends MaybeTsDsl<TypeTsDsl>\n      ? TypeQueryTsDsl\n      : TypeQueryTsDsl | TypeOfExprTsDsl {\n    if (this instanceof TsDsl) {\n      const node = this.$render();\n      return ts.isExpression(node)\n        ? (typeOfExprFactory!(this) as any)\n        : (typeQueryFactory!(this) as any);\n    }\n\n    if (ts.isExpression(this as any)) {\n      return typeOfExprFactory!(this as ts.Expression) as any;\n    }\n\n    return typeQueryFactory!(this) as any;\n  }\n\n  /** Shorthand: builds `unique T`. */\n  unique(this: MaybeTsDsl<TypeTsDsl>): TypeOperatorTsDsl {\n    return typeOperatorFactory!().unique(this);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\nexport class TypeAttrTsDsl extends TypeTsDsl<ts.QualifiedName> {\n  protected _base?: string | MaybeTsDsl<ts.EntityName>;\n  protected right: string | ts.Identifier;\n\n  constructor(\n    base: string | MaybeTsDsl<ts.EntityName>,\n    right: string | ts.Identifier,\n  );\n  constructor(right: string | ts.Identifier);\n  constructor(\n    baseOrRight: string | MaybeTsDsl<ts.EntityName>,\n    maybeRight?: string | ts.Identifier,\n  ) {\n    super();\n    if (maybeRight) {\n      this.base(baseOrRight);\n      this.right = maybeRight;\n    } else {\n      this.base(undefined);\n      this.right = baseOrRight as string | ts.Identifier;\n    }\n  }\n\n  base(base?: string | MaybeTsDsl<ts.EntityName>): this {\n    this._base = base;\n    return this;\n  }\n\n  $render(): ts.QualifiedName {\n    if (!this._base) {\n      throw new Error('TypeAttrTsDsl: missing base for qualified name');\n    }\n    const left = this.$node(this._base);\n    if (!ts.isEntityName(left)) {\n      throw new Error('TypeAttrTsDsl: base must be an EntityName');\n    }\n    const right = this.$maybeId(this.right);\n    return ts.factory.createQualifiedName(left, right);\n  }\n}\n\nexport interface TypeAttrTsDsl extends TypeExprMixin {}\nmixin(TypeAttrTsDsl, TypeExprMixin);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport {\n  registerLazyAccessTypeExprFactory,\n  TypeExprMixin,\n} from '../mixins/type-expr';\nimport { TypeAttrTsDsl } from './attr';\n\nexport class TypeExprTsDsl extends TypeTsDsl<ts.TypeReferenceNode> {\n  protected _exprInput?: string | ts.Identifier | TypeAttrTsDsl;\n\n  constructor();\n  constructor(fn: (t: TypeExprTsDsl) => void);\n  constructor(name: string);\n  constructor(name: string, fn?: (t: TypeExprTsDsl) => void);\n  constructor(\n    nameOrFn?: string | ((t: TypeExprTsDsl) => void),\n    fn?: (t: TypeExprTsDsl) => void,\n  ) {\n    super();\n    if (typeof nameOrFn === 'string') {\n      this._exprInput = nameOrFn;\n      fn?.(this);\n    } else {\n      nameOrFn?.(this);\n    }\n  }\n\n  /** Accesses a nested type (e.g. `Foo.Bar`). */\n  attr(right: string | ts.Identifier | TypeAttrTsDsl): this {\n    this._exprInput =\n      right instanceof TypeAttrTsDsl\n        ? right.base(this._exprInput)\n        : new TypeAttrTsDsl(this._exprInput!, right);\n    return this;\n  }\n\n  $render(): ts.TypeReferenceNode {\n    if (!this._exprInput)\n      throw new Error('TypeExpr must have either an expression or an object');\n    return ts.factory.createTypeReferenceNode(\n      // @ts-expect-error --- need to fix types\n      this.$type(this._exprInput),\n      this.$generics(),\n    );\n  }\n}\n\nexport interface TypeExprTsDsl extends TypeArgsMixin, TypeExprMixin {}\nmixin(TypeExprTsDsl, TypeArgsMixin, TypeExprMixin);\n\nregisterLazyAccessTypeExprFactory(\n  (...args) =>\n    new TypeExprTsDsl(...(args as ConstructorParameters<typeof TypeExprTsDsl>)),\n);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  ReadonlyMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ValueMixin } from '../mixins/value';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport class FieldTsDsl extends TsDsl<ts.PropertyDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n  protected name: string;\n  protected _type?: TypeTsDsl;\n\n  constructor(name: string, fn?: (f: FieldTsDsl) => void) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  /** Sets the field type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  /** Builds the `PropertyDeclaration` node. */\n  $render(): ts.PropertyDeclaration {\n    return ts.factory.createPropertyDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      this.name,\n      undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n  }\n}\n\nexport interface FieldTsDsl\n  extends DecoratorMixin,\n    DocMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin,\n    ReadonlyMixin,\n    StaticMixin,\n    ValueMixin {}\nmixin(\n  FieldTsDsl,\n  DecoratorMixin,\n  DocMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  ReadonlyMixin,\n  StaticMixin,\n  ValueMixin,\n);\n","import ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nexport class StmtTsDsl extends TsDsl<ts.Statement> {\n  protected _inner: ts.Expression | ts.Statement | TsDsl<any>;\n\n  constructor(inner: ts.Expression | ts.Statement | TsDsl<any>) {\n    super();\n    this._inner = inner;\n  }\n\n  $render(): ts.Statement {\n    const node = this.$node(this._inner);\n    return ts.isStatement(node)\n      ? node\n      : ts.factory.createExpressionStatement(node);\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { StmtTsDsl } from '../stmt/stmt';\n\n/**\n * Adds `.do()` for appending statements or expressions to a body.\n */\nexport class DoMixin extends TsDsl {\n  protected _do?: Array<MaybeTsDsl<ts.Expression | ts.Statement>>;\n\n  /** Adds one or more expressions/statements to the body. */\n  do(...items: ReadonlyArray<MaybeTsDsl<ts.Expression | ts.Statement>>): this {\n    (this._do ??= []).push(...items);\n    return this;\n  }\n\n  /** Renders the collected `.do()` calls into an array of `Statement` nodes. */\n  protected $do(): ReadonlyArray<ts.Statement> {\n    if (!this._do) return [];\n    return this.$node(this._do.map((item) => new StmtTsDsl(item)));\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","export class OptionalMixin {\n  protected _optional?: boolean;\n\n  /** Marks the node as optional when the condition is true. */\n  optional<T extends this>(this: T, condition?: boolean): T {\n    this._optional = arguments.length === 0 ? true : Boolean(condition);\n    return this;\n  }\n\n  /** Marks the node as required when the condition is true. */\n  required<T extends this>(this: T, condition?: boolean): T {\n    this._optional = arguments.length === 0 ? false : !condition;\n    return this;\n  }\n}\n","import ts from 'typescript';\n\nimport { TsDsl } from './base';\n\nexport class TokenTsDsl<K extends ts.SyntaxKind = never> extends TsDsl<\n  ts.Token<K>\n> {\n  protected _kind?: K;\n\n  /** Sets the token kind */\n  kind(kind: K): this {\n    this._kind = kind;\n    return this;\n  }\n\n  /** Creates `-` */\n  minus(): TokenTsDsl<ts.SyntaxKind.MinusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.MinusToken>).kind(\n      ts.SyntaxKind.MinusToken,\n    );\n  }\n\n  /** Creates `?` (optional) */\n  optional(): TokenTsDsl<ts.SyntaxKind.QuestionToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionToken>).kind(\n      ts.SyntaxKind.QuestionToken,\n    );\n  }\n\n  /** Creates `+` */\n  plus(): TokenTsDsl<ts.SyntaxKind.PlusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.PlusToken>).kind(\n      ts.SyntaxKind.PlusToken,\n    );\n  }\n\n  /** Creates `?.` (optional chaining token) */\n  questionDot(): TokenTsDsl<ts.SyntaxKind.QuestionDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionDotToken>).kind(\n      ts.SyntaxKind.QuestionDotToken,\n    );\n  }\n\n  /** Creates `readonly` */\n  readonly(): TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword> {\n    return (this as TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword>).kind(\n      ts.SyntaxKind.ReadonlyKeyword,\n    );\n  }\n\n  /** Creates `...` (spread / rest) */\n  spread(): TokenTsDsl<ts.SyntaxKind.DotDotDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.DotDotDotToken>).kind(\n      ts.SyntaxKind.DotDotDotToken,\n    );\n  }\n\n  /** Renders the final token */\n  $render(): ts.Token<K> {\n    if (!this._kind) {\n      throw new Error(`Token missing \\`.kind(kind)\\``);\n    }\n    // @ts-expect-error\n    return ts.factory.createToken(this._kind);\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TokenTsDsl } from '../token';\n\n/**\n * Builds binding patterns (e.g. `{ foo, bar }`, `[a, b, ...rest]`).\n */\nexport class PatternTsDsl extends TsDsl<ts.BindingName> {\n  protected pattern?:\n    | { kind: 'array'; values: ReadonlyArray<string> }\n    | { kind: 'object'; values: Record<string, string> };\n  protected _spread?: string;\n\n  /** Defines an array pattern (e.g. `[a, b, c]`). */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this {\n    const values =\n      props[0] instanceof Array\n        ? [...props[0]]\n        : (props as ReadonlyArray<string>);\n    this.pattern = { kind: 'array', values };\n    return this;\n  }\n\n  /** Defines an object pattern (e.g. `{ a, b: alias }`). */\n  object(\n    ...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>\n  ): this {\n    const entries: Record<string, string> = {};\n    for (const p of props) {\n      if (typeof p === 'string') entries[p] = p;\n      else if (p instanceof Array) for (const n of p) entries[n] = n;\n      else Object.assign(entries, p);\n    }\n    this.pattern = { kind: 'object', values: entries };\n    return this;\n  }\n\n  /** Adds a spread element (e.g. `...rest`, `...options`, `...args`). */\n  spread(name: string): this {\n    this._spread = name;\n    return this;\n  }\n\n  /** Builds and returns a BindingName (ObjectBindingPattern, ArrayBindingPattern, or Identifier). */\n  $render(): ts.BindingName {\n    if (!this.pattern) {\n      throw new Error('PatternTsDsl requires object() or array() pattern');\n    }\n\n    if (this.pattern.kind === 'object') {\n      const elements = Object.entries(this.pattern.values).map(\n        ([key, alias]) =>\n          key === alias\n            ? ts.factory.createBindingElement(\n                undefined,\n                undefined,\n                key,\n                undefined,\n              )\n            : ts.factory.createBindingElement(undefined, key, alias, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createObjectBindingPattern(elements);\n    }\n\n    if (this.pattern.kind === 'array') {\n      const elements = this.pattern.values.map((p) =>\n        ts.factory.createBindingElement(undefined, undefined, p, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createArrayBindingPattern(elements);\n    }\n\n    throw new Error('PatternTsDsl requires object() or array() pattern');\n  }\n\n  private createSpread(): ts.BindingElement | undefined {\n    return this._spread\n      ? ts.factory.createBindingElement(\n          this.$node(new TokenTsDsl().spread()),\n          undefined,\n          this.$node(new IdTsDsl(this._spread)),\n        )\n      : undefined;\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { PatternTsDsl } from '../decl/pattern';\n\n/**\n * Mixin providing `.array()`, `.object()`, and `.spread()` methods for defining destructuring patterns.\n */\nexport class PatternMixin extends TsDsl {\n  protected pattern?: PatternTsDsl;\n\n  /** Defines an array binding pattern. */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this {\n    (this.pattern ??= new PatternTsDsl()).array(...props);\n    return this;\n  }\n\n  /** Defines an object binding pattern. */\n  object(\n    ...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>\n  ): this {\n    (this.pattern ??= new PatternTsDsl()).object(...props);\n    return this;\n  }\n\n  /** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */\n  spread(name: string): this {\n    (this.pattern ??= new PatternTsDsl()).spread(name);\n    return this;\n  }\n\n  /** Renders the pattern into a `BindingName`. */\n  protected $pattern(): ts.BindingName | undefined {\n    return this.$node(this.pattern);\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport class ParamTsDsl extends TsDsl<ts.ParameterDeclaration> {\n  protected name?: string;\n  protected _type?: TypeTsDsl;\n\n  constructor(\n    name: string | ((p: ParamTsDsl) => void),\n    fn?: (p: ParamTsDsl) => void,\n  ) {\n    super();\n    if (typeof name === 'string') {\n      this.name = name;\n      fn?.(this);\n    } else {\n      name(this);\n    }\n  }\n\n  /** Sets the parameter type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  $render(): ts.ParameterDeclaration {\n    const name = this.$pattern() ?? this.name;\n    if (!name)\n      throw new Error(\n        'Param must have either a name or a destructuring pattern',\n      );\n    return ts.factory.createParameterDeclaration(\n      this.$decorators(),\n      undefined,\n      name,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n  }\n}\n\nexport interface ParamTsDsl\n  extends DecoratorMixin,\n    OptionalMixin,\n    PatternMixin,\n    ValueMixin {}\nmixin(ParamTsDsl, DecoratorMixin, OptionalMixin, PatternMixin, ValueMixin);\n","import type ts from 'typescript';\n\nimport { type MaybeTsDsl, TsDsl } from '../base';\nimport { ParamTsDsl } from '../decl/param';\n\nexport class ParamMixin extends TsDsl {\n  protected _params?: Array<MaybeTsDsl<ts.ParameterDeclaration>>;\n\n  /** Adds a parameter. */\n  param(\n    name: string | ((p: ParamTsDsl) => void),\n    fn?: (p: ParamTsDsl) => void,\n  ): this {\n    const p = new ParamTsDsl(name, fn);\n    (this._params ??= []).push(p);\n    return this;\n  }\n\n  /** Adds multiple parameters. */\n  params(...params: ReadonlyArray<MaybeTsDsl<ts.ParameterDeclaration>>): this {\n    (this._params ??= []).push(...params);\n    return this;\n  }\n\n  /** Renders the parameters into an array of `ParameterDeclaration`s. */\n  protected $params(): ReadonlyArray<ts.ParameterDeclaration> {\n    if (!this._params) return [];\n    return this.$node(this._params);\n  }\n\n  $render(): ts.Node {\n    throw new Error('noop');\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\n\nexport class InitTsDsl extends TsDsl<ts.ConstructorDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n\n  constructor(fn?: (i: InitTsDsl) => void) {\n    super();\n    fn?.(this);\n  }\n\n  /** Builds the `ConstructorDeclaration` node. */\n  $render(): ts.ConstructorDeclaration {\n    return ts.factory.createConstructorDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      this.$params(),\n      ts.factory.createBlock(this.$do(), true),\n    );\n  }\n}\n\nexport interface InitTsDsl\n  extends DecoratorMixin,\n    DoMixin,\n    DocMixin,\n    ParamMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin {}\nmixin(\n  InitTsDsl,\n  DecoratorMixin,\n  DoMixin,\n  DocMixin,\n  ParamMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport class MethodTsDsl extends TsDsl<ts.MethodDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n  protected name: string;\n  protected _returns?: TypeTsDsl;\n\n  constructor(name: string, fn?: (m: MethodTsDsl) => void) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  /** Sets the return type. */\n  returns(type: string | TypeTsDsl): this {\n    this._returns = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  /** Builds the `MethodDeclaration` node. */\n  $render(): ts.MethodDeclaration {\n    return ts.factory.createMethodDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      undefined,\n      this.name,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$generics(),\n      this.$params(),\n      this.$type(this._returns),\n      ts.factory.createBlock(this.$do(), true),\n    );\n  }\n}\n\nexport interface MethodTsDsl\n  extends AbstractMixin,\n    AsyncMixin,\n    DecoratorMixin,\n    DoMixin,\n    DocMixin,\n    OptionalMixin,\n    ParamMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin,\n    StaticMixin,\n    TypeParamsMixin {}\nmixin(\n  MethodTsDsl,\n  AbstractMixin,\n  AsyncMixin,\n  DecoratorMixin,\n  DoMixin,\n  DocMixin,\n  OptionalMixin,\n  ParamMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n  TypeParamsMixin,\n);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { NewlineTsDsl } from '../layout/newline';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  createModifierAccessor,\n  DefaultMixin,\n  ExportMixin,\n} from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { FieldTsDsl } from './field';\nimport { InitTsDsl } from './init';\nimport { MethodTsDsl } from './method';\n\nexport class ClassTsDsl extends TsDsl<ts.ClassDeclaration> {\n  protected heritageClauses: Array<ts.HeritageClause> = [];\n  protected body: Array<MaybeTsDsl<ts.ClassElement | NewlineTsDsl>> = [];\n  protected modifiers = createModifierAccessor(this);\n  protected name: string;\n\n  constructor(name: string) {\n    super();\n    this.name = name;\n  }\n\n  /** Adds one or more class members (fields, methods, etc.). */\n  do(...items: ReadonlyArray<MaybeTsDsl<ts.ClassElement | ts.Node>>): this {\n    // @ts-expect-error --- IGNORE ---\n    this.body.push(...items);\n    return this;\n  }\n\n  /** Adds a base class to extend from. */\n  extends(base?: string | ts.Expression | false | null): this {\n    if (!base) return this;\n    this.heritageClauses.push(\n      ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n        ts.factory.createExpressionWithTypeArguments(\n          this.$maybeId(base),\n          undefined,\n        ),\n      ]),\n    );\n    return this;\n  }\n\n  /** Adds a class field. */\n  field(name: string, fn?: (f: FieldTsDsl) => void): this {\n    const f = new FieldTsDsl(name, fn);\n    this.body.push(f);\n    return this;\n  }\n\n  /** Adds a class constructor. */\n  init(fn?: (i: InitTsDsl) => void): this {\n    const i = new InitTsDsl(fn);\n    this.body.push(i);\n    return this;\n  }\n\n  /** Adds a class method. */\n  method(name: string, fn?: (m: MethodTsDsl) => void): this {\n    const m = new MethodTsDsl(name, fn);\n    this.body.push(m);\n    return this;\n  }\n\n  /** Inserts an empty line between members for formatting. */\n  newline(): this {\n    this.body.push(new NewlineTsDsl());\n    return this;\n  }\n\n  /** Builds the `ClassDeclaration` node. */\n  $render(): ts.ClassDeclaration {\n    const body = this.$node(this.body) as ReadonlyArray<ts.ClassElement>;\n    return ts.factory.createClassDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      this.name,\n      this.$generics(),\n      this.heritageClauses,\n      body,\n    );\n  }\n}\n\nexport interface ClassTsDsl\n  extends AbstractMixin,\n    DecoratorMixin,\n    DefaultMixin,\n    DocMixin,\n    ExportMixin,\n    TypeParamsMixin {}\nmixin(\n  ClassTsDsl,\n  AbstractMixin,\n  DecoratorMixin,\n  DefaultMixin,\n  DocMixin,\n  ExportMixin,\n  TypeParamsMixin,\n);\n","/**\n * Matches characters from the start as long as they're not allowed.\n */\nexport const illegalStartCharactersRegExp = /^[^$_\\p{ID_Start}]+/u;\n\n/**\n * Matches string if it contains only digits and optionally decimal point or\n * leading minus sign.\n */\nexport const numberRegExp = /^-?\\d+(\\.\\d+)?$/;\n\nexport const reservedBrowserGlobalsRegExp =\n  /^(document|history|location|navigator|window)$/g;\n\nexport const reservedJavaScriptGlobalsRegExp =\n  /^(console|Array|Date|Error|Function|JSON|Map|Math|Object|Promise|RegExp|Set|WeakMap|WeakSet)$/g;\n\nexport const reservedJavaScriptKeywordsRegExp =\n  /^(arguments|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|eval|export|extends|false|finally|for|from|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)$/g;\n\nexport const reservedNodeGlobalsRegExp = /^(global|process|Buffer)$/g;\n\nexport const reservedTypeScriptKeywordsRegExp =\n  /^(any|as|bigint|boolean|namespace|never|null|number|string|symbol|type|undefined|unknown|void)$/g;\n\n/**\n * Javascript identifier regexp pattern retrieved from\n * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nexport const validTypescriptIdentifierRegExp =\n  /^[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*$/u;\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport class PrefixTsDsl extends TsDsl<ts.PrefixUnaryExpression> {\n  protected _expr?: string | MaybeTsDsl<ts.Expression>;\n  protected _op?: ts.PrefixUnaryOperator;\n\n  constructor(\n    expr?: string | MaybeTsDsl<ts.Expression>,\n    op?: ts.PrefixUnaryOperator,\n  ) {\n    super();\n    this._expr = expr;\n    this._op = op;\n  }\n\n  /** Sets the operand (the expression being prefixed). */\n  expr(expr: string | MaybeTsDsl<ts.Expression>): this {\n    this._expr = expr;\n    return this;\n  }\n\n  /** Sets the operator to MinusToken for negation (`-`). */\n  neg(): this {\n    this._op = ts.SyntaxKind.MinusToken;\n    return this;\n  }\n\n  /** Sets the operator to ExclamationToken for logical NOT (`!`). */\n  not(): this {\n    this._op = ts.SyntaxKind.ExclamationToken;\n    return this;\n  }\n\n  /** Sets the operator (e.g. `ts.SyntaxKind.ExclamationToken` for `!`). */\n  op(op: ts.PrefixUnaryOperator): this {\n    this._op = op;\n    return this;\n  }\n\n  /** Renders the prefix unary expression node. */\n  $render(): ts.PrefixUnaryExpression {\n    if (!this._expr) {\n      throw new Error('Missing expression for prefix unary expression');\n    }\n    if (!this._op) {\n      throw new Error('Missing operator for prefix unary expression');\n    }\n    return ts.factory.createPrefixUnaryExpression(\n      this._op,\n      this.$node(this._expr),\n    );\n  }\n}\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport type { AsTsDsl } from '../expr/as';\n\ntype AsFactory = (\n  expr: string | MaybeTsDsl<ts.Expression>,\n  type: string | TypeTsDsl,\n) => AsTsDsl;\nlet asFactory: AsFactory | undefined;\n/** Registers the As DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessAsFactory(factory: AsFactory): void {\n  asFactory = factory;\n}\n\nexport class AsMixin {\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as(\n    this: string | MaybeTsDsl<ts.Expression>,\n    type: string | TypeTsDsl,\n  ): AsTsDsl {\n    return asFactory!(this, type);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging, @typescript-eslint/no-empty-object-type */\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { PrefixTsDsl } from '../expr/prefix';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\n\nexport class LiteralTsDsl extends TsDsl<ts.LiteralTypeNode['literal']> {\n  protected value: string | number | boolean | null;\n\n  constructor(value: string | number | boolean | null) {\n    super();\n    this.value = value;\n  }\n\n  $render(): ts.LiteralTypeNode['literal'] {\n    if (typeof this.value === 'boolean') {\n      return this.value ? ts.factory.createTrue() : ts.factory.createFalse();\n    }\n    if (typeof this.value === 'number') {\n      const expr = ts.factory.createNumericLiteral(Math.abs(this.value));\n      return this.value < 0 ? this.$node(new PrefixTsDsl(expr).neg()) : expr;\n    }\n    if (typeof this.value === 'string') {\n      return ts.factory.createStringLiteral(this.value, true);\n    }\n    if (this.value === null) {\n      return ts.factory.createNull();\n    }\n    throw new Error(`Unsupported literal: ${String(this.value)}`);\n  }\n}\n\nexport interface LiteralTsDsl extends AsMixin {}\nmixin(LiteralTsDsl, AsMixin);\n","import ts from 'typescript';\n\nimport { numberRegExp, validTypescriptIdentifierRegExp } from '~/utils/regexp';\n\nimport { IdTsDsl } from '../expr/id';\nimport { LiteralTsDsl } from '../expr/literal';\n\nexport const safeMemberName = (name: string): ts.PropertyName => {\n  validTypescriptIdentifierRegExp.lastIndex = 0;\n  if (validTypescriptIdentifierRegExp.test(name)) {\n    return new IdTsDsl(name).$render();\n  }\n  return new LiteralTsDsl(name).$render() as ts.StringLiteral;\n};\n\nexport const safePropName = (name: string): ts.PropertyName => {\n  numberRegExp.lastIndex = 0;\n  if (numberRegExp.test(name)) {\n    return name.startsWith('-')\n      ? (new LiteralTsDsl(name).$render() as ts.StringLiteral)\n      : ts.factory.createNumericLiteral(name);\n  }\n\n  validTypescriptIdentifierRegExp.lastIndex = 0;\n  if (validTypescriptIdentifierRegExp.test(name)) {\n    return new IdTsDsl(name).$render();\n  }\n\n  return new LiteralTsDsl(name).$render() as ts.StringLiteral;\n};\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { safeMemberName } from '../utils/prop';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nexport class EnumMemberTsDsl extends TsDsl<ts.EnumMember> {\n  private _name: string;\n  private _value?: Value;\n\n  constructor(name: string, value?: ValueFn) {\n    super();\n    this._name = name;\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this.value(value);\n    }\n  }\n\n  /** Sets the enum member value. */\n  value(value?: Value): this {\n    this._value = value;\n    return this;\n  }\n\n  $render(): ts.EnumMember {\n    return ts.factory.createEnumMember(\n      safeMemberName(this._name),\n      this.$node(this._value),\n    );\n  }\n}\n\nexport interface EnumMemberTsDsl extends DocMixin {}\nmixin(EnumMemberTsDsl, DocMixin);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  ConstMixin,\n  createModifierAccessor,\n  ExportMixin,\n} from '../mixins/modifiers';\nimport { EnumMemberTsDsl } from './member';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nexport class EnumTsDsl extends TsDsl<ts.EnumDeclaration> {\n  private _members: Array<EnumMemberTsDsl> = [];\n  private _name: string | ts.Identifier;\n  protected modifiers = createModifierAccessor(this);\n\n  constructor(name: string | ts.Identifier, fn?: (e: EnumTsDsl) => void) {\n    super();\n    this._name = name;\n    fn?.(this);\n  }\n\n  /** Adds an enum member. */\n  member(name: string, value?: ValueFn): this {\n    const m = new EnumMemberTsDsl(name, value);\n    this._members.push(m);\n    return this;\n  }\n\n  /** Adds multiple enum members. */\n  members(...members: ReadonlyArray<EnumMemberTsDsl>): this {\n    this._members.push(...members);\n    return this;\n  }\n\n  /** Renders the enum declaration. */\n  $render(): ts.EnumDeclaration {\n    return ts.factory.createEnumDeclaration(\n      this.modifiers.list(),\n      this._name,\n      this.$node(this._members),\n    );\n  }\n}\n\nexport interface EnumTsDsl extends ConstMixin, DocMixin, ExportMixin {}\nmixin(EnumTsDsl, ConstMixin, DocMixin, ExportMixin);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeExprTsDsl } from '../type/expr';\n\ntype FuncMode = 'arrow' | 'decl' | 'expr';\n\nclass ImplFuncTsDsl<M extends FuncMode = 'arrow'> extends TsDsl<\n  M extends 'decl'\n    ? ts.FunctionDeclaration\n    : M extends 'expr'\n      ? ts.FunctionExpression\n      : ts.ArrowFunction\n> {\n  protected mode: FuncMode;\n  protected modifiers = createModifierAccessor(this);\n  protected name?: string;\n  protected _returns?: TypeTsDsl;\n\n  constructor();\n  constructor(fn: (f: ImplFuncTsDsl<'arrow'>) => void);\n  constructor(name: string);\n  constructor(name: string, fn: (f: ImplFuncTsDsl<'decl'>) => void);\n  constructor(\n    nameOrFn?: string | ((f: ImplFuncTsDsl<'arrow'>) => void),\n    fn?: (f: ImplFuncTsDsl<'decl'>) => void,\n  ) {\n    super();\n    if (typeof nameOrFn === 'string') {\n      this.name = nameOrFn;\n      this.mode = 'decl';\n      fn?.(this as unknown as FuncTsDsl<'decl'>);\n    } else {\n      this.mode = 'arrow';\n      nameOrFn?.(this as unknown as FuncTsDsl<'arrow'>);\n    }\n  }\n\n  /** Switches the function to an arrow function form. */\n  arrow(): FuncTsDsl<'arrow'> {\n    this.mode = 'arrow';\n    return this as unknown as FuncTsDsl<'arrow'>;\n  }\n\n  /** Switches the function to a function declaration form. */\n  decl(): FuncTsDsl<'decl'> {\n    this.mode = 'decl';\n    return this as unknown as FuncTsDsl<'decl'>;\n  }\n\n  /** Switches the function to a function expression form. */\n  expr(): FuncTsDsl<'expr'> {\n    this.mode = 'expr';\n    return this as unknown as FuncTsDsl<'expr'>;\n  }\n\n  /** Sets the return type. */\n  returns(type: string | TypeTsDsl): this {\n    this._returns = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  $render(): M extends 'decl'\n    ? ts.FunctionDeclaration\n    : M extends 'expr'\n      ? ts.FunctionExpression\n      : ts.ArrowFunction {\n    if (this.mode === 'decl') {\n      if (!this.name) throw new Error('Function declaration requires a name');\n      return ts.factory.createFunctionDeclaration(\n        [...this.$decorators(), ...this.modifiers.list()],\n        undefined,\n        this.name,\n        this.$generics(),\n        this.$params(),\n        this.$type(this._returns),\n        ts.factory.createBlock(this.$do(), true),\n      ) as any;\n    }\n\n    if (this.mode === 'expr') {\n      return ts.factory.createFunctionExpression(\n        this.modifiers.list(),\n        undefined,\n        this.name,\n        this.$generics(),\n        this.$params(),\n        this.$type(this._returns),\n        ts.factory.createBlock(this.$do(), true),\n      ) as any;\n    }\n\n    const body = this.$do();\n    const exprBody =\n      body.length === 1 && ts.isReturnStatement(body[0]!)\n        ? (body[0].expression ?? ts.factory.createBlock(body, true))\n        : ts.factory.createBlock(body, true);\n\n    return ts.factory.createArrowFunction(\n      this.modifiers.list(),\n      this.$generics(),\n      this.$params(),\n      this.$type(this._returns),\n      undefined,\n      exprBody,\n    ) as any;\n  }\n}\n\ninterface ImplFuncTsDsl\n  extends AbstractMixin,\n    AsMixin,\n    AsyncMixin,\n    DecoratorMixin,\n    DoMixin,\n    DocMixin,\n    ParamMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin,\n    StaticMixin,\n    TypeParamsMixin {}\nmixin(\n  ImplFuncTsDsl,\n  AbstractMixin,\n  AsMixin,\n  AsyncMixin,\n  DecoratorMixin,\n  DoMixin,\n  DocMixin,\n  ParamMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n  TypeParamsMixin,\n);\n\nexport const FuncTsDsl = ImplFuncTsDsl as {\n  new (): FuncTsDsl<'arrow'>;\n  new (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n  new (name: string): FuncTsDsl<'decl'>;\n  new (name: string, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n} & typeof ImplFuncTsDsl;\nexport type FuncTsDsl<M extends FuncMode = 'arrow'> = ImplFuncTsDsl<M>;\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport type { AsyncMixin } from '../mixins/modifiers';\nimport {\n  AbstractMixin,\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\n\nexport class GetterTsDsl extends TsDsl<ts.GetAccessorDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n  protected name: string | ts.PropertyName;\n\n  constructor(name: string | ts.PropertyName, fn?: (g: GetterTsDsl) => void) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  $render(): ts.GetAccessorDeclaration {\n    return ts.factory.createGetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      this.name,\n      this.$params(),\n      undefined,\n      ts.factory.createBlock(this.$do(), true),\n    );\n  }\n}\n\nexport interface GetterTsDsl\n  extends AbstractMixin,\n    AsyncMixin,\n    DecoratorMixin,\n    DoMixin,\n    DocMixin,\n    ParamMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin,\n    StaticMixin {}\nmixin(\n  GetterTsDsl,\n  AbstractMixin,\n  DecoratorMixin,\n  DoMixin,\n  DocMixin,\n  ParamMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport type { AsyncMixin } from '../mixins/modifiers';\nimport {\n  AbstractMixin,\n  createModifierAccessor,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\n\nexport class SetterTsDsl extends TsDsl<ts.SetAccessorDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n  protected name: string | ts.PropertyName;\n\n  constructor(name: string | ts.PropertyName, fn?: (s: SetterTsDsl) => void) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  $render(): ts.SetAccessorDeclaration {\n    return ts.factory.createSetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers.list()],\n      this.name,\n      this.$params(),\n      ts.factory.createBlock(this.$do(), true),\n    );\n  }\n}\n\nexport interface SetterTsDsl\n  extends AbstractMixin,\n    AsyncMixin,\n    DecoratorMixin,\n    DoMixin,\n    DocMixin,\n    ParamMixin,\n    PrivateMixin,\n    ProtectedMixin,\n    PublicMixin,\n    StaticMixin {}\nmixin(\n  SetterTsDsl,\n  AbstractMixin,\n  DecoratorMixin,\n  DoMixin,\n  DocMixin,\n  ParamMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n);\n","export class LayoutMixin {\n  protected static readonly DEFAULT_THRESHOLD = 3;\n  protected layout: boolean | number | undefined;\n\n  /** Sets automatic line output with optional threshold (default: 3). */\n  auto(threshold: number = LayoutMixin.DEFAULT_THRESHOLD): this {\n    this.layout = threshold;\n    return this;\n  }\n\n  /** Sets single line output. */\n  inline(): this {\n    this.layout = false;\n    return this;\n  }\n\n  /** Sets multi line output. */\n  pretty(): this {\n    this.layout = true;\n    return this;\n  }\n\n  /** Computes whether output should be multiline based on layout setting and element count. */\n  protected $multiline(count: number): boolean {\n    if (this.layout === undefined) {\n      this.layout = LayoutMixin.DEFAULT_THRESHOLD;\n    }\n    return typeof this.layout === 'number' ? count >= this.layout : this.layout;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { LayoutMixin } from '../mixins/layout';\nimport { LiteralTsDsl } from './literal';\n\nexport class ArrayTsDsl extends TsDsl<ts.ArrayLiteralExpression> {\n  protected _elements: Array<\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'element' }\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'spread' }\n  > = [];\n\n  constructor(\n    ...exprs: Array<string | number | boolean | MaybeTsDsl<ts.Expression>>\n  ) {\n    super();\n    this.elements(...exprs);\n  }\n\n  /** Adds a single array element. */\n  element(expr: string | number | boolean | MaybeTsDsl<ts.Expression>): this {\n    const node =\n      typeof expr === 'string' ||\n      typeof expr === 'number' ||\n      typeof expr === 'boolean'\n        ? new LiteralTsDsl(expr)\n        : expr;\n    this._elements.push({ expr: node, kind: 'element' });\n    return this;\n  }\n\n  /** Adds multiple array elements. */\n  elements(\n    ...exprs: ReadonlyArray<\n      string | number | boolean | MaybeTsDsl<ts.Expression>\n    >\n  ): this {\n    for (const expr of exprs) this.element(expr);\n    return this;\n  }\n\n  /** Adds a spread element (`...expr`). */\n  spread(expr: MaybeTsDsl<ts.Expression>): this {\n    this._elements.push({ expr, kind: 'spread' });\n    return this;\n  }\n\n  $render(): ts.ArrayLiteralExpression {\n    const elements = this._elements.map((item) => {\n      const node = this.$node(item.expr);\n      return item.kind === 'spread'\n        ? ts.factory.createSpreadElement(node)\n        : node;\n    });\n\n    return ts.factory.createArrayLiteralExpression(\n      elements,\n      this.$multiline(this._elements.length),\n    );\n  }\n}\n\nexport interface ArrayTsDsl extends AsMixin, LayoutMixin {}\nmixin(ArrayTsDsl, AsMixin, LayoutMixin);\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { AttrTsDsl } from '../expr/attr';\nimport type { AwaitTsDsl } from '../expr/await';\nimport type { CallTsDsl } from '../expr/call';\nimport type { ReturnTsDsl } from '../stmt/return';\n\ntype AttrFactory = (\n  expr: string | MaybeTsDsl<ts.Expression>,\n  name: string | ts.MemberName | number,\n) => AttrTsDsl;\nlet attrFactory: AttrFactory | undefined;\n/** Registers the Attr DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessAttrFactory(factory: AttrFactory): void {\n  attrFactory = factory;\n}\n\ntype AwaitFactory = (expr: string | MaybeTsDsl<ts.Expression>) => AwaitTsDsl;\nlet awaitFactory: AwaitFactory | undefined;\n/** Registers the Await DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessAwaitFactory(factory: AwaitFactory): void {\n  awaitFactory = factory;\n}\n\ntype CallFactory = (\n  expr: string | MaybeTsDsl<ts.Expression>,\n  args: ReadonlyArray<string | MaybeTsDsl<ts.Expression> | undefined>,\n) => CallTsDsl;\nlet callFactory: CallFactory | undefined;\n/** Registers the Call DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessCallFactory(factory: CallFactory): void {\n  callFactory = factory;\n}\n\ntype ReturnFactory = (expr: string | MaybeTsDsl<ts.Expression>) => ReturnTsDsl;\nlet returnFactory: ReturnFactory | undefined;\n/** Registers the Return DSL factory after its module has finished evaluating. */\nexport function registerLazyAccessReturnFactory(factory: ReturnFactory): void {\n  returnFactory = factory;\n}\n\nexport class ExprMixin {\n  /** Accesses a property on the current expression (e.g. `this.foo`). */\n  attr(\n    this: string | MaybeTsDsl<ts.Expression>,\n    name: string | ts.MemberName | number,\n  ): AttrTsDsl {\n    return attrFactory!(this, name);\n  }\n\n  /** Awaits the current expression (e.g. `await expr`). */\n  await(this: string | MaybeTsDsl<ts.Expression>): AwaitTsDsl {\n    return awaitFactory!(this);\n  }\n\n  /** Calls the current expression (e.g. `fn(arg1, arg2)`). */\n  call(\n    this: string | MaybeTsDsl<ts.Expression>,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression> | undefined>\n  ): CallTsDsl {\n    return callFactory!(this, args);\n  }\n\n  /** Produces a `return` statement returning the current expression. */\n  return(this: string | MaybeTsDsl<ts.Expression>): ReturnTsDsl {\n    return returnFactory!(this);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin, registerLazyAccessAsFactory } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\n\nexport class AsTsDsl extends TsDsl<ts.AsExpression> {\n  protected expr: string | MaybeTsDsl<ts.Expression>;\n  protected type: string | TypeTsDsl;\n\n  constructor(\n    expr: string | MaybeTsDsl<ts.Expression>,\n    type: string | TypeTsDsl,\n  ) {\n    super();\n    this.expr = expr;\n    this.type = type;\n  }\n\n  $render() {\n    return ts.factory.createAsExpression(\n      this.$node(this.expr),\n      this.$type(this.type),\n    );\n  }\n}\n\nexport interface AsTsDsl extends AsMixin, ExprMixin {}\nmixin(AsTsDsl, AsMixin, ExprMixin);\n\nregisterLazyAccessAsFactory((...args) => new AsTsDsl(...args));\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\n\ntype Expr = string | MaybeTsDsl<ts.Expression>;\ntype Op = Operator | ts.BinaryOperator;\ntype Operator =\n  | '!='\n  | '!=='\n  | '&&'\n  | '*'\n  | '+'\n  | '-'\n  | '/'\n  | '<'\n  | '<='\n  | '='\n  | '=='\n  | '==='\n  | '>'\n  | '>='\n  | '??'\n  | '||';\n\nexport class BinaryTsDsl extends TsDsl<ts.BinaryExpression> {\n  protected _base: Expr;\n  protected _expr?: Expr;\n  protected _op?: Op;\n\n  constructor(base: Expr, op?: Op, expr?: Expr) {\n    super();\n    this._base = base;\n    this._op = op;\n    this._expr = expr;\n  }\n\n  /** Logical AND ‚Äî `this && expr` */\n  and(expr: Expr): this {\n    return this.opAndExpr('&&', expr);\n  }\n\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(expr: Expr): this {\n    return this.opAndExpr('=', expr);\n  }\n\n  /** Nullish coalescing ‚Äî `this ?? expr` */\n  coalesce(expr: Expr): this {\n    return this.opAndExpr('??', expr);\n  }\n\n  /** Division ‚Äî `this / expr` */\n  div(expr: Expr): this {\n    return this.opAndExpr('/', expr);\n  }\n\n  /** Strict equality ‚Äî `this === expr` */\n  eq(expr: Expr): this {\n    return this.opAndExpr('===', expr);\n  }\n\n  /** Greater than ‚Äî `this > expr` */\n  gt(expr: Expr): this {\n    return this.opAndExpr('>', expr);\n  }\n\n  /** Greater than or equal ‚Äî `this >= expr` */\n  gte(expr: Expr): this {\n    return this.opAndExpr('>=', expr);\n  }\n\n  /** Loose equality ‚Äî `this == expr` */\n  looseEq(expr: Expr): this {\n    return this.opAndExpr('==', expr);\n  }\n\n  /** Loose inequality ‚Äî `this != expr` */\n  looseNeq(expr: Expr): this {\n    return this.opAndExpr('!=', expr);\n  }\n\n  /** Less than ‚Äî `this < expr` */\n  lt(expr: Expr): this {\n    return this.opAndExpr('<', expr);\n  }\n\n  /** Less than or equal ‚Äî `this <= expr` */\n  lte(expr: Expr): this {\n    return this.opAndExpr('<=', expr);\n  }\n\n  /** Subtraction ‚Äî `this - expr` */\n  minus(expr: Expr): this {\n    return this.opAndExpr('-', expr);\n  }\n\n  /** Strict inequality ‚Äî `this !== expr` */\n  neq(expr: Expr): this {\n    return this.opAndExpr('!==', expr);\n  }\n\n  /** Logical OR ‚Äî `this || expr` */\n  or(expr: Expr): this {\n    return this.opAndExpr('||', expr);\n  }\n\n  /** Addition ‚Äî `this + expr` */\n  plus(expr: Expr): this {\n    return this.opAndExpr('+', expr);\n  }\n\n  /** Multiplication ‚Äî `this * expr` */\n  times(expr: Expr): this {\n    return this.opAndExpr('*', expr);\n  }\n\n  $render(): ts.BinaryExpression {\n    if (!this._op) {\n      throw new Error('BinaryTsDsl: missing operator');\n    }\n    if (this._expr === undefined) {\n      throw new Error('BinaryTsDsl: missing right-hand expression');\n    }\n    const base = this.$node(this._base);\n    const expr = this.$node(this._expr);\n    const operator =\n      typeof this._op === 'string' ? this.opToToken(this._op) : this._op;\n    return ts.factory.createBinaryExpression(base, operator, expr);\n  }\n\n  /** Sets the binary operator and right-hand operand for this expression. */\n  private opAndExpr(op: Op, expr: Expr): this {\n    this._expr = expr;\n    this._op = op;\n    return this;\n  }\n\n  private opToToken(op: Operator): ts.BinaryOperator | ts.BinaryOperatorToken {\n    const tokenMap: Record<Operator, ts.BinaryOperator> = {\n      '!=': ts.SyntaxKind.ExclamationEqualsToken,\n      '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n      '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n      '*': ts.SyntaxKind.AsteriskToken,\n      '+': ts.SyntaxKind.PlusToken,\n      '-': ts.SyntaxKind.MinusToken,\n      '/': ts.SyntaxKind.SlashToken,\n      '<': ts.SyntaxKind.LessThanToken,\n      '<=': ts.SyntaxKind.LessThanEqualsToken,\n      '=': ts.SyntaxKind.EqualsToken,\n      '==': ts.SyntaxKind.EqualsEqualsToken,\n      '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n      '>': ts.SyntaxKind.GreaterThanToken,\n      '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n      '??': ts.SyntaxKind.QuestionQuestionToken,\n      '||': ts.SyntaxKind.BarBarToken,\n    };\n    const token = tokenMap[op];\n    if (!token) {\n      throw new Error(`Unsupported operator: ${op}`);\n    }\n    return token;\n  }\n}\n\nexport interface BinaryTsDsl extends AsMixin, ExprMixin {}\nmixin(BinaryTsDsl, AsMixin, ExprMixin);\n","import type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { BinaryTsDsl } from '../expr/binary';\n\ntype This = string | MaybeTsDsl<ts.Expression>;\ntype Expr = string | MaybeTsDsl<ts.Expression>;\n\nexport class OperatorMixin {\n  /** Logical AND ‚Äî `this && expr` */\n  and(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).and(expr);\n  }\n\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this, '=', expr);\n  }\n\n  /** Nullish coalescing ‚Äî `this ?? expr` */\n  coalesce(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).coalesce(expr);\n  }\n\n  /** Division ‚Äî `this / expr` */\n  div(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).div(expr);\n  }\n\n  /** Strict equality ‚Äî `this === expr` */\n  eq(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).eq(expr);\n  }\n\n  /** Greater than ‚Äî `this > expr` */\n  gt(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).gt(expr);\n  }\n\n  /** Greater than or equal ‚Äî `this >= expr` */\n  gte(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).gte(expr);\n  }\n\n  /** Loose equality ‚Äî `this == expr` */\n  looseEq(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).looseEq(expr);\n  }\n\n  /** Loose inequality ‚Äî `this != expr` */\n  looseNeq(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).looseNeq(expr);\n  }\n\n  /** Less than ‚Äî `this < expr` */\n  lt(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).lt(expr);\n  }\n\n  /** Less than or equal ‚Äî `this <= expr` */\n  lte(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).lte(expr);\n  }\n\n  /** Subtraction ‚Äî `this - expr` */\n  minus(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).minus(expr);\n  }\n\n  /** Strict inequality ‚Äî `this !== expr` */\n  neq(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).neq(expr);\n  }\n\n  /** Logical OR ‚Äî `this || expr` */\n  or(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).or(expr);\n  }\n\n  /** Addition ‚Äî `this + expr` */\n  plus(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).plus(expr);\n  }\n\n  /** Multiplication ‚Äî `this * expr` */\n  times(this: This, expr: Expr): BinaryTsDsl {\n    return new BinaryTsDsl(this).times(expr);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { validTypescriptIdentifierRegExp } from '~/utils/regexp';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin, registerLazyAccessAttrFactory } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { LiteralTsDsl } from './literal';\n\nexport class AttrTsDsl extends TsDsl<\n  ts.PropertyAccessExpression | ts.ElementAccessExpression\n> {\n  protected left: string | MaybeTsDsl<ts.Expression>;\n  protected right: string | ts.MemberName | number;\n\n  constructor(\n    left: string | MaybeTsDsl<ts.Expression>,\n    right: string | ts.MemberName | number,\n  ) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n\n  $render(): ts.PropertyAccessExpression | ts.ElementAccessExpression {\n    const leftNode = this.$node(this.left);\n    validTypescriptIdentifierRegExp.lastIndex = 0;\n    if (\n      typeof this.right === 'number' ||\n      (typeof this.right === 'string' &&\n        !validTypescriptIdentifierRegExp.test(this.right))\n    ) {\n      if (this._optional) {\n        return ts.factory.createElementAccessChain(\n          leftNode,\n          this.$node(new TokenTsDsl().questionDot()),\n          this.$node(new LiteralTsDsl(this.right)),\n        );\n      }\n      return ts.factory.createElementAccessExpression(\n        leftNode,\n        this.$node(new LiteralTsDsl(this.right)),\n      );\n    }\n    if (this._optional) {\n      return ts.factory.createPropertyAccessChain(\n        leftNode,\n        this.$node(new TokenTsDsl().questionDot()),\n        this.$maybeId(this.right),\n      );\n    }\n    return ts.factory.createPropertyAccessExpression(\n      leftNode,\n      this.$maybeId(this.right),\n    );\n  }\n}\n\nexport interface AttrTsDsl\n  extends AsMixin,\n    ExprMixin,\n    OperatorMixin,\n    OptionalMixin {}\nmixin(AttrTsDsl, AsMixin, ExprMixin, OperatorMixin, OptionalMixin);\n\nregisterLazyAccessAttrFactory((...args) => new AttrTsDsl(...args));\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { ExprMixin, registerLazyAccessAwaitFactory } from '../mixins/expr';\n\nexport class AwaitTsDsl extends TsDsl<ts.AwaitExpression> {\n  protected _awaitExpr: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(expr: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    this._awaitExpr = expr;\n  }\n\n  $render(): ts.AwaitExpression {\n    return ts.factory.createAwaitExpression(this.$node(this._awaitExpr));\n  }\n}\n\nexport interface AwaitTsDsl extends ExprMixin {}\nmixin(AwaitTsDsl, ExprMixin);\n\nregisterLazyAccessAwaitFactory((...args) => new AwaitTsDsl(...args));\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { ArgsMixin } from '../mixins/args';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin, registerLazyAccessCallFactory } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\n\nexport class CallTsDsl extends TsDsl<ts.CallExpression> {\n  protected _callee: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(\n    callee: string | MaybeTsDsl<ts.Expression>,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression> | undefined>\n  ) {\n    super();\n    this._callee = callee;\n    this.args(\n      ...args.filter((a): a is NonNullable<typeof a> => a !== undefined),\n    );\n  }\n\n  $render(): ts.CallExpression {\n    return ts.factory.createCallExpression(\n      this.$node(this._callee),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nexport interface CallTsDsl\n  extends ArgsMixin,\n    AsMixin,\n    ExprMixin,\n    TypeArgsMixin {}\nmixin(CallTsDsl, ArgsMixin, AsMixin, ExprMixin, TypeArgsMixin);\n\nregisterLazyAccessCallFactory((expr, args) => new CallTsDsl(expr, ...args));\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\nexport class ExprTsDsl extends TsDsl<ts.Expression> {\n  protected _exprInput: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(id: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    this._exprInput = id;\n  }\n\n  $render(): ts.Expression {\n    return this.$node(this._exprInput);\n  }\n}\n\nexport interface ExprTsDsl\n  extends AsMixin,\n    ExprMixin,\n    OperatorMixin,\n    TypeExprMixin {}\nmixin(ExprTsDsl, AsMixin, ExprMixin, OperatorMixin, TypeExprMixin);\n","import ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class HintTsDsl extends TsDsl<ts.Node> {\n  protected _lines: Array<string> = [];\n\n  constructor(lines?: MaybeArray<string>, fn?: (d: HintTsDsl) => void) {\n    super();\n    if (lines) {\n      if (typeof lines === 'string') {\n        this.add(lines);\n      } else {\n        this.add(...lines);\n      }\n    }\n    fn?.(this);\n  }\n\n  add(...lines: ReadonlyArray<string>): this {\n    this._lines.push(...lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.filter((line) => Boolean(line) || line === '');\n    if (!lines.length) return node;\n\n    for (const line of lines) {\n      ts.addSyntheticLeadingComment(\n        node,\n        ts.SyntaxKind.SingleLineCommentTrivia,\n        ` ${line}`,\n        false,\n      );\n    }\n\n    return node;\n  }\n\n  $render(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { ITsDsl, MaybeArray } from '../base';\nimport { HintTsDsl } from '../layout/hint';\n\nexport function HintMixin<\n  TBase extends new (...args: ReadonlyArray<any>) => ITsDsl,\n>(Base: TBase) {\n  const $renderBase = Base.prototype.$render;\n\n  class Mixin extends Base {\n    _hint?: HintTsDsl;\n\n    hint(lines?: MaybeArray<string>, fn?: (h: HintTsDsl) => void): this {\n      this._hint = new HintTsDsl(lines, fn);\n      return this;\n    }\n\n    override $render(...args: Parameters<ITsDsl['$render']>) {\n      const node = $renderBase.apply(this, args);\n      return this._hint ? this._hint.apply(node) : node;\n    }\n  }\n\n  // @ts-expect-error\n  Mixin.prototype.$render.mixin = true;\n\n  return Mixin;\n}\n\nexport type HintMixin = InstanceType<ReturnType<typeof HintMixin>>;\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { GetterTsDsl } from '../decl/getter';\nimport { SetterTsDsl } from '../decl/setter';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { safePropName } from '../utils/prop';\nimport { IdTsDsl } from './id';\n\ntype Expr = string | MaybeTsDsl<ts.Expression>;\ntype Stmt = string | MaybeTsDsl<ts.Statement>;\ntype Kind = 'computed' | 'getter' | 'prop' | 'setter' | 'spread';\n\ntype Meta =\n  | { kind: 'computed'; name: string }\n  | { kind: 'getter'; name: string }\n  | { kind: 'prop'; name: string }\n  | { kind: 'setter'; name: string }\n  | { kind: 'spread'; name?: undefined };\n\nexport class ObjectPropTsDsl extends TsDsl<ts.ObjectLiteralElementLike> {\n  protected _value?: Expr | Stmt;\n  protected meta: Meta;\n\n  constructor(meta: Meta) {\n    super();\n    this.meta = meta;\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  value(value: Expr | Stmt | ((p: ObjectPropTsDsl) => void)) {\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this._value = value;\n    }\n    return this;\n  }\n\n  $render(): ts.ObjectLiteralElementLike {\n    this.$validate();\n    const node = this.$node(this._value);\n    if (this.meta.kind === 'spread') {\n      if (ts.isStatement(node)) {\n        throw new Error(\n          'Invalid spread: object spread must be an expression, not a statement.',\n        );\n      }\n      return ts.factory.createSpreadAssignment(node);\n    }\n    if (this.meta.kind === 'getter') {\n      const getter = new GetterTsDsl(safePropName(this.meta.name)).do(node);\n      return this.$node(getter);\n    }\n    if (this.meta.kind === 'setter') {\n      const setter = new SetterTsDsl(safePropName(this.meta.name)).do(node);\n      return this.$node(setter);\n    }\n    if (ts.isIdentifier(node) && node.text === this.meta.name) {\n      return ts.factory.createShorthandPropertyAssignment(this.meta.name);\n    }\n    if (ts.isStatement(node)) {\n      throw new Error(\n        'Invalid property: object property value must be an expression, not a statement.',\n      );\n    }\n    return ts.factory.createPropertyAssignment(\n      this.meta.kind === 'computed'\n        ? ts.factory.createComputedPropertyName(\n            this.$node(new IdTsDsl(this.meta.name)),\n          )\n        : safePropName(this.meta.name),\n      node,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _value: Expr | Stmt;\n    kind: Kind;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(\n      `Object property${this.meta.name ? ` \"${this.meta.name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._value) missing.push('.value()');\n    return missing;\n  }\n}\n\nexport interface ObjectPropTsDsl extends DocMixin {}\nmixin(ObjectPropTsDsl, DocMixin);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { HintMixin } from '../mixins/hint';\nimport { LayoutMixin } from '../mixins/layout';\nimport { ObjectPropTsDsl } from './prop';\n\ntype Expr = string | MaybeTsDsl<ts.Expression>;\ntype Stmt = string | MaybeTsDsl<ts.Statement>;\ntype ExprFn = Expr | ((p: ObjectPropTsDsl) => void);\ntype StmtFn = Stmt | ((p: ObjectPropTsDsl) => void);\n\nexport class ObjectTsDsl extends TsDsl<ts.ObjectLiteralExpression> {\n  protected _props: Array<ObjectPropTsDsl> = [];\n\n  constructor(...props: Array<ObjectPropTsDsl>) {\n    super();\n    this.props(...props);\n  }\n\n  /** Adds a computed property (e.g. `{ [expr]: value }`). */\n  computed(name: string, expr: ExprFn): this {\n    this._props.push(\n      new ObjectPropTsDsl({ kind: 'computed', name }).value(expr),\n    );\n    return this;\n  }\n\n  /** Adds a getter property (e.g. `{ get foo() { ... } }`). */\n  getter(name: string, stmt: StmtFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'getter', name }).value(stmt));\n    return this;\n  }\n\n  /** Returns true if object has at least one property or spread. */\n  hasProps(): boolean {\n    return this._props.length > 0;\n  }\n\n  /** Returns true if object has no properties or spreads. */\n  get isEmpty(): boolean {\n    return this._props.length === 0;\n  }\n\n  /** Adds a property assignment. */\n  prop(name: string, expr: ExprFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'prop', name }).value(expr));\n    return this;\n  }\n\n  /** Adds multiple properties. */\n  props(...props: ReadonlyArray<ObjectPropTsDsl>): this {\n    this._props.push(...props);\n    return this;\n  }\n\n  /** Adds a setter property (e.g. `{ set foo(v) { ... } }`). */\n  setter(name: string, stmt: StmtFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'setter', name }).value(stmt));\n    return this;\n  }\n\n  /** Adds a spread property (e.g. `{ ...options }`). */\n  spread(expr: ExprFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'spread' }).value(expr));\n    return this;\n  }\n\n  /** Builds and returns the object literal expression. */\n  $render(): ts.ObjectLiteralExpression {\n    return ts.factory.createObjectLiteralExpression(\n      this.$node(this._props),\n      this.$multiline(this._props.length),\n    );\n  }\n}\n\nexport interface ObjectTsDsl\n  extends AsMixin,\n    ExprMixin,\n    HintMixin,\n    LayoutMixin {}\nmixin(ObjectTsDsl, AsMixin, ExprMixin, HintMixin, LayoutMixin);\n","import type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { ArrayTsDsl } from './array';\nimport { LiteralTsDsl } from './literal';\nimport { ObjectTsDsl } from './object';\n\nexport const fromValue = (\n  input: unknown,\n  options?: {\n    layout?: 'pretty';\n  },\n): TsDsl<ts.Expression> => {\n  if (input instanceof TsDsl) {\n    return input;\n  }\n\n  if (input === null) {\n    return new LiteralTsDsl(input);\n  }\n\n  if (\n    typeof input === 'number' ||\n    typeof input === 'boolean' ||\n    typeof input === 'string'\n  ) {\n    return new LiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new ArrayTsDsl(...input.map((v) => fromValue(v, options)));\n    if (options?.layout === 'pretty') arr.pretty();\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new ObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const expr = fromValue(val, options);\n      obj.prop(key, expr);\n    }\n    if (options?.layout === 'pretty') obj.pretty();\n    return obj;\n  }\n\n  throw new Error(`$.fromValue(): Unsupported input type ${String(input)}`);\n};\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { ArgsMixin } from '../mixins/args';\nimport { ExprMixin } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\n\nexport class NewTsDsl extends TsDsl<ts.NewExpression> {\n  protected classExpr: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(\n    classExpr: string | MaybeTsDsl<ts.Expression>,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ) {\n    super();\n    this.classExpr = classExpr;\n    this.args(...args);\n  }\n\n  /** Builds the `NewExpression` node. */\n  $render(): ts.NewExpression {\n    return ts.factory.createNewExpression(\n      this.$node(this.classExpr),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nexport interface NewTsDsl extends ArgsMixin, ExprMixin, TypeArgsMixin {}\nmixin(NewTsDsl, ArgsMixin, ExprMixin, TypeArgsMixin);\n","import ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\ntype RegexFlag = 'g' | 'i' | 'm' | 's' | 'u' | 'y';\n\ntype RegexFlags<Avail extends string = RegexFlag> =\n  | ''\n  | {\n      [K in Avail]: `${K}${RegexFlags<Exclude<Avail, K>>}`;\n    }[Avail];\n\nexport class RegExpTsDsl extends TsDsl<ts.RegularExpressionLiteral> {\n  protected pattern: string;\n  protected flags?: RegexFlags;\n\n  constructor(pattern: string, flags?: RegexFlags) {\n    super();\n    this.pattern = pattern;\n    this.flags = flags;\n  }\n\n  /** Emits a RegularExpressionLiteral node. */\n  $render(): ts.RegularExpressionLiteral {\n    const patternContent =\n      this.pattern.startsWith('/') && this.pattern.endsWith('/')\n        ? this.pattern.slice(1, -1)\n        : this.pattern;\n    const escapedPattern = patternContent.replace(/(?<!\\\\)\\//g, '\\\\/');\n    const literal = `/${escapedPattern}/${this.flags ?? ''}`;\n    return ts.factory.createRegularExpressionLiteral(literal);\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport class TemplateTsDsl extends TsDsl<\n  ts.TemplateExpression | ts.NoSubstitutionTemplateLiteral\n> {\n  protected parts: Array<string | MaybeTsDsl<ts.Expression>> = [];\n\n  constructor(value?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  add(value: string | MaybeTsDsl<ts.Expression>): this {\n    this.parts.push(value);\n    return this;\n  }\n\n  $render(): ts.TemplateExpression | ts.NoSubstitutionTemplateLiteral {\n    const parts = this.$node(this.parts);\n\n    const normalized: Array<string | ts.Expression> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (\n          index + 1 < parts.length &&\n          typeof parts[index + 1] === 'string'\n        ) {\n          merged += parts[index + 1];\n          index++;\n        }\n        normalized.push(merged);\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createNoSubstitutionTemplateLiteral(normalized[0]);\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateExpression(\n        ts.factory.createTemplateHead(normalized[0]),\n        [\n          ts.factory.createTemplateSpan(\n            normalized[1]!,\n            ts.factory.createTemplateTail(''),\n          ),\n        ],\n      );\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateSpan> = [];\n\n    while (normalized.length) {\n      const expr = normalized.shift() as ts.Expression;\n      const next =\n        typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateSpan(\n          expr,\n          isLast\n            ? ts.factory.createTemplateTail(next)\n            : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateExpression(head, spans);\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport class TernaryTsDsl extends TsDsl<ts.ConditionalExpression> {\n  protected _condition?: string | MaybeTsDsl<ts.Expression>;\n  protected _then?: string | MaybeTsDsl<ts.Expression>;\n  protected _else?: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(condition?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  condition(condition: string | MaybeTsDsl<ts.Expression>) {\n    this._condition = condition;\n    return this;\n  }\n\n  do(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._then = expr;\n    return this;\n  }\n\n  otherwise(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._else = expr;\n    return this;\n  }\n\n  $render(): ts.ConditionalExpression {\n    if (!this._condition) throw new Error('Missing condition in ternary');\n    if (!this._then) throw new Error('Missing then expression in ternary');\n    if (!this._else) throw new Error('Missing else expression in ternary');\n\n    return ts.factory.createConditionalExpression(\n      this.$node(this._condition),\n      undefined,\n      this.$node(this._then),\n      undefined,\n      this.$node(this._else),\n    );\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { OperatorMixin } from '../mixins/operator';\nimport { registerLazyAccessTypeOfExprFactory } from '../mixins/type-expr';\n\nexport class TypeOfExprTsDsl extends TsDsl<ts.TypeOfExpression> {\n  protected _expr: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(expr: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    this._expr = expr;\n  }\n\n  $render(): ts.TypeOfExpression {\n    return ts.factory.createTypeOfExpression(this.$node(this._expr));\n  }\n}\n\nexport interface TypeOfExprTsDsl extends OperatorMixin {}\nmixin(TypeOfExprTsDsl, OperatorMixin);\n\nregisterLazyAccessTypeOfExprFactory((...args) => new TypeOfExprTsDsl(...args));\n","import ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class NoteTsDsl extends TsDsl<ts.Node> {\n  protected _lines: Array<string> = [];\n\n  constructor(lines?: MaybeArray<string>, fn?: (d: NoteTsDsl) => void) {\n    super();\n    if (lines) {\n      if (typeof lines === 'string') {\n        this.add(lines);\n      } else {\n        this.add(...lines);\n      }\n    }\n    fn?.(this);\n  }\n\n  add(...lines: ReadonlyArray<string>): this {\n    this._lines.push(...lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.filter((line) => Boolean(line) || line === '');\n    if (!lines.length) return node;\n\n    ts.addSyntheticLeadingComment(\n      node,\n      ts.SyntaxKind.MultiLineCommentTrivia,\n      `\\n${lines.join('\\n')}\\n`,\n      true,\n    );\n\n    return node;\n  }\n\n  $render(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DoMixin } from '../mixins/do';\n\nexport class IfTsDsl extends TsDsl<ts.IfStatement> {\n  protected _condition?: string | MaybeTsDsl<ts.Expression>;\n  protected _else?: ReadonlyArray<MaybeTsDsl<ts.Statement>>;\n\n  constructor(condition?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  condition(condition: string | MaybeTsDsl<ts.Expression>): this {\n    this._condition = condition;\n    return this;\n  }\n\n  otherwise(...statements: ReadonlyArray<MaybeTsDsl<ts.Statement>>): this {\n    this._else = statements;\n    return this;\n  }\n\n  $render(): ts.IfStatement {\n    if (!this._condition) throw new Error('Missing condition in if');\n\n    const thenStmts = this.$do();\n    if (!thenStmts.length) throw new Error('Missing then block in if');\n\n    const condition = this.$node(this._condition);\n    const thenBlock =\n      thenStmts.length === 1\n        ? thenStmts[0]!\n        : ts.factory.createBlock(thenStmts, true);\n    const thenNode = ts.isBlock(thenBlock)\n      ? thenBlock\n      : ts.factory.createBlock([thenBlock], true);\n\n    let elseNode: ts.Statement | undefined;\n    if (this._else) {\n      const elseStmts = this.$node(this._else);\n      const elseBlock =\n        elseStmts.length === 1\n          ? elseStmts[0]!\n          : ts.factory.createBlock(elseStmts, true);\n      elseNode = ts.isBlock(elseBlock)\n        ? elseBlock\n        : ts.factory.createBlock([elseBlock], true);\n    }\n\n    return ts.factory.createIfStatement(condition, thenNode, elseNode);\n  }\n}\n\nexport interface IfTsDsl extends DoMixin {}\nmixin(IfTsDsl, DoMixin);\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { ExprMixin, registerLazyAccessReturnFactory } from '../mixins/expr';\n\nexport class ReturnTsDsl extends TsDsl<ts.ReturnStatement> {\n  protected _returnExpr?: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(expr?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    this._returnExpr = expr;\n  }\n\n  $render(): ts.ReturnStatement {\n    return ts.factory.createReturnStatement(this.$node(this._returnExpr));\n  }\n}\n\nexport interface ReturnTsDsl extends ExprMixin {}\nmixin(ReturnTsDsl, ExprMixin);\n\nregisterLazyAccessReturnFactory((...args) => new ReturnTsDsl(...args));\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nexport class ThrowTsDsl extends TsDsl<ts.ThrowStatement> {\n  protected error: string | MaybeTsDsl<ts.Expression>;\n  protected msg?: string | MaybeTsDsl<ts.Expression>;\n  protected useNew: boolean;\n\n  constructor(error: string | MaybeTsDsl<ts.Expression>, useNew = true) {\n    super();\n    this.error = error;\n    this.useNew = useNew;\n  }\n\n  message(value: string | MaybeTsDsl<ts.Expression>): this {\n    this.msg = value;\n    return this;\n  }\n\n  $render(): ts.ThrowStatement {\n    const errorNode = this.$node(this.error);\n    const messageNode = this.$node(this.msg ? [this.msg] : []).map((expr) =>\n      typeof expr === 'string' ? new LiteralTsDsl(expr).$render() : expr,\n    );\n    if (this.useNew) {\n      return ts.factory.createThrowStatement(\n        ts.factory.createNewExpression(errorNode, undefined, messageNode),\n      );\n    }\n    const args = messageNode.length\n      ? [ts.factory.createCallExpression(errorNode, undefined, messageNode)]\n      : [errorNode];\n    return ts.factory.createThrowStatement(args[0]!);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { HintMixin } from '../mixins/hint';\nimport {\n  createModifierAccessor,\n  DefaultMixin,\n  ExportMixin,\n} from '../mixins/modifiers';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport class VarTsDsl extends TsDsl<ts.VariableStatement> {\n  protected kind: ts.NodeFlags = ts.NodeFlags.None;\n  protected modifiers = createModifierAccessor(this);\n  protected name?: string;\n  protected _type?: TypeTsDsl;\n\n  constructor(name?: string) {\n    super();\n    this.name = name;\n  }\n\n  const(): this {\n    this.kind = ts.NodeFlags.Const;\n    return this;\n  }\n\n  let(): this {\n    this.kind = ts.NodeFlags.Let;\n    return this;\n  }\n\n  /** Sets the variable type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  var(): this {\n    this.kind = ts.NodeFlags.None;\n    return this;\n  }\n\n  $render(): ts.VariableStatement {\n    const name = this.$pattern() ?? this.name;\n    if (!name)\n      throw new Error('Var must have either a name or a destructuring pattern');\n    return ts.factory.createVariableStatement(\n      this.modifiers.list(),\n      ts.factory.createVariableDeclarationList(\n        [\n          ts.factory.createVariableDeclaration(\n            name,\n            undefined,\n            this.$type(this._type),\n            this.$value(),\n          ),\n        ],\n        this.kind,\n      ),\n    );\n  }\n}\n\nexport interface VarTsDsl\n  extends DefaultMixin,\n    DocMixin,\n    ExportMixin,\n    HintMixin,\n    PatternMixin,\n    ValueMixin {}\nmixin(\n  VarTsDsl,\n  DefaultMixin,\n  DocMixin,\n  ExportMixin,\n  HintMixin,\n  PatternMixin,\n  ValueMixin,\n);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { createModifierAccessor, ExportMixin } from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\n\nexport class TypeAliasTsDsl extends TsDsl<ts.TypeAliasDeclaration> {\n  protected value?: MaybeTsDsl<ts.TypeNode>;\n  protected modifiers = createModifierAccessor(this);\n  protected name: string;\n\n  constructor(name: string, fn?: (t: TypeAliasTsDsl) => void) {\n    super();\n    this.name = name;\n    fn?.(this);\n  }\n\n  /** Sets the type expression on the right-hand side of `= ...`. */\n  type(node: MaybeTsDsl<ts.TypeNode>): this {\n    this.value = node;\n    return this;\n  }\n\n  /** Renders a `TypeAliasDeclaration` node. */\n  $render(): ts.TypeAliasDeclaration {\n    if (!this.value)\n      throw new Error(`Type alias '${this.name}' is missing a type definition`);\n    return ts.factory.createTypeAliasDeclaration(\n      this.modifiers.list(),\n      this.name,\n      this.$generics(),\n      this.$type(this.value),\n    );\n  }\n}\n\nexport interface TypeAliasTsDsl\n  extends DocMixin,\n    ExportMixin,\n    TypeParamsMixin {}\nmixin(TypeAliasTsDsl, DocMixin, ExportMixin, TypeParamsMixin);\n","import ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\n\nexport class TypeAndTsDsl extends TypeTsDsl<ts.IntersectionTypeNode> {\n  protected _types: Array<string | ts.TypeNode | TypeTsDsl> = [];\n\n  constructor(...nodes: Array<string | ts.TypeNode | TypeTsDsl>) {\n    super();\n    this.types(...nodes);\n  }\n\n  types(...nodes: Array<string | ts.TypeNode | TypeTsDsl>): this {\n    this._types.push(...nodes);\n    return this;\n  }\n\n  $render(): ts.IntersectionTypeNode {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const n of this._types) {\n      const t = this.$type(n);\n      if (ts.isIntersectionTypeNode(t)) {\n        flat.push(...t.types);\n      } else {\n        flat.push(t);\n      }\n    }\n\n    return ts.factory.createIntersectionTypeNode(flat);\n  }\n}\n","import ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nexport class TypeLiteralTsDsl extends TypeTsDsl<ts.LiteralTypeNode> {\n  protected value: string | number | boolean | null;\n\n  constructor(value: string | number | boolean | null) {\n    super();\n    this.value = value;\n  }\n\n  $render(): ts.LiteralTypeNode {\n    return ts.factory.createLiteralTypeNode(\n      this.$node(new LiteralTsDsl(this.value)),\n    );\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { createModifierAccessor, ReadonlyMixin } from '../mixins/modifiers';\n\ntype Type = string | MaybeTsDsl<ts.TypeNode>;\n\nexport class TypeIdxSigTsDsl extends TypeTsDsl<ts.IndexSignatureDeclaration> {\n  protected modifiers = createModifierAccessor(this);\n  protected _key?: Type;\n  protected _name: string;\n  protected _type?: Type;\n\n  constructor(name: string, fn?: (i: TypeIdxSigTsDsl) => void) {\n    super();\n    this._name = name;\n    fn?.(this);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key type: `[name: T]` */\n  key(type: Type): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Sets the property type. */\n  type(type: Type): this {\n    this._type = type;\n    return this;\n  }\n\n  $render(): ts.IndexSignatureDeclaration {\n    this.$validate();\n    return ts.factory.createIndexSignature(\n      this.modifiers.list(),\n      [\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          this._name,\n          undefined,\n          this.$type(this._key),\n        ),\n      ],\n      this.$type(this._type),\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _key: Type;\n    _name: string;\n    _type: Type;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(\n      `Index signature${this._name ? ` \"${this._name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._name) missing.push('.name()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n\nexport interface TypeIdxSigTsDsl extends DocMixin, ReadonlyMixin {}\nmixin(TypeIdxSigTsDsl, DocMixin, ReadonlyMixin);\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { createModifierAccessor, ReadonlyMixin } from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { safePropName } from '../utils/prop';\n\nexport class TypePropTsDsl extends TypeTsDsl<ts.TypeElement> {\n  protected modifiers = createModifierAccessor(this);\n  protected name: string;\n  protected _type?: string | MaybeTsDsl<ts.TypeNode>;\n\n  constructor(name: string, fn: (p: TypePropTsDsl) => void) {\n    super();\n    this.name = name;\n    fn(this);\n  }\n\n  /** Sets the property type. */\n  type(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._type = type;\n    return this;\n  }\n\n  /** Builds and returns the property signature. */\n  $render(): ts.TypeElement {\n    if (!this._type) {\n      throw new Error(`Type not specified for property '${this.name}'`);\n    }\n    return ts.factory.createPropertySignature(\n      this.modifiers.list(),\n      safePropName(this.name),\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n    );\n  }\n}\n\nexport interface TypePropTsDsl extends DocMixin, OptionalMixin, ReadonlyMixin {}\nmixin(TypePropTsDsl, DocMixin, OptionalMixin, ReadonlyMixin);\n","import ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { TypeIdxSigTsDsl } from './idx-sig';\nimport { TypePropTsDsl } from './prop';\n\nexport class TypeObjectTsDsl extends TypeTsDsl<ts.TypeNode> {\n  protected props: Array<TypePropTsDsl | TypeIdxSigTsDsl> = [];\n\n  /** Returns true if object has at least one property or spread. */\n  hasProps(): boolean {\n    return this.props.length > 0;\n  }\n\n  /** Adds an index signature to the object type. */\n  idxSig(name: string, fn: (i: TypeIdxSigTsDsl) => void): this {\n    const idx = new TypeIdxSigTsDsl(name, fn);\n    this.props.push(idx);\n    return this;\n  }\n\n  /** Returns true if object has no properties or spreads. */\n  get isEmpty(): boolean {\n    return !this.props.length;\n  }\n\n  /** Adds a property signature (returns property builder). */\n  prop(name: string, fn: (p: TypePropTsDsl) => void): this {\n    const prop = new TypePropTsDsl(name, fn);\n    this.props.push(prop);\n    return this;\n  }\n\n  $render(): ts.TypeNode {\n    return ts.factory.createTypeLiteralNode(this.$node(this.props));\n  }\n}\n","import ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\n\nexport class TypeTupleTsDsl extends TypeTsDsl<ts.TupleTypeNode> {\n  protected _elements: Array<string | ts.TypeNode | TypeTsDsl> = [];\n\n  constructor(...nodes: Array<string | ts.TypeNode | TypeTsDsl>) {\n    super();\n    this.elements(...nodes);\n  }\n\n  elements(...types: Array<string | ts.TypeNode | TypeTsDsl>): this {\n    this._elements.push(...types);\n    return this;\n  }\n\n  $render(): ts.TupleTypeNode {\n    return ts.factory.createTupleTypeNode(\n      this._elements.map((t) => this.$type(t)),\n    );\n  }\n}\n","import type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TypeLiteralTsDsl } from './literal';\nimport { TypeObjectTsDsl } from './object';\nimport { TypeTupleTsDsl } from './tuple';\n\nexport const fromValue = (input: unknown): TsDsl<ts.TypeNode> => {\n  if (input instanceof TsDsl) {\n    return input;\n  }\n\n  if (input === null) {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (\n    typeof input === 'number' ||\n    typeof input === 'boolean' ||\n    typeof input === 'string'\n  ) {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new TypeTupleTsDsl(...input.map((v) => fromValue(v)));\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new TypeObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const type = fromValue(val);\n      obj.prop(key, (p) => p.type(type));\n    }\n    return obj;\n  }\n\n  throw new Error(\n    `$.type.fromValue(): Unsupported input type ${String(input)}`,\n  );\n};\n","/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport { DocMixin } from '../mixins/doc';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeExprTsDsl } from './expr';\n\nexport class TypeFuncTsDsl extends TypeTsDsl<ts.FunctionTypeNode> {\n  protected _returns?: TypeTsDsl;\n\n  /** Sets the return type. */\n  returns(type: string | TypeTsDsl): this {\n    this._returns = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  $render(): ts.FunctionTypeNode {\n    if (this._returns === undefined) {\n      throw new Error('Missing return type in function type DSL');\n    }\n    return ts.factory.createFunctionTypeNode(\n      this.$generics(),\n      this.$params(),\n      this.$type(this._returns),\n    );\n  }\n}\n\nexport interface TypeFuncTsDsl extends DocMixin, ParamMixin, TypeParamsMixin {}\nmixin(TypeFuncTsDsl, DocMixin, ParamMixin, TypeParamsMixin);\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport {\n  registerLazyAccessTypeIdxFactory,\n  TypeExprMixin,\n} from '../mixins/type-expr';\n\nexport class TypeIdxTsDsl extends TypeTsDsl<ts.IndexedAccessTypeNode> {\n  protected _base: string | MaybeTsDsl<ts.TypeNode>;\n  protected _index: string | MaybeTsDsl<ts.TypeNode> | number;\n\n  constructor(\n    base: string | MaybeTsDsl<ts.TypeNode>,\n    index: string | MaybeTsDsl<ts.TypeNode> | number,\n  ) {\n    super();\n    this._base = base;\n    this._index = index;\n  }\n\n  base(base: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._base = base;\n    return this;\n  }\n\n  index(index: string | MaybeTsDsl<ts.TypeNode> | number): this {\n    this._index = index;\n    return this;\n  }\n\n  $render(): ts.IndexedAccessTypeNode {\n    return ts.factory.createIndexedAccessTypeNode(\n      this.$type(this._base),\n      this.$type(this._index),\n    );\n  }\n}\n\nexport interface TypeIdxTsDsl extends TypeExprMixin {}\nmixin(TypeIdxTsDsl, TypeExprMixin);\n\nregisterLazyAccessTypeIdxFactory((...args) => new TypeIdxTsDsl(...args));\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { TokenTsDsl } from '../token';\n\nexport class TypeMappedTsDsl extends TypeTsDsl<ts.MappedTypeNode> {\n  protected questionToken?: TokenTsDsl<\n    | ts.SyntaxKind.QuestionToken\n    | ts.SyntaxKind.PlusToken\n    | ts.SyntaxKind.MinusToken\n  >;\n  protected readonlyToken?: TokenTsDsl<\n    | ts.SyntaxKind.ReadonlyKeyword\n    | ts.SyntaxKind.MinusToken\n    | ts.SyntaxKind.PlusToken\n  >;\n  protected _key?: string | MaybeTsDsl<ts.TypeNode>;\n  protected _name?: string;\n  protected _type?: string | MaybeTsDsl<ts.TypeNode>;\n\n  constructor(name?: string) {\n    super();\n    this.name(name);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key constraint: `[K in Constraint]` */\n  key(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Removes `readonly` from the mapped members (`[K in X]-readonly`). */\n  mutable(): this {\n    this.readonlyToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Sets the parameter name: `{ [Name in keyof T]: U }` */\n  name(name?: string): this {\n    this._name = name;\n    return this;\n  }\n\n  /** Makes `[K in X]?:` optional. */\n  optional(): this {\n    this.questionToken = new TokenTsDsl().optional();\n    return this;\n  }\n\n  /** Makes `[K in X]` readonly */\n  readonly(): this {\n    this.readonlyToken = new TokenTsDsl().readonly();\n    return this;\n  }\n\n  /** Removes `?` from the mapped members (`[K in X]-?:`). */\n  required(): this {\n    this.questionToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Sets the mapped value type: `[K in X]: ValueType` */\n  type(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._type = type;\n    return this;\n  }\n\n  $render(): ts.MappedTypeNode {\n    this.$validate();\n    return ts.factory.createMappedTypeNode(\n      this.$node(this.readonlyToken),\n      ts.factory.createTypeParameterDeclaration(\n        undefined,\n        this._name,\n        this.$type(this._key),\n        undefined,\n      ),\n      undefined,\n      this.$node(this.questionToken),\n      this.$type(this._type),\n      undefined,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _key: string | MaybeTsDsl<ts.TypeNode>;\n    _name: string;\n    _type: string | MaybeTsDsl<ts.TypeNode>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(\n      `Mapped type${this._name ? ` \"${this._name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._name) missing.push('.name()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { registerLazyAccessTypeOperatorFactory } from '../mixins/type-expr';\n\ntype Op =\n  | ts.SyntaxKind.KeyOfKeyword\n  | ts.SyntaxKind.ReadonlyKeyword\n  | ts.SyntaxKind.UniqueKeyword;\ntype Type = string | MaybeTsDsl<ts.TypeNode>;\n\n/**\n * Builds a TypeScript `TypeOperatorNode`, such as:\n *\n * - `keyof T`\n * - `readonly U`\n * - `unique V`\n *\n * This DSL provides both a generic `.operator()` API and convenient\n * shorthand methods (`.keyof()`, `.readonly()`, `.unique()`).\n *\n * The node will throw during render if required fields are missing.\n */\nexport class TypeOperatorTsDsl extends TypeTsDsl<ts.TypeOperatorNode> {\n  protected _op?: Op;\n  protected _type?: Type;\n\n  /** Shorthand: builds `keyof T`. */\n  keyof(type: Type): this {\n    this.operator(ts.SyntaxKind.KeyOfKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the operator explicitly. */\n  operator(op: Op): this {\n    this._op = op;\n    return this;\n  }\n\n  /** Shorthand: builds `readonly T`. */\n  readonly(type: Type): this {\n    this.operator(ts.SyntaxKind.ReadonlyKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the target type of the operator. */\n  type(type: Type): this {\n    this._type = type;\n    return this;\n  }\n\n  /** Shorthand: builds `unique T`. */\n  unique(type: Type): this {\n    this.operator(ts.SyntaxKind.UniqueKeyword);\n    this.type(type);\n    return this;\n  }\n\n  $render(): ts.TypeOperatorNode {\n    this.$validate();\n    return ts.factory.createTypeOperatorNode(this._op, this.$type(this._type));\n  }\n\n  /** Throws if required fields are not set. */\n  $validate(): asserts this is this & {\n    _op: Op;\n    _type: Type;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Type operator missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._op) missing.push('.operator()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n\nregisterLazyAccessTypeOperatorFactory(\n  (...args) => new TypeOperatorTsDsl(...args),\n);\n","import ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\n\nexport class TypeOrTsDsl extends TypeTsDsl<ts.UnionTypeNode> {\n  protected _types: Array<string | ts.TypeNode | TypeTsDsl> = [];\n\n  constructor(...nodes: Array<string | ts.TypeNode | TypeTsDsl>) {\n    super();\n    this.types(...nodes);\n  }\n\n  types(...nodes: Array<string | ts.TypeNode | TypeTsDsl>): this {\n    this._types.push(...nodes);\n    return this;\n  }\n\n  $render(): ts.UnionTypeNode {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const n of this._types) {\n      const t = this.$type(n);\n      if (ts.isUnionTypeNode(t)) {\n        flat.push(...t.types);\n      } else {\n        flat.push(t);\n      }\n    }\n\n    return ts.factory.createUnionTypeNode(flat);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging */\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\nimport { mixin } from '../mixins/apply';\nimport {\n  registerLazyAccessTypeQueryFactory,\n  TypeExprMixin,\n} from '../mixins/type-expr';\n\nexport class TypeQueryTsDsl extends TypeTsDsl<ts.TypeQueryNode> {\n  protected _expr: string | MaybeTsDsl<TypeTsDsl | ts.Expression>;\n\n  constructor(expr: string | MaybeTsDsl<TypeTsDsl | ts.Expression>) {\n    super();\n    this._expr = expr;\n  }\n\n  $render(): ts.TypeQueryNode {\n    const expr = this.$node(this._expr);\n    return ts.factory.createTypeQueryNode(expr as unknown as ts.EntityName);\n  }\n}\n\nexport interface TypeQueryTsDsl extends TypeExprMixin {}\nmixin(TypeQueryTsDsl, TypeExprMixin);\n\nregisterLazyAccessTypeQueryFactory((...args) => new TypeQueryTsDsl(...args));\n","import ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeTsDsl } from '../base';\n\nexport class TypeTemplateTsDsl extends TypeTsDsl<ts.TemplateLiteralTypeNode> {\n  protected parts: Array<string | MaybeTsDsl<ts.TypeNode>> = [];\n\n  constructor(value?: string | MaybeTsDsl<ts.TypeNode>) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  /** Adds a raw string segment or embedded type expression. */\n  add(part: string | MaybeTsDsl<ts.TypeNode>): this {\n    this.parts.push(part);\n    return this;\n  }\n\n  /** Renders a TemplateLiteralTypeNode. */\n  $render(): ts.TemplateLiteralTypeNode {\n    const parts = this.$node(this.parts);\n\n    const normalized: Array<string | ts.TypeNode> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (\n          index + 1 < parts.length &&\n          typeof parts[index + 1] === 'string'\n        ) {\n          merged += parts[index + 1]!;\n          index++;\n        }\n        normalized.push(merged);\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createTemplateLiteralType(\n        ts.factory.createTemplateHead(normalized[0]),\n        [],\n      );\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateLiteralType(\n        ts.factory.createTemplateHead(normalized[0]),\n        [\n          ts.factory.createTemplateLiteralTypeSpan(\n            normalized[1]!,\n            ts.factory.createTemplateTail(''),\n          ),\n        ],\n      );\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateLiteralTypeSpan> = [];\n\n    while (normalized.length) {\n      const type = normalized.shift() as ts.TypeNode;\n      const next =\n        typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateLiteralTypeSpan(\n          type,\n          isLast\n            ? ts.factory.createTemplateTail(next)\n            : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateLiteralType(head, spans);\n  }\n}\n","import { ClassTsDsl } from './decl/class';\nimport { DecoratorTsDsl } from './decl/decorator';\nimport { EnumTsDsl } from './decl/enum';\nimport { FieldTsDsl } from './decl/field';\nimport { FuncTsDsl } from './decl/func';\nimport { GetterTsDsl } from './decl/getter';\nimport { InitTsDsl } from './decl/init';\nimport { EnumMemberTsDsl } from './decl/member';\nimport { MethodTsDsl } from './decl/method';\nimport { ParamTsDsl } from './decl/param';\nimport { PatternTsDsl } from './decl/pattern';\nimport { SetterTsDsl } from './decl/setter';\nimport { ArrayTsDsl } from './expr/array';\nimport { AsTsDsl } from './expr/as';\nimport { AttrTsDsl } from './expr/attr';\nimport { AwaitTsDsl } from './expr/await';\nimport { BinaryTsDsl } from './expr/binary';\nimport { CallTsDsl } from './expr/call';\nimport { ExprTsDsl } from './expr/expr';\nimport { fromValue as exprValue } from './expr/fromValue';\nimport { IdTsDsl } from './expr/id';\nimport { LiteralTsDsl } from './expr/literal';\nimport { NewTsDsl } from './expr/new';\nimport { ObjectTsDsl } from './expr/object';\nimport { PrefixTsDsl } from './expr/prefix';\nimport { ObjectPropTsDsl } from './expr/prop';\nimport { RegExpTsDsl } from './expr/regexp';\nimport { TemplateTsDsl } from './expr/template';\nimport { TernaryTsDsl } from './expr/ternary';\nimport { TypeOfExprTsDsl } from './expr/typeof';\nimport { DocTsDsl } from './layout/doc';\nimport { HintTsDsl } from './layout/hint';\nimport { NewlineTsDsl } from './layout/newline';\nimport { NoteTsDsl } from './layout/note';\nimport { IfTsDsl } from './stmt/if';\nimport { ReturnTsDsl } from './stmt/return';\nimport { StmtTsDsl } from './stmt/stmt';\nimport { ThrowTsDsl } from './stmt/throw';\nimport { VarTsDsl } from './stmt/var';\nimport { TokenTsDsl } from './token';\nimport { TypeAliasTsDsl } from './type/alias';\nimport { TypeAndTsDsl } from './type/and';\nimport { TypeAttrTsDsl } from './type/attr';\nimport { TypeExprTsDsl } from './type/expr';\nimport { fromValue as typeValue } from './type/fromValue';\nimport { TypeFuncTsDsl } from './type/func';\nimport { TypeIdxTsDsl } from './type/idx';\nimport { TypeLiteralTsDsl } from './type/literal';\nimport { TypeMappedTsDsl } from './type/mapped';\nimport { TypeObjectTsDsl } from './type/object';\nimport { TypeOperatorTsDsl } from './type/operator';\nimport { TypeOrTsDsl } from './type/or';\nimport { TypeParamTsDsl } from './type/param';\nimport { TypeQueryTsDsl } from './type/query';\nimport { TypeTemplateTsDsl } from './type/template';\nimport { TypeTupleTsDsl } from './type/tuple';\n\nconst base = {\n  /** Creates an array literal expression (e.g. `[1, 2, 3]`). */\n  array: (...args: ConstructorParameters<typeof ArrayTsDsl>) =>\n    new ArrayTsDsl(...args),\n\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as: (...args: ConstructorParameters<typeof AsTsDsl>) => new AsTsDsl(...args),\n\n  /** Creates a property access expression (e.g. `obj.foo`). */\n  attr: (...args: ConstructorParameters<typeof AttrTsDsl>) =>\n    new AttrTsDsl(...args),\n\n  /** Creates an await expression (e.g. `await promise`). */\n  await: (...args: ConstructorParameters<typeof AwaitTsDsl>) =>\n    new AwaitTsDsl(...args),\n\n  /** Creates a binary expression (e.g. `a + b`). */\n  binary: (...args: ConstructorParameters<typeof BinaryTsDsl>) =>\n    new BinaryTsDsl(...args),\n\n  /** Creates a function or method call expression (e.g. `fn(arg)`). */\n  call: (...args: ConstructorParameters<typeof CallTsDsl>) =>\n    new CallTsDsl(...args),\n\n  /** Creates a class declaration or expression. */\n  class: (...args: ConstructorParameters<typeof ClassTsDsl>) =>\n    new ClassTsDsl(...args),\n\n  /** Creates a constant variable declaration (`const`). */\n  const: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args).const(),\n\n  /** Creates a decorator expression (e.g. `@decorator`). */\n  decorator: (...args: ConstructorParameters<typeof DecoratorTsDsl>) =>\n    new DecoratorTsDsl(...args),\n\n  /** Creates a JSDoc documentation block. */\n  doc: (...args: ConstructorParameters<typeof DocTsDsl>) =>\n    new DocTsDsl(...args),\n\n  /** Creates an enum declaration. */\n  enum: (...args: ConstructorParameters<typeof EnumTsDsl>) =>\n    new EnumTsDsl(...args),\n\n  /** Creates a general expression node. */\n  expr: (...args: ConstructorParameters<typeof ExprTsDsl>) =>\n    new ExprTsDsl(...args),\n\n  /** Creates a field declaration in a class or object. */\n  field: (...args: ConstructorParameters<typeof FieldTsDsl>) =>\n    new FieldTsDsl(...args),\n\n  /** Converts a runtime value into a corresponding expression node. */\n  fromValue: (...args: Parameters<typeof exprValue>) => exprValue(...args),\n\n  /** Creates a function expression or declaration. */\n  func: ((nameOrFn?: any, fn?: any) => {\n    if (nameOrFn === undefined) return new FuncTsDsl();\n    if (typeof nameOrFn !== 'string') return new FuncTsDsl(nameOrFn);\n    if (fn === undefined) return new FuncTsDsl(nameOrFn);\n    return new FuncTsDsl(nameOrFn, fn);\n  }) as {\n    (): FuncTsDsl<'arrow'>;\n    (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n    (name: string): FuncTsDsl<'decl'>;\n    (name: string, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n    (\n      name?: string,\n      fn?: (f: FuncTsDsl<'decl'>) => void,\n    ): FuncTsDsl<'arrow'> | FuncTsDsl<'decl'>;\n  },\n\n  /** Creates a getter method declaration. */\n  getter: (...args: ConstructorParameters<typeof GetterTsDsl>) =>\n    new GetterTsDsl(...args),\n\n  /** Creates a single-line comment (//). */\n  hint: (...args: ConstructorParameters<typeof HintTsDsl>) =>\n    new HintTsDsl(...args),\n\n  /** Creates an identifier (e.g. `foo`). */\n  id: (...args: ConstructorParameters<typeof IdTsDsl>) => new IdTsDsl(...args),\n\n  /** Creates an if statement. */\n  if: (...args: ConstructorParameters<typeof IfTsDsl>) => new IfTsDsl(...args),\n\n  /** Creates an initialization block or statement. */\n  init: (...args: ConstructorParameters<typeof InitTsDsl>) =>\n    new InitTsDsl(...args),\n\n  /** Creates a let variable declaration (`let`). */\n  let: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args).let(),\n\n  /** Creates a literal value (e.g. string, number, boolean). */\n  literal: (...args: ConstructorParameters<typeof LiteralTsDsl>) =>\n    new LiteralTsDsl(...args),\n\n  /** Creates an enum member declaration. */\n  member: (...args: ConstructorParameters<typeof EnumMemberTsDsl>) =>\n    new EnumMemberTsDsl(...args),\n\n  /** Creates a method declaration inside a class or object. */\n  method: (...args: ConstructorParameters<typeof MethodTsDsl>) =>\n    new MethodTsDsl(...args),\n\n  /** Creates a negation expression (`-x`). */\n  neg: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args).neg(),\n\n  /** Creates a new expression (e.g. `new ClassName()`). */\n  new: (...args: ConstructorParameters<typeof NewTsDsl>) =>\n    new NewTsDsl(...args),\n\n  /** Creates a newline (for formatting purposes). */\n  newline: (...args: ConstructorParameters<typeof NewlineTsDsl>) =>\n    new NewlineTsDsl(...args),\n\n  /** Creates a logical NOT expression (`!x`). */\n  not: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args).not(),\n\n  /** Creates a block comment (/* ... *\\/). */\n  note: (...args: ConstructorParameters<typeof NoteTsDsl>) =>\n    new NoteTsDsl(...args),\n\n  /** Creates an object literal expression. */\n  object: (...args: ConstructorParameters<typeof ObjectTsDsl>) =>\n    new ObjectTsDsl(...args),\n\n  /** Creates a parameter declaration for functions or methods. */\n  param: (...args: ConstructorParameters<typeof ParamTsDsl>) =>\n    new ParamTsDsl(...args),\n\n  /** Creates a pattern for destructuring or matching. */\n  pattern: (...args: ConstructorParameters<typeof PatternTsDsl>) =>\n    new PatternTsDsl(...args),\n\n  /** Creates a prefix unary expression (e.g. `-x`, `!x`, `~x`). */\n  prefix: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args),\n\n  /** Creates an object literal property (e.g. `{ foo: bar }`). */\n  prop: (...args: ConstructorParameters<typeof ObjectPropTsDsl>) =>\n    new ObjectPropTsDsl(...args),\n\n  /** Creates a regular expression literal (e.g. `/foo/gi`). */\n  regexp: (...args: ConstructorParameters<typeof RegExpTsDsl>) =>\n    new RegExpTsDsl(...args),\n\n  /** Creates a return statement. */\n  return: (...args: ConstructorParameters<typeof ReturnTsDsl>) =>\n    new ReturnTsDsl(...args),\n\n  /** Creates a setter method declaration. */\n  setter: (...args: ConstructorParameters<typeof SetterTsDsl>) =>\n    new SetterTsDsl(...args),\n\n  /** Wraps an expression or statement-like value into a `StmtTsDsl`. */\n  stmt: (...args: ConstructorParameters<typeof StmtTsDsl>) =>\n    new StmtTsDsl(...args),\n\n  /** Creates a template literal expression. */\n  template: (...args: ConstructorParameters<typeof TemplateTsDsl>) =>\n    new TemplateTsDsl(...args),\n\n  /** Creates a ternary conditional expression (if ? then : else). */\n  ternary: (...args: ConstructorParameters<typeof TernaryTsDsl>) =>\n    new TernaryTsDsl(...args),\n\n  /** Creates a throw statement. */\n  throw: (...args: ConstructorParameters<typeof ThrowTsDsl>) =>\n    new ThrowTsDsl(...args),\n\n  /** Creates a syntax token (e.g. `?`, `readonly`, `+`, `-`). */\n  token: (...args: ConstructorParameters<typeof TokenTsDsl>) =>\n    new TokenTsDsl(...args),\n\n  /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n  type: Object.assign(\n    (...args: ConstructorParameters<typeof TypeExprTsDsl>) =>\n      new TypeExprTsDsl(...args),\n    {\n      /** Creates a type alias declaration (e.g. `type Foo = Bar`). */\n      alias: (...args: ConstructorParameters<typeof TypeAliasTsDsl>) =>\n        new TypeAliasTsDsl(...args),\n\n      /** Creates an intersection type (e.g. `A & B`). */\n      and: (...args: ConstructorParameters<typeof TypeAndTsDsl>) =>\n        new TypeAndTsDsl(...args),\n\n      /** Creates a qualified type reference (e.g. Foo.Bar). */\n      attr: (...args: ConstructorParameters<typeof TypeAttrTsDsl>) =>\n        new TypeAttrTsDsl(...args),\n\n      /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n      expr: (...args: ConstructorParameters<typeof TypeExprTsDsl>) =>\n        new TypeExprTsDsl(...args),\n\n      /** Converts a runtime value into a corresponding type expression node. */\n      fromValue: (...args: Parameters<typeof typeValue>) => typeValue(...args),\n\n      /** Creates a function type node (e.g. `(a: string) => number`). */\n      func: (...args: ConstructorParameters<typeof TypeFuncTsDsl>) =>\n        new TypeFuncTsDsl(...args),\n\n      /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n      idx: (...args: ConstructorParameters<typeof TypeIdxTsDsl>) =>\n        new TypeIdxTsDsl(...args),\n\n      /** Creates a literal type node (e.g. 'foo', 42, or true). */\n      literal: (...args: ConstructorParameters<typeof TypeLiteralTsDsl>) =>\n        new TypeLiteralTsDsl(...args),\n\n      /** Creates a mapped type (e.g. `{ [K in keyof T]: U }`). */\n      mapped: (...args: ConstructorParameters<typeof TypeMappedTsDsl>) =>\n        new TypeMappedTsDsl(...args),\n\n      /** Creates a type literal node (e.g. { foo: string }). */\n      object: (...args: ConstructorParameters<typeof TypeObjectTsDsl>) =>\n        new TypeObjectTsDsl(...args),\n\n      /** Creates a type operator node (e.g. `readonly T`, `keyof T`, `unique T`). */\n      operator: (...args: ConstructorParameters<typeof TypeOperatorTsDsl>) =>\n        new TypeOperatorTsDsl(...args),\n\n      /** Represents a union type (e.g. `A | B | C`). */\n      or: (...args: ConstructorParameters<typeof TypeOrTsDsl>) =>\n        new TypeOrTsDsl(...args),\n\n      /** Creates a type parameter (e.g. `<T>`). */\n      param: (...args: ConstructorParameters<typeof TypeParamTsDsl>) =>\n        new TypeParamTsDsl(...args),\n\n      /** Creates a type query node (e.g. `typeof Foo`). */\n      query: (...args: ConstructorParameters<typeof TypeQueryTsDsl>) =>\n        new TypeQueryTsDsl(...args),\n\n      /** Builds a TypeScript template literal *type* (e.g. `${Foo}-${Bar}` as a type). */\n      template: (...args: ConstructorParameters<typeof TypeTemplateTsDsl>) =>\n        new TypeTemplateTsDsl(...args),\n\n      /** Creates a tuple type (e.g. [A, B, C]). */\n      tuple: (...args: ConstructorParameters<typeof TypeTupleTsDsl>) =>\n        new TypeTupleTsDsl(...args),\n    },\n  ),\n\n  /** Creates a runtime `typeof` expression (e.g. typeof x). */\n  typeofExpr: (...args: ConstructorParameters<typeof TypeOfExprTsDsl>) =>\n    new TypeOfExprTsDsl(...args),\n\n  /** Creates a variable declaration (var). */\n  var: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args),\n};\n\nexport const $ = Object.assign(\n  (...args: ConstructorParameters<typeof ExprTsDsl>) => new ExprTsDsl(...args),\n  base,\n);\n\nexport type DollarTsDsl = {\n  /**\n   * Entry point to the TypeScript DSL.\n   *\n   * `$` creates a general expression node by default, but also exposes\n   * builders for all other constructs such as `.type()`, `.call()`,\n   * `.object()`, `.func()`, etc.\n   *\n   * Example:\n   * ```ts\n   * const node = $('console').attr('log').call($.literal('Hello'));\n   * ```\n   *\n   * Returns:\n   * - A new `ExprTsDsl` instance when called directly.\n   * - The `base` factory object for constructing more specific nodes.\n   */\n  $: typeof $;\n};\n\nexport type { MaybeTsDsl, TypeTsDsl } from './base';\nexport { TsDsl } from './base';\n","import type { Config } from '~/types/config';\n\nexport const transformClassName = ({\n  config,\n  name,\n}: {\n  config: Config;\n  name: string;\n}) => {\n  const plugin = config.plugins['@hey-api/sdk'];\n  if (plugin?.config.classNameBuilder) {\n    let customName = '';\n\n    if (typeof plugin.config.classNameBuilder === 'function') {\n      customName = plugin.config.classNameBuilder(name);\n    } else {\n      customName = plugin.config.classNameBuilder.replace('{{name}}', name);\n    }\n\n    return customName;\n  }\n\n  return name;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\n\nimport type { Auth } from '../../client-core/bundle/auth';\nimport type { HeyApiSdkPlugin } from '../types';\n\n// TODO: parser - handle more security types\nconst securitySchemeObjectToAuthObject = ({\n  securitySchemeObject,\n}: {\n  securitySchemeObject: IR.SecurityObject;\n}): Auth | undefined => {\n  if (securitySchemeObject.type === 'openIdConnect') {\n    return {\n      scheme: 'bearer',\n      type: 'http',\n    };\n  }\n\n  if (securitySchemeObject.type === 'oauth2') {\n    if (\n      securitySchemeObject.flows.password ||\n      securitySchemeObject.flows.authorizationCode ||\n      securitySchemeObject.flows.clientCredentials ||\n      securitySchemeObject.flows.implicit\n    ) {\n      return {\n        scheme: 'bearer',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'apiKey') {\n    if (securitySchemeObject.in === 'header') {\n      return {\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    if (\n      securitySchemeObject.in === 'query' ||\n      securitySchemeObject.in == 'cookie'\n    ) {\n      return {\n        in: securitySchemeObject.in,\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'http') {\n    const scheme = securitySchemeObject.scheme.toLowerCase();\n    if (scheme === 'bearer' || scheme === 'basic') {\n      return {\n        scheme: scheme as 'bearer' | 'basic',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  return;\n};\n\nexport const operationAuth = ({\n  operation,\n  plugin,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<Auth> => {\n  if (!operation.security || !plugin.config.auth) {\n    return [];\n  }\n\n  const auth: Array<Auth> = [];\n\n  for (const securitySchemeObject of operation.security) {\n    const authObject = securitySchemeObjectToAuthObject({\n      securitySchemeObject,\n    });\n    if (authObject) {\n      auth.push(authObject);\n    } else {\n      console.warn(\n        `‚ùóÔ∏è SDK warning: unsupported security scheme. Please open an issue if you'd like it added https://github.com/hey-api/openapi-ts/issues\\n${JSON.stringify(securitySchemeObject, null, 2)}`,\n      );\n    }\n  }\n\n  return auth;\n};\n","export const nuxtTypeComposable = 'TComposable';\nexport const nuxtTypeDefault = 'DefaultT';\nexport const nuxtTypeResponse = 'ResT';\n","const jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\n\n/**\n * Returns the reusable component name from `$ref`.\n */\nexport const refToName = ($ref: string): string => {\n  const path = jsonPointerToPath($ref);\n  const name = path[path.length - 1]!;\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  return decodeURI(name);\n};\n\n/**\n * Encodes a path segment for use in a JSON Pointer (RFC 6901).\n *\n * - Replaces all '~' with '~0'.\n * - Replaces all '/' with '~1'.\n *\n * This ensures that path segments containing these characters are safely\n * represented in JSON Pointer strings.\n *\n * @param segment - The path segment (string or number) to encode.\n * @returns The encoded segment as a string.\n */\nexport const encodeJsonPointerSegment = (segment: string | number): string =>\n  String(segment).replace(/~/g, '~0').replace(/\\//g, '~1');\n\n/**\n * Converts a JSON Pointer string (RFC 6901) to an array of path segments.\n *\n * - Removes the leading '#' if present.\n * - Splits the pointer on '/'.\n * - Decodes '~1' to '/' and '~0' to '~' in each segment.\n * - Returns an empty array for the root pointer ('#' or '').\n *\n * @param pointer - The JSON Pointer string to convert (e.g., '#/components/schemas/Foo').\n * @returns An array of decoded path segments.\n */\nexport const jsonPointerToPath = (pointer: string): ReadonlyArray<string> => {\n  let clean = pointer.trim();\n  if (clean.startsWith('#')) {\n    clean = clean.slice(1);\n  }\n  if (clean.startsWith('/')) {\n    clean = clean.slice(1);\n  }\n  if (!clean) {\n    return [];\n  }\n  return clean\n    .split('/')\n    .map((part) =>\n      part.replace(jsonPointerSlash, '/').replace(jsonPointerTilde, '~'),\n    );\n};\n\n/**\n * Normalizes a JSON Pointer string to a canonical form.\n *\n * - Ensures the pointer starts with '#'.\n * - Removes trailing slashes (except for root).\n * - Collapses multiple consecutive slashes into one.\n * - Trims whitespace from the input.\n *\n * @param pointer - The JSON Pointer string to normalize.\n * @returns The normalized JSON Pointer string.\n */\nexport const normalizeJsonPointer = (pointer: string): string => {\n  let normalized = pointer.trim();\n  if (!normalized.startsWith('#')) {\n    normalized = `#${normalized}`;\n  }\n  // Remove trailing slashes (except for root)\n  if (normalized.length > 1 && normalized.endsWith('/')) {\n    normalized = normalized.slice(0, -1);\n  }\n  // Collapse multiple slashes\n  normalized = normalized.replace(/\\/+/g, '/');\n  return normalized;\n};\n\n/**\n * Encode path as JSON Pointer (RFC 6901).\n *\n * @param path\n * @returns\n */\nexport const pathToJsonPointer = (\n  path: ReadonlyArray<string | number>,\n): string => {\n  const segments = path.map(encodeJsonPointerSegment).join('/');\n  return '#' + (segments ? `/${segments}` : '');\n};\n\nexport const resolveRef = <T>({\n  $ref,\n  spec,\n}: {\n  $ref: string;\n  spec: Record<string, any>;\n}): T => {\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  const path = jsonPointerToPath(decodeURI($ref));\n\n  let current = spec;\n\n  for (const part of path) {\n    const segment = part as keyof typeof current;\n    if (current[segment] === undefined) {\n      throw new Error(`Reference not found: ${$ref}`);\n    }\n    current = current[segment];\n  }\n\n  return current as T;\n};\n","import type { IR } from '~/ir/types';\nimport type { PluginInstance } from '~/plugins/shared/utils/instance';\nimport { refToName } from '~/utils/ref';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { Field } from '../../client-core/bundle/params';\n\ntype Location = keyof IR.ParametersObject | 'body';\n\ntype SignatureParameter = {\n  /**\n   * Is this parameter required in the SDK method signature?\n   */\n  isRequired: boolean;\n  /**\n   * Parameter name in the SDK method signature.\n   */\n  name: string;\n  /**\n   * If the name was modified due to conflicts, this holds the original name.\n   */\n  originalName?: string;\n  /**\n   * Parameter schema object.\n   */\n  schema: IR.SchemaObject;\n};\n\ntype SignatureParameters = Record<string, SignatureParameter>;\n\ntype Signature = {\n  fields: ReadonlyArray<Field>;\n  parameters: SignatureParameters;\n};\n\n/**\n * Collects and resolves all operation parameters for flattened SDK signatures.\n * - Prefixes all conflicting names with their location (e.g. path_foo, query_foo)\n * - Returns a flat map of resolved parameter names to their metadata\n */\nexport const getSignatureParameters = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): Signature | undefined => {\n  // TODO: add cookies\n  const locations = [\n    'header',\n    'path',\n    'query',\n  ] as const satisfies ReadonlyArray<Location>;\n  const nameToLocations: Record<string, Set<Location>> = {};\n\n  const addParameter = (name: string, location: Location): void => {\n    if (!nameToLocations[name]) {\n      nameToLocations[name] = new Set();\n    }\n    nameToLocations[name].add(location);\n  };\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        addParameter(parameter.name, location);\n      }\n    }\n  }\n\n  if (operation.body) {\n    // spread body if there's only a single object\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const key in properties) {\n        addParameter(key, 'body');\n      }\n    } else if (operation.body.schema.$ref) {\n      // alias body for more ergonomic naming, e.g. user if the type is User\n      const name = refToName(operation.body.schema.$ref);\n      const key = stringCase({ case: 'camelCase', value: name });\n      addParameter(key, 'body');\n    } else {\n      addParameter('body', 'body');\n    }\n  }\n\n  const conflicts = new Set<string>();\n  for (const name in nameToLocations) {\n    if (nameToLocations[name]!.size > 1) {\n      conflicts.add(name);\n    }\n  }\n\n  const signatureParameters: SignatureParameters = {};\n  const fields: Array<Field> = [];\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        const originalName = parameter.name;\n        const name = conflicts.has(originalName)\n          ? `${location}_${originalName}`\n          : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: parameter.required ?? false,\n          name,\n          schema: parameter.schema,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location === 'header' ? 'headers' : location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    }\n  }\n\n  if (operation.body) {\n    const location = 'body';\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const originalName in properties) {\n        const property = properties[originalName]!;\n        const name = conflicts.has(originalName)\n          ? `${location}_${originalName}`\n          : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: property.required?.includes(originalName) ?? false,\n          name,\n          schema: property,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    } else if (operation.body.schema.$ref) {\n      const value = refToName(operation.body.schema.$ref);\n      const originalName = stringCase({ case: 'camelCase', value });\n      const name = conflicts.has(originalName)\n        ? `${location}_${originalName}`\n        : originalName;\n      const signatureParameter: SignatureParameter = {\n        isRequired: operation.body.required ?? false,\n        name,\n        schema: operation.body.schema,\n      };\n      if (name !== originalName) {\n        signatureParameter.originalName = originalName;\n      }\n      signatureParameters[name] = signatureParameter;\n      fields.push({\n        key: name,\n        map: 'body',\n      });\n    } else {\n      // never alias body\n      signatureParameters.body = {\n        isRequired: operation.body.required ?? false,\n        name: 'body',\n        schema: operation.body.schema,\n      };\n      fields.push({ in: 'body' });\n    }\n  }\n\n  if (!Object.keys(signatureParameters).length) {\n    return;\n  }\n\n  return { fields, parameters: signatureParameters };\n};\n","import type { IR } from '~/ir/types';\nimport type { $ } from '~/ts-dsl';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\ninterface ValidatorProps {\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}\n\nexport const createRequestValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.request) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.request);\n  if (!validator.api.createRequestValidator) return;\n\n  return validator.api.createRequestValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n\nexport const createResponseValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.response) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.response);\n  if (!validator.api.createResponseValidator) return;\n\n  return validator.api.createResponseValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport type { Context } from '~/ir/context';\nimport { statusCodeToGroup } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { sanitizeNamespaceIdentifier } from '~/openApi/common/parser/sanitize';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { reservedJavaScriptKeywordsRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\nimport { transformClassName } from '~/utils/transform';\n\nimport type { Field, Fields } from '../../client-core/bundle/params';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { operationAuth } from './auth';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { getSignatureParameters } from './signature';\nimport { createRequestValidator, createResponseValidator } from './validator';\n\ninterface ClassNameEntry {\n  /**\n   * Name of the class where this function appears.\n   */\n  className: string;\n  /**\n   * Name of the function within the class.\n   */\n  methodName: string;\n  /**\n   * JSONPath-like array to class location.\n   */\n  path: ReadonlyArray<string>;\n}\n\nconst operationClassName = ({\n  context,\n  value,\n}: {\n  context: Context;\n  value: string;\n}) => {\n  const name = stringCase({\n    case: 'PascalCase',\n    value: sanitizeNamespaceIdentifier(value),\n  });\n  return transformClassName({\n    config: context.config,\n    name,\n  });\n};\n\nconst getOperationMethodName = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: {\n    config: Pick<\n      HeyApiSdkPlugin['Instance']['config'],\n      'asClass' | 'methodNameBuilder'\n    >;\n  };\n}) => {\n  if (plugin.config.methodNameBuilder) {\n    return plugin.config.methodNameBuilder(operation);\n  }\n\n  const handleIllegal = !plugin.config.asClass;\n  if (handleIllegal && operation.id.match(reservedJavaScriptKeywordsRegExp)) {\n    return `${operation.id}_`;\n  }\n\n  return operation.id;\n};\n\n/**\n * Returns a list of classes where this operation appears in the generated SDK.\n */\nexport const operationClasses = ({\n  context,\n  operation,\n  plugin,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n  plugin: {\n    config: Pick<\n      HeyApiSdkPlugin['Instance']['config'],\n      'asClass' | 'classStructure' | 'instance'\n    >;\n  };\n}): Map<string, ClassNameEntry> => {\n  const classNames = new Map<string, ClassNameEntry>();\n\n  let className: string | undefined;\n  let methodName: string | undefined;\n  let classCandidates: Array<string> = [];\n\n  if (plugin.config.classStructure === 'auto' && operation.operationId) {\n    classCandidates = operation.operationId.split(/[./]/).filter(Boolean);\n    if (classCandidates.length > 1) {\n      const methodCandidate = classCandidates.pop()!;\n      methodName = stringCase({\n        case: 'camelCase',\n        value: sanitizeNamespaceIdentifier(methodCandidate),\n      });\n      className = classCandidates.pop()!;\n    }\n  }\n\n  const rootClasses = plugin.config.instance\n    ? [plugin.config.instance as string]\n    : (operation.tags ?? ['default']);\n\n  for (const rootClass of rootClasses) {\n    const finalClassName = operationClassName({\n      context,\n      value: className || rootClass,\n    });\n\n    // Default path\n    let path = [rootClass];\n    if (className) {\n      // If root class is already within classCandidates or the same as className\n      // do not add it again as this will cause a recursion issue.\n      if (classCandidates.includes(rootClass) || rootClass === className) {\n        path = [...classCandidates, className];\n      } else {\n        path = [rootClass, ...classCandidates, className];\n      }\n    }\n\n    classNames.set(rootClass, {\n      className: finalClassName,\n      methodName: methodName || getOperationMethodName({ operation, plugin }),\n      path: path.map((value) =>\n        operationClassName({\n          context,\n          value,\n        }),\n      ),\n    });\n  }\n\n  return classNames;\n};\n\n/** TODO: needs complete refactor */\nexport const operationOptionsType = ({\n  isDataAllowed = true,\n  operation,\n  plugin,\n  throwOnError,\n}: {\n  isDataAllowed?: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n  throwOnError?: string;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolDataType = isDataAllowed\n    ? plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tool: 'typescript',\n      })\n    : undefined;\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  if (isNuxtClient) {\n    const symbolResponseType = plugin.querySymbol({\n      category: 'type',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    });\n    const dataType = isDataAllowed\n      ? symbolDataType?.placeholder || 'unknown'\n      : 'never';\n    const responseType = symbolResponseType?.placeholder || 'unknown';\n    return `${symbolOptions.placeholder}<${nuxtTypeComposable}, ${dataType}, ${responseType}, ${nuxtTypeDefault}>`;\n  }\n\n  // TODO: refactor this to be more generic, works for now\n  if (throwOnError) {\n    const dataType = isDataAllowed\n      ? symbolDataType?.placeholder || 'unknown'\n      : 'never';\n    return `${symbolOptions.placeholder}<${dataType}, ${throwOnError}>`;\n  }\n  const dataType = isDataAllowed ? symbolDataType?.placeholder : 'never';\n  return dataType\n    ? `${symbolOptions.placeholder}<${dataType}>`\n    : symbolOptions.placeholder;\n};\n\ntype OperationParameters = {\n  argNames: Array<string>;\n  fields: Array<Field | Fields>;\n  parameters: Array<ReturnType<typeof $.param>>;\n};\n\nexport const operationParameters = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): OperationParameters => {\n  const result: OperationParameters = {\n    argNames: [],\n    fields: [],\n    parameters: [],\n  };\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  if (plugin.config.paramsStructure === 'flat') {\n    const signature = getSignatureParameters({ operation, plugin });\n    const flatParams = $.type.object();\n\n    if (signature) {\n      let isParametersRequired = false;\n\n      for (const key in signature.parameters) {\n        const parameter = signature.parameters[key]!;\n        if (parameter.isRequired) {\n          isParametersRequired = true;\n        }\n        flatParams.prop(parameter.name, (p) =>\n          p.required(parameter.isRequired).type(\n            pluginTypeScript.api.schemaToType({\n              plugin: pluginTypeScript,\n              schema: parameter.schema,\n              state: toRefs({\n                path: [],\n              }),\n            }),\n          ),\n        );\n      }\n\n      result.argNames.push('parameters');\n      for (const field of signature.fields) {\n        result.fields.push(field);\n      }\n\n      result.parameters.push(\n        $.param('parameters', (p) =>\n          p.required(isParametersRequired).type(flatParams),\n        ),\n      );\n    }\n  }\n\n  result.parameters.push(\n    $.param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        operationOptionsType({\n          isDataAllowed: plugin.config.paramsStructure === 'grouped',\n          operation,\n          plugin,\n          throwOnError: isNuxtClient ? undefined : 'ThrowOnError',\n        }),\n      ),\n    ),\n  );\n\n  return result;\n};\n\n/**\n * Infers `responseType` value from provided response content type. This is\n * an adapted version of `getParseAs()` from the Fetch API client.\n *\n * From Axios documentation:\n * `responseType` indicates the type of data that the server will respond with\n * options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n * browser only: 'blob'\n */\nconst getResponseType = (\n  contentType: string | null | undefined,\n):\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'stream'\n  | 'text'\n  | undefined => {\n  if (!contentType) {\n    return;\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  // Axios does not handle form data out of the box\n  // if (cleanContent === 'multipart/form-data') {\n  //   return 'formData';\n  // }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nexport const operationStatements = ({\n  isRequiredOptions,\n  opParameters,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  opParameters: OperationParameters;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<ReturnType<typeof $.return | typeof $.const>> => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'response' : 'responses',\n  });\n  const responseType = symbolResponseType?.placeholder || 'unknown';\n\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'error' : 'errors',\n  });\n  const errorType = symbolErrorType?.placeholder || 'unknown';\n\n  // TODO: transform parameters\n  // const query = {\n  //   BarBaz: options.query.bar_baz,\n  //   qux_quux: options.query.qux_quux,\n  //   fooBar: options.query.foo_bar,\n  // };\n\n  // if (operation.parameters) {\n  //   for (const name in operation.parameters.query) {\n  //     const parameter = operation.parameters.query[name]\n  //     if (parameter.name !== fieldName({ context, name: parameter.name })) {\n  //       console.warn(parameter.name)\n  //     }\n  //   }\n  // }\n\n  const reqOptions = $.object();\n\n  if (operation.body) {\n    switch (operation.body.type) {\n      case 'form-data': {\n        const symbol = plugin.referenceSymbol({\n          category: 'external',\n          resource: 'client.formDataBodySerializer',\n        });\n        reqOptions.spread(symbol.placeholder);\n        break;\n      }\n      case 'json':\n        // jsonBodySerializer is the default, no need to specify\n        break;\n      case 'text':\n      case 'octet-stream':\n        // ensure we don't use any serializer by default\n        reqOptions.prop('bodySerializer', $.literal(null));\n        break;\n      case 'url-search-params': {\n        const symbol = plugin.referenceSymbol({\n          category: 'external',\n          resource: 'client.urlSearchParamsBodySerializer',\n        });\n        reqOptions.spread(symbol.placeholder);\n        break;\n      }\n    }\n  }\n\n  // TODO: parser - set parseAs to skip inference if every response has the same\n  // content type. currently impossible because successes do not contain\n  // header information\n\n  const paramSerializers = $.object();\n\n  for (const name in operation.parameters?.query) {\n    const parameter = operation.parameters.query[name]!;\n\n    if (\n      parameter.schema.type === 'array' ||\n      parameter.schema.type === 'tuple'\n    ) {\n      if (parameter.style !== 'form' || !parameter.explode) {\n        // override the default settings for array serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'array',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'form', (o) =>\n                o.prop('style', $.literal(parameter.style)),\n              ),\n          ),\n        );\n      }\n    } else if (parameter.schema.type === 'object') {\n      if (parameter.style !== 'deepObject' || !parameter.explode) {\n        // override the default settings for object serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'object',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'deepObject', (o) =>\n                o.prop('style', $.literal(parameter.style)),\n              ),\n          ),\n        );\n      }\n    }\n  }\n\n  if (paramSerializers.hasProps()) {\n    // TODO: if all parameters have the same serialization,\n    // apply it globally to reduce output size\n    reqOptions.prop(\n      'querySerializer',\n      $.object().prop('parameters', paramSerializers),\n    );\n  }\n\n  const requestValidator = createRequestValidator({ operation, plugin });\n  const responseValidator = createResponseValidator({ operation, plugin });\n  if (requestValidator) {\n    reqOptions.prop('requestValidator', requestValidator.arrow());\n  }\n\n  if (plugin.config.transformer) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    };\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = plugin.referenceSymbol(query);\n      reqOptions.prop('responseTransformer', $(ref.placeholder));\n    }\n  }\n\n  let hasServerSentEvents = false;\n  let responseTypeValue: ReturnType<typeof getResponseType> | undefined;\n\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n\n    // try to infer `responseType` option for Axios. We don't need this in\n    // Fetch API client because it automatically detects the correct response\n    // during runtime.\n    if (!responseTypeValue && client.name === '@hey-api/client-axios') {\n      // this doesn't handle default status code for now\n      if (statusCodeToGroup({ statusCode }) === '2XX') {\n        responseTypeValue = getResponseType(response.mediaType);\n        if (responseTypeValue) {\n          reqOptions.prop('responseType', $.literal(responseTypeValue));\n        }\n      }\n    }\n\n    if (response.mediaType === 'text/event-stream') {\n      hasServerSentEvents = true;\n    }\n  }\n\n  if (responseValidator) {\n    reqOptions.prop('responseValidator', responseValidator.arrow());\n  }\n\n  if (plugin.config.responseStyle === 'data') {\n    reqOptions.prop('responseStyle', $.literal(plugin.config.responseStyle));\n  }\n\n  const auth = operationAuth({ context: plugin.context, operation, plugin });\n  if (auth.length) {\n    reqOptions.prop('security', $.fromValue(auth));\n  }\n\n  reqOptions.prop('url', $.literal(operation.path));\n\n  // options must go last to allow overriding parameters above\n  reqOptions.spread('options');\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  const hasParams = opParameters.argNames.length;\n\n  if (hasParams) {\n    const args: Array<ReturnType<typeof $.expr>> = [];\n    const config: Array<ReturnType<typeof $.object>> = [];\n    for (const argName of opParameters.argNames) {\n      args.push($(argName));\n    }\n    for (const field of opParameters.fields) {\n      const shape = $.object();\n      if ('in' in field) {\n        shape.prop('in', $.literal(field.in));\n      }\n      if ('key' in field) {\n        if (field.key) {\n          shape.prop('key', $.literal(field.key));\n        }\n        if (field.map) {\n          shape.prop('map', $.literal(field.map));\n        }\n      }\n      config.push(shape);\n    }\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'client.buildClientParams',\n    });\n    statements.push(\n      $.const('params').assign(\n        $(symbol.placeholder).call(\n          $.array(...args),\n          $.array($.object().prop('args', $.array(...config))),\n        ),\n      ),\n    );\n    reqOptions.spread('params');\n  }\n\n  if (operation.body) {\n    const parameterContentType = operation.parameters?.header?.['content-type'];\n    const hasRequiredContentType = Boolean(parameterContentType?.required);\n    // spreading required Content-Type on generated header would throw a TypeScript error\n    if (!hasRequiredContentType) {\n      const headers = $.object()\n        .pretty()\n        // form-data does not need Content-Type header, browser will set it automatically\n        .prop(\n          parameterContentType?.name ?? 'Content-Type',\n          $.literal(\n            operation.body.type === 'form-data'\n              ? null\n              : operation.body.mediaType,\n          ),\n        )\n        .spread($('options').attr('headers').required(isRequiredOptions));\n      if (hasParams) {\n        headers.spread($('params').attr('headers'));\n      }\n      reqOptions.prop('headers', headers);\n    }\n  }\n\n  const symbolClient = plugin.config.client\n    ? plugin.getSymbol({\n        category: 'client',\n      })\n    : undefined;\n\n  let clientExpression: ReturnType<typeof $.attr | typeof $.binary>;\n  const optionsClient = $('options').attr('client').required(isRequiredOptions);\n  if (plugin.config.instance) {\n    clientExpression = optionsClient.coalesce($('this').attr('client'));\n  } else if (symbolClient) {\n    clientExpression = optionsClient.coalesce(symbolClient.placeholder);\n  } else {\n    clientExpression = optionsClient;\n  }\n\n  let functionName = hasServerSentEvents\n    ? clientExpression.attr('sse')\n    : clientExpression;\n  functionName = functionName.attr(operation.method);\n\n  statements.push(\n    $.return(\n      functionName\n        .call(reqOptions)\n        .$if(\n          isNuxtClient,\n          (f) =>\n            f\n              .generic(nuxtTypeComposable)\n              .generic(`${responseType} | ${nuxtTypeDefault}`)\n              .generic(errorType)\n              .generic(nuxtTypeDefault),\n          (f) =>\n            f.generic(responseType).generic(errorType).generic('ThrowOnError'),\n        )\n        .$if(plugin.config.responseStyle === 'data', (f) =>\n          f.generic($.type.literal(plugin.config.responseStyle)),\n        ),\n    ),\n  );\n\n  return statements;\n};\n","import { EOL } from 'node:os';\n\nimport { validTypescriptIdentifierRegExp } from './regexp';\n\nexport const escapeName = (value: string): string => {\n  if (value || value === '') {\n    validTypescriptIdentifierRegExp.lastIndex = 0;\n    const validName = validTypescriptIdentifierRegExp.test(value);\n    if (!validName) {\n      return `'${value}'`;\n    }\n  }\n  return value;\n};\n\nexport const unescapeName = (value: string): string => {\n  if (value && value.startsWith(\"'\") && value.endsWith(\"'\")) {\n    return value.slice(1, value.length - 1);\n  }\n  return value;\n};\n\nexport const escapeComment = (value: string) =>\n  value\n    .replace(/\\*\\//g, '*')\n    .replace(/\\/\\*/g, '*')\n    .replace(/\\r?\\n(.*)/g, (_l, w) => EOL + w.trim());\n","import type { Context } from '~/ir/context';\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createOperationComment = (\n  operation: IR.OperationObject,\n): ReadonlyArray<string> | undefined => {\n  const comments: Array<string> = [];\n\n  if (operation.summary) {\n    comments.push(escapeComment(operation.summary));\n  }\n\n  if (operation.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between summary and description\n    }\n\n    comments.push(escapeComment(operation.description));\n  }\n\n  if (operation.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n\nexport const isOperationOptionsRequired = ({\n  context,\n  operation,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n}): boolean => {\n  const client = getClientPlugin(context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const plugin = context.config.plugins['@hey-api/sdk'];\n  if (plugin) {\n    if (!plugin.config.client && !plugin.config.instance) {\n      return true;\n    }\n    if (plugin.config.paramsStructure === 'flat') {\n      return false;\n    }\n  }\n  return isNuxtClient || hasOperationDataRequired(operation);\n};\n\nexport const hasOperationSse = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n}): boolean => {\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n    if (response.mediaType === 'text/event-stream') {\n      return true;\n    }\n  }\n  return false;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { AngularCommonPlugin } from './types';\n\ninterface AngularRequestClassEntry {\n  className: string;\n  classes: Set<string>;\n  methods: Set<string>;\n  nodes: Array<ReturnType<typeof $.method | typeof $.field | typeof $.newline>>;\n  root: boolean;\n}\n\nconst generateAngularClassRequests = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const requestClasses = new Map<string, AngularRequestClassEntry>();\n  const generatedClasses = new Set<string>();\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin: sdkPlugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          if (!requestClasses.has(currentClassName)) {\n            requestClasses.set(currentClassName, {\n              className: currentClassName,\n              classes: new Set(),\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName && parentClassName !== currentClassName) {\n            const parentClass = requestClasses.get(parentClassName)!;\n            parentClass.classes.add(currentClassName);\n            requestClasses.set(parentClassName, parentClass);\n          }\n\n          const isLast = entry.path.length === index + 1;\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = requestClasses.get(currentClassName)!;\n\n          const requestMethodName =\n            plugin.config.httpRequests.methodNameBuilder(operation);\n\n          if (currentClass.methods.has(requestMethodName)) {\n            return;\n          }\n\n          const methodNode = generateAngularRequestMethod({\n            isRequiredOptions,\n            methodName: requestMethodName,\n            operation,\n            plugin,\n          });\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(methodNode);\n          } else {\n            currentClass.nodes.push($.newline(), methodNode);\n          }\n\n          currentClass.methods.add(requestMethodName);\n          requestClasses.set(currentClassName, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const generateClass = (currentClass: AngularRequestClassEntry) => {\n    if (generatedClasses.has(currentClass.className)) {\n      return;\n    }\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = requestClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        currentClass.nodes.push(\n          $.field(\n            stringCase({ case: 'camelCase', value: childClass.className }),\n          ).assign(\n            $.new(\n              buildName({\n                config: {\n                  case: 'preserve',\n                  name: plugin.config.httpRequests.classNameBuilder,\n                },\n                name: childClass.className,\n              }),\n            ),\n          ),\n        );\n      }\n    }\n\n    const symbolInjectable = plugin.referenceSymbol({\n      category: 'external',\n      resource: '@angular/core.Injectable',\n    });\n    const symbolClass = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'utility',\n        resource: 'class',\n        resourceId: currentClass.className,\n        tool: 'angular',\n      },\n      name: buildName({\n        config: {\n          case: 'preserve',\n          name: plugin.config.httpRequests.classNameBuilder,\n        },\n        name: currentClass.className,\n      }),\n    });\n    const node = $.class(symbolClass.placeholder)\n      .export(symbolClass.exported)\n      .$if(currentClass.root, (c) =>\n        c.decorator(\n          symbolInjectable.placeholder,\n          $.object().prop('providedIn', $.literal('root')),\n        ),\n      )\n      .do(...currentClass.nodes);\n    plugin.setSymbolValue(symbolClass, node);\n\n    generatedClasses.add(currentClass.className);\n  };\n\n  for (const requestClass of requestClasses.values()) {\n    generateClass(requestClass);\n  }\n};\n\nconst generateAngularFunctionRequests = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        meta: {\n          category: 'utility',\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'data',\n          tool: 'angular',\n        },\n        name: plugin.config.httpRequests.methodNameBuilder(operation),\n      });\n      const node = generateAngularRequestFunction({\n        isRequiredOptions,\n        operation,\n        plugin,\n        symbol,\n      });\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n\nconst generateRequestCallExpression = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const optionsClient = $('options')\n    .attr('client')\n    .optional()\n    .$if(symbolClient, (c, s) => c.coalesce(s.placeholder));\n\n  return optionsClient\n    .attr('requestOptions')\n    .call(\n      $.object()\n        .prop('responseStyle', $.literal('data'))\n        .prop('method', $.literal(operation.method.toUpperCase()))\n        .prop('url', $.literal(operation.path))\n        .spread('options'),\n    );\n};\n\nconst generateAngularRequestMethod = ({\n  isRequiredOptions,\n  methodName,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  methodName: string;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const symbolHttpRequest = plugin.referenceSymbol({\n    category: 'external',\n    resource: '@angular/common/http.HttpRequest',\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return $.method(methodName)\n    .public()\n    .$if(createOperationComment(operation), (c, v) => c.doc(v))\n    .param('options', (p) =>\n      p\n        .required(isRequiredOptions)\n        .type(`${symbolOptions.placeholder}<${dataType}, ThrowOnError>`),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .returns(`${symbolHttpRequest.placeholder}<unknown>`)\n    .do(\n      $.return(\n        generateRequestCallExpression({\n          operation,\n          plugin,\n        }),\n      ),\n    );\n};\n\nconst generateAngularRequestFunction = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n  symbol,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const symbolHttpRequest = plugin.referenceSymbol({\n    category: 'external',\n    resource: '@angular/common/http.HttpRequest',\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p\n            .required(isRequiredOptions)\n            .type(`${symbolOptions.placeholder}<${dataType}, ThrowOnError>`),\n        )\n        .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n        .returns(`${symbolHttpRequest.placeholder}<unknown>`)\n        .do(\n          $.return(\n            generateRequestCallExpression({\n              operation,\n              plugin,\n            }),\n          ),\n        ),\n    );\n};\n\nexport const createHttpRequests: AngularCommonPlugin['Handler'] = ({\n  plugin,\n}) => {\n  if (plugin.config.httpRequests.asClass) {\n    generateAngularClassRequests({ plugin });\n  } else {\n    generateAngularFunctionRequests({ plugin });\n  }\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { AngularCommonPlugin } from './types';\n\ninterface AngularServiceClassEntry {\n  className: string;\n  classes: Set<string>;\n  methods: Set<string>;\n  nodes: Array<ReturnType<typeof $.method | typeof $.field | typeof $.newline>>;\n  root: boolean;\n}\n\nconst generateAngularClassServices = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const serviceClasses = new Map<string, AngularServiceClassEntry>();\n  const generatedClasses = new Set<string>();\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin: sdkPlugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          if (!serviceClasses.has(currentClassName)) {\n            serviceClasses.set(currentClassName, {\n              className: currentClassName,\n              classes: new Set(),\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName && parentClassName !== currentClassName) {\n            const parentClass = serviceClasses.get(parentClassName)!;\n            parentClass.classes.add(currentClassName);\n            serviceClasses.set(parentClassName, parentClass);\n          }\n\n          const isLast = entry.path.length === index + 1;\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = serviceClasses.get(currentClassName)!;\n\n          const resourceMethodName =\n            plugin.config.httpResources.methodNameBuilder(operation);\n\n          if (currentClass.methods.has(resourceMethodName)) {\n            return;\n          }\n\n          const methodNode = generateAngularResourceMethod({\n            isRequiredOptions,\n            methodName: resourceMethodName,\n            operation,\n            plugin,\n          });\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(methodNode);\n          } else {\n            currentClass.nodes.push($.newline(), methodNode);\n          }\n\n          currentClass.methods.add(resourceMethodName);\n          serviceClasses.set(currentClassName, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const generateClass = (currentClass: AngularServiceClassEntry) => {\n    if (generatedClasses.has(currentClass.className)) {\n      return;\n    }\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = serviceClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        currentClass.nodes.push(\n          $.field(\n            stringCase({\n              case: 'camelCase',\n              value: childClass.className,\n            }),\n          ).assign(\n            $.new(\n              buildName({\n                config: {\n                  case: 'preserve',\n                  name: plugin.config.httpResources.classNameBuilder,\n                },\n                name: childClass.className,\n              }),\n            ),\n          ),\n        );\n      }\n    }\n\n    const symbolInjectable = plugin.referenceSymbol({\n      category: 'external',\n      resource: '@angular/core.Injectable',\n    });\n    const symbolClass = plugin.registerSymbol({\n      exported: true,\n      name: buildName({\n        config: {\n          case: 'preserve',\n          name: plugin.config.httpResources.classNameBuilder,\n        },\n        name: currentClass.className,\n      }),\n    });\n    const node = $.class(symbolClass.placeholder)\n      .export(symbolClass.exported)\n      .$if(currentClass.root, (c) =>\n        c.decorator(\n          symbolInjectable.placeholder,\n          $.object().prop('providedIn', $.literal('root')),\n        ),\n      )\n      .do(...currentClass.nodes);\n    plugin.setSymbolValue(symbolClass, node);\n\n    generatedClasses.add(currentClass.className);\n  };\n\n  for (const serviceClass of serviceClasses.values()) {\n    generateClass(serviceClass);\n  }\n};\n\nconst generateAngularFunctionServices = ({\n  plugin,\n}: {\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        name: plugin.config.httpResources.methodNameBuilder(operation),\n      });\n      const node = generateAngularResourceFunction({\n        isRequiredOptions,\n        operation,\n        plugin,\n        symbol,\n      });\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n\nconst generateResourceCallExpression = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  const symbolHttpResource = plugin.referenceSymbol({\n    category: 'external',\n    resource: '@angular/common/http.httpResource',\n  });\n\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  const responseType = symbolResponseType?.placeholder || 'unknown';\n\n  if (plugin.config.httpRequests.asClass) {\n    // For class-based request methods, use inject and class hierarchy\n    const classes = operationClasses({\n      context: plugin.context,\n      operation,\n      plugin: sdkPlugin,\n    });\n\n    const firstEntry = Array.from(classes.values())[0];\n    if (firstEntry) {\n      // Import the root class from HTTP requests\n      const rootClassName = firstEntry.path[0]!;\n      const symbolClass = plugin.referenceSymbol({\n        category: 'utility',\n        resource: 'class',\n        resourceId: rootClassName,\n        tool: 'angular',\n      });\n\n      // Build the method access path using inject\n      const symbolInject = plugin.referenceSymbol({\n        category: 'external',\n        resource: '@angular/core.inject',\n      });\n      let methodAccess: ReturnType<typeof $.attr | typeof $.call> = $(\n        symbolInject.placeholder,\n      ).call(symbolClass.placeholder);\n\n      // Navigate through the class hierarchy\n      for (let i = 1; i < firstEntry.path.length; i++) {\n        const className = firstEntry.path[i];\n        if (className) {\n          methodAccess = methodAccess.attr(\n            stringCase({\n              case: 'camelCase',\n              value: className,\n            }),\n          );\n        }\n      }\n\n      methodAccess = methodAccess.attr(\n        plugin.config.httpRequests.methodNameBuilder(operation),\n      );\n\n      return $(symbolHttpResource.placeholder)\n        .call(\n          $.func().do(\n            $.const('opts').assign(\n              $.ternary('options')\n                .do($('options').call())\n                .otherwise($.id('undefined')),\n            ),\n            $.return(\n              $.ternary('opts')\n                .do(methodAccess.call('opts'))\n                .otherwise($.id('undefined')),\n            ),\n          ),\n        )\n        .generic(responseType);\n    }\n  } else {\n    const symbolHttpRequest = plugin.referenceSymbol({\n      category: 'utility',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'data',\n      tool: 'angular',\n    });\n\n    return $(symbolHttpResource.placeholder)\n      .call(\n        $.func().do(\n          $.const('opts').assign(\n            $.ternary('options')\n              .do($('options').call())\n              .otherwise($.id('undefined')),\n          ),\n          $.return(\n            $.ternary('opts')\n              .do($(symbolHttpRequest.placeholder).call('opts'))\n              .otherwise($.id('undefined')),\n          ),\n        ),\n      )\n      .generic(responseType);\n  }\n\n  // Fallback return (should not reach here)\n  return $(symbolHttpResource.placeholder).call(\n    $.func()\n      .do($.return($.id('undefined')))\n      .generic(responseType),\n  );\n};\n\nconst generateAngularResourceMethod = ({\n  isRequiredOptions,\n  methodName,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  methodName: string;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}) => {\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return $.method(methodName)\n    .public()\n    .$if(createOperationComment(operation), (c, v) => c.doc(v))\n    .param('options', (p) =>\n      p\n        .required(isRequiredOptions)\n        .type(\n          `() => ${symbolOptions.placeholder}<${dataType}, ThrowOnError> | undefined`,\n        ),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .do(\n      $.return(\n        generateResourceCallExpression({\n          operation,\n          plugin,\n        }),\n      ),\n    );\n};\n\nconst generateAngularResourceFunction = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n  symbol,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const dataType = symbolDataType?.placeholder || 'unknown';\n\n  return $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p\n            .required(isRequiredOptions)\n            .type(\n              `() => ${symbolOptions.placeholder}<${dataType}, ThrowOnError> | undefined`,\n            ),\n        )\n        .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n        .do(\n          $.return(\n            generateResourceCallExpression({\n              operation,\n              plugin,\n            }),\n          ),\n        ),\n    );\n};\n\nexport const createHttpResources: AngularCommonPlugin['Handler'] = ({\n  plugin,\n}) => {\n  if (plugin.config.httpResources.asClass) {\n    generateAngularClassServices({ plugin });\n  } else {\n    generateAngularFunctionServices({ plugin });\n  }\n};\n","import { createHttpRequests } from './httpRequests';\nimport { createHttpResources } from './httpResources';\nimport type { AngularCommonPlugin } from './types';\n\nexport const handler: AngularCommonPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: '@angular/common/http',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.HttpRequest',\n    },\n    name: 'HttpRequest',\n  });\n  plugin.registerSymbol({\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.inject',\n    },\n    name: 'inject',\n  });\n  plugin.registerSymbol({\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.Injectable',\n    },\n    name: 'Injectable',\n  });\n  plugin.registerSymbol({\n    external: '@angular/common/http',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.httpResource',\n    },\n    name: 'httpResource',\n  });\n\n  if (plugin.config.httpRequests.enabled) {\n    createHttpRequests({ plugin });\n  }\n\n  if (plugin.config.httpResources.enabled) {\n    createHttpResources({ plugin });\n  }\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { AngularCommonPlugin } from './types';\n\nexport const defaultConfig: AngularCommonPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/client-angular', '@hey-api/sdk'],\n  handler,\n  name: '@angular/common',\n  resolveConfig: (plugin, context) => {\n    plugin.config.httpRequests = context.valueToObject({\n      defaultValue: {\n        asClass: false,\n        classNameBuilder: '{{name}}Requests',\n        enabled: true,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n      },\n      value: plugin.config.httpRequests,\n    });\n\n    if (!plugin.config.httpRequests.methodNameBuilder) {\n      const { asClass } = plugin.config.httpRequests;\n      plugin.config.httpRequests.methodNameBuilder = (operation) =>\n        asClass ? String(operation.id) : `${String(operation.id)}Request`;\n    }\n\n    plugin.config.httpResources = context.valueToObject({\n      defaultValue: {\n        asClass: false,\n        classNameBuilder: '{{name}}Resources',\n        enabled: true,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n      },\n      value: plugin.config.httpResources,\n    });\n\n    if (!plugin.config.httpResources.methodNameBuilder) {\n      const { asClass } = plugin.config.httpResources;\n      plugin.config.httpResources.methodNameBuilder = (operation) =>\n        asClass ? String(operation.id) : `${String(operation.id)}Resource`;\n    }\n  },\n};\n\n/**\n * Type helper for `@angular/common` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const clientDefaultConfig = {\n  baseUrl: true,\n  bundle: true,\n  exportFromIndex: false,\n} as const;\n\nexport const clientDefaultMeta = {\n  dependencies: ['@hey-api/typescript'],\n  tags: ['client'],\n} as const;\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport type { IProject, ProjectRenderMeta } from '@hey-api/codegen-core';\n\nimport type { DefinePlugin } from '~/plugins';\nimport type { Client } from '~/plugins/@hey-api/client-core/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Config } from '~/types/config';\n\nimport { ensureDirSync } from './utils';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Returns absolute path to the client folder. This is hard-coded for now.\n */\nexport const clientFolderAbsolutePath = (config: Config): string => {\n  const client = getClientPlugin(config);\n\n  if ('bundle' in client.config && client.config.bundle) {\n    // not proud of this one\n    const renamed: Map<string, string> | undefined =\n      // @ts-expect-error\n      config._FRAGILE_CLIENT_BUNDLE_RENAMED;\n    return path.resolve(\n      config.output.path,\n      'client',\n      `${renamed?.get('index') ?? 'index'}.ts`,\n    );\n  }\n\n  return client.name;\n};\n\n/**\n * Recursively copies files and directories.\n * This is a PnP-compatible alternative to fs.cpSync that works with Yarn PnP's\n * virtualized filesystem.\n */\nconst copyRecursivePnP = (src: string, dest: string) => {\n  const stat = fs.statSync(src);\n\n  if (stat.isDirectory()) {\n    if (!fs.existsSync(dest)) {\n      fs.mkdirSync(dest, { recursive: true });\n    }\n\n    const files = fs.readdirSync(src);\n    for (const file of files) {\n      copyRecursivePnP(path.join(src, file), path.join(dest, file));\n    }\n  } else {\n    const content = fs.readFileSync(src);\n    fs.writeFileSync(dest, content);\n  }\n};\n\nconst renameFile = ({\n  filePath,\n  project,\n  renamed,\n}: {\n  filePath: string;\n  project: IProject;\n  renamed: Map<string, string>;\n}) => {\n  const extension = path.extname(filePath);\n  const name = path.basename(filePath, extension);\n  const renamedName = project.fileName?.(name) || name;\n  if (renamedName !== name) {\n    const outputPath = path.dirname(filePath);\n    fs.renameSync(\n      filePath,\n      path.resolve(outputPath, `${renamedName}${extension}`),\n    );\n    renamed.set(name, renamedName);\n  }\n};\n\nconst replaceImports = ({\n  filePath,\n  meta,\n  renamed,\n}: {\n  filePath: string;\n  meta: ProjectRenderMeta;\n  renamed: Map<string, string>;\n}) => {\n  let content = fs.readFileSync(filePath, 'utf8');\n\n  content = content.replace(\n    /from\\s+['\"](\\.\\.?\\/[^'\"]*?)['\"]/g,\n    (match, importPath) => {\n      const importIndex = match.indexOf(importPath);\n      const extension = path.extname(importPath);\n      const fileName = path.basename(importPath, extension);\n      const importDir = path.dirname(importPath);\n      const replacedName =\n        (renamed.get(fileName) ?? fileName) +\n        (meta.importFileExtension ? meta.importFileExtension : extension);\n      const replacedMatch =\n        match.slice(0, importIndex) +\n        [importDir, replacedName].filter(Boolean).join('/') +\n        match.slice(importIndex + importPath.length);\n      return replacedMatch;\n    },\n  );\n\n  const header = '// This file is auto-generated by @hey-api/openapi-ts\\n\\n';\n\n  content = `${header}${content}`;\n\n  fs.writeFileSync(filePath, content, 'utf8');\n};\n\n/**\n * Creates a `client` folder containing the same modules as the client package.\n */\nexport const generateClientBundle = ({\n  meta,\n  outputPath,\n  plugin,\n  project,\n}: {\n  meta: ProjectRenderMeta;\n  outputPath: string;\n  plugin: DefinePlugin<Client.Config & { name: string }>['Config'];\n  project?: IProject;\n}): Map<string, string> | undefined => {\n  const renamed = new Map<string, string>();\n\n  // copy Hey API clients to output\n  const isHeyApiClientPlugin = plugin.name.startsWith('@hey-api/client-');\n  if (isHeyApiClientPlugin) {\n    // copy client core\n    const coreOutputPath = path.resolve(outputPath, 'core');\n    ensureDirSync(coreOutputPath);\n    const coreDistPath = path.resolve(__dirname, 'clients', 'core');\n    copyRecursivePnP(coreDistPath, coreOutputPath);\n\n    // copy client bundle\n    const clientOutputPath = path.resolve(outputPath, 'client');\n    ensureDirSync(clientOutputPath);\n    const clientDistFolderName = plugin.name.slice('@hey-api/client-'.length);\n    const clientDistPath = path.resolve(\n      __dirname,\n      'clients',\n      clientDistFolderName,\n    );\n    copyRecursivePnP(clientDistPath, clientOutputPath);\n\n    if (project) {\n      const copiedCoreFiles = fs.readdirSync(coreOutputPath);\n      for (const file of copiedCoreFiles) {\n        renameFile({\n          filePath: path.resolve(coreOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n\n      const copiedClientFiles = fs.readdirSync(clientOutputPath);\n      for (const file of copiedClientFiles) {\n        renameFile({\n          filePath: path.resolve(clientOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n    }\n\n    const coreFiles = fs.readdirSync(coreOutputPath);\n    for (const file of coreFiles) {\n      replaceImports({\n        filePath: path.resolve(coreOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n\n    const clientFiles = fs.readdirSync(clientOutputPath);\n    for (const file of clientFiles) {\n      replaceImports({\n        filePath: path.resolve(clientOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n    return renamed;\n  }\n\n  const clientSrcPath = path.isAbsolute(plugin.name)\n    ? path.dirname(plugin.name)\n    : undefined;\n\n  // copy custom local client to output\n  if (clientSrcPath) {\n    const dirPath = path.resolve(outputPath, 'client');\n    ensureDirSync(dirPath);\n    copyRecursivePnP(clientSrcPath, dirPath);\n    return;\n  }\n\n  // copy third-party client to output\n  const clientModulePath = path.normalize(require.resolve(plugin.name));\n  const clientModulePathComponents = clientModulePath.split(path.sep);\n  const clientDistPath = clientModulePathComponents\n    .slice(0, clientModulePathComponents.indexOf('dist') + 1)\n    .join(path.sep);\n\n  const indexJsFile =\n    clientModulePathComponents[clientModulePathComponents.length - 1];\n  const distFiles = [indexJsFile!, 'index.d.mts', 'index.d.cts'];\n  const dirPath = path.resolve(outputPath, 'client');\n  ensureDirSync(dirPath);\n  for (const file of distFiles) {\n    fs.copyFileSync(\n      path.resolve(clientDistPath, file),\n      path.resolve(dirPath, file),\n    );\n  }\n\n  return;\n};\n","const parseUrlRegExp =\n  /^(([^:/?#]+):)?((\\/\\/)?([^:/?#]*)(:?([^/?#]*)))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\ninterface Url {\n  host: string;\n  path: string;\n  port: string;\n  protocol: string;\n}\n\nexport const parseUrl = (value: string): Url => {\n  const errorResponse: Url = {\n    host: '',\n    path: '',\n    port: '',\n    protocol: '',\n  };\n\n  parseUrlRegExp.lastIndex = 0;\n  const match = value.match(parseUrlRegExp);\n\n  if (!match) {\n    return errorResponse;\n  }\n\n  const host = match[5] || '';\n\n  // value is a relative file system path\n  if (host === '.' || host === '..') {\n    return errorResponse;\n  }\n\n  const path = match[8] || '';\n  const protocol = match[2] || '';\n\n  // value is probably a Windows file system path\n  if (protocol.length === 1) {\n    return errorResponse;\n  }\n\n  return {\n    host,\n    path: path === '/' ? '' : path,\n    port: match[7] || '',\n    protocol,\n  };\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { $ } from '~/ts-dsl';\nimport { parseUrl } from '~/utils/url';\n\nimport type { PluginHandler } from './types';\nimport { getClientBaseUrlKey } from './utils';\n\nconst resolveBaseUrlString = ({\n  plugin,\n}: Parameters<PluginHandler>[0]): string | undefined => {\n  const { baseUrl } = plugin.config;\n\n  if (baseUrl === false) {\n    return;\n  }\n\n  if (typeof baseUrl === 'string') {\n    return baseUrl;\n  }\n\n  const { servers } = plugin.context.ir;\n\n  if (!servers) {\n    return;\n  }\n\n  return servers[typeof baseUrl === 'number' ? baseUrl : 0]?.url;\n};\n\nexport const createClient: PluginHandler = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolCreateClient = plugin.registerSymbol({\n    external: clientModule,\n    name: 'createClient',\n  });\n  const symbolCreateConfig = plugin.registerSymbol({\n    external: clientModule,\n    name: 'createConfig',\n  });\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n\n  const { runtimeConfigPath } = plugin.config;\n  const symbolCreateClientConfig = runtimeConfigPath\n    ? plugin.registerSymbol({\n        external: runtimeConfigPath,\n        name: 'createClientConfig',\n      })\n    : undefined;\n\n  const defaultVals = $.object();\n\n  const resolvedBaseUrl = resolveBaseUrlString({\n    plugin: plugin as any,\n  });\n  if (resolvedBaseUrl) {\n    const url = parseUrl(resolvedBaseUrl);\n    if (url.protocol && url.host && !resolvedBaseUrl.includes('{')) {\n      defaultVals.prop(\n        getClientBaseUrlKey(plugin.context.config),\n        $.literal(resolvedBaseUrl),\n      );\n    } else if (resolvedBaseUrl !== '/' && resolvedBaseUrl.startsWith('/')) {\n      const baseUrl = resolvedBaseUrl.endsWith('/')\n        ? resolvedBaseUrl.slice(0, -1)\n        : resolvedBaseUrl;\n      defaultVals.prop(\n        getClientBaseUrlKey(plugin.context.config),\n        $.literal(baseUrl),\n      );\n    }\n  }\n\n  if ('throwOnError' in plugin.config && plugin.config.throwOnError) {\n    defaultVals.prop('throwOnError', $.literal(true));\n  }\n\n  const createConfigParameters = [\n    $(symbolCreateConfig.placeholder)\n      .call(defaultVals.hasProps() ? defaultVals : undefined)\n      .generic(symbolClientOptions.placeholder),\n  ];\n\n  const symbolClient = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'client',\n    },\n    name: 'client',\n  });\n  const statement = $.const(symbolClient.placeholder)\n    .export(symbolClient.exported)\n    .assign(\n      $(symbolCreateClient.placeholder).$if(\n        symbolCreateClientConfig,\n        (c, s) => c.call($(s.placeholder).call(...createConfigParameters)),\n        (c) => c.call(...createConfigParameters),\n      ),\n    );\n  plugin.setSymbolValue(symbolClient, statement);\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { $ } from '~/ts-dsl';\n\nimport type { PluginHandler } from './types';\n\nexport const createClientConfigType = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n  const symbolConfig = plugin.registerSymbol({\n    external: clientModule,\n    kind: 'type',\n    name: 'Config',\n  });\n  const symbolDefaultClientOptions = plugin.registerSymbol({\n    external: clientModule,\n    kind: 'type',\n    name: 'ClientOptions',\n  });\n  const symbolCreateClientConfig = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    name: 'CreateClientConfig',\n  });\n\n  const typeCreateClientConfig = $.type\n    .alias(symbolCreateClientConfig.placeholder)\n    .export(symbolCreateClientConfig.exported)\n    .doc([\n      'The `createClientConfig()` function will be called on client initialization',\n      \"and the returned object will become the client's initial configuration.\",\n      '',\n      'You may want to initialize your client this way instead of calling',\n      \"`setConfig()`. This is useful for example if you're using Next.js\",\n      'to ensure your client always has the correct values.',\n    ])\n    .generic('T', (g) =>\n      g\n        .extends(symbolDefaultClientOptions.placeholder)\n        .default(symbolClientOptions.placeholder),\n    )\n    .type(\n      $.type\n        .func()\n        .param('override', (p) =>\n          p\n            .optional()\n            .type(\n              $.type(symbolConfig.placeholder).generic(\n                $.type.and(symbolDefaultClientOptions.placeholder, 'T'),\n              ),\n            ),\n        )\n        .returns(\n          $.type(symbolConfig.placeholder).generic(\n            $.type.and(\n              $.type('Required').generic(\n                symbolDefaultClientOptions.placeholder,\n              ),\n              'T',\n            ),\n          ),\n        ),\n    );\n  plugin.setSymbolValue(symbolCreateClientConfig, typeCreateClientConfig);\n};\n","import { createClient } from './client';\nimport { createClientConfigType } from './createClientConfig';\nimport type { PluginHandler } from './types';\n\nexport const clientPluginHandler = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  createClientConfigType({ plugin });\n  createClient({ plugin });\n};\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientAngularPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAngularPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-angular',\n};\n\n/**\n * Type helper for `@hey-api/client-angular` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientAxiosPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAxiosPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-axios',\n};\n\n/**\n * Type helper for `@hey-api/client-axios` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientFetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientFetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-fetch',\n};\n\n/**\n * Type helper for `@hey-api/client-fetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientKyPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientKyPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ky',\n};\n\n/**\n * Type helper for `@hey-api/client-ky` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientNextPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNextPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-next',\n};\n\n/**\n * Type helper for `@hey-api/client-next` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientNuxtPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNuxtPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: clientDefaultConfig,\n  handler: clientPluginHandler,\n  name: '@hey-api/client-nuxt',\n};\n\n/**\n * Type helper for `@hey-api/client-nuxt` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientOfetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientOfetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ofetch',\n};\n\n/**\n * Type helper for `@hey-api/client-ofetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { RangeOptions, SemVer } from 'semver';\nimport * as semver from 'semver';\n\nexport type Package = {\n  /**\n   * Get the installed version of a package.\n   * @param name The name of the package to get the version for.\n   * @returns A SemVer object containing version information, or undefined if the package is not installed\n   *         or the version string is invalid.\n   */\n  getVersion: (name: string) => SemVer | undefined;\n  /**\n   * Check if a given package is installed in the project.\n   * @param name The name of the package to check.\n   */\n  isInstalled: (name: string) => boolean;\n  /**\n   * Check if the installed version of a package or a given SemVer object satisfies a semver range.\n   * @param nameOrVersion The name of the package to check, or a SemVer object.\n   * @param range The semver range to check against.\n   * @returns True if the version satisfies the range, false otherwise.\n   */\n  satisfies: (\n    nameOrVersion: string | SemVer,\n    range: string,\n    optionsOrLoose?: boolean | RangeOptions,\n  ) => boolean;\n};\n\nexport const satisfies: typeof semver.satisfies = (...args) =>\n  semver.satisfies(...args);\n\nexport const packageFactory = (\n  dependencies: Record<string, string>,\n): Package => ({\n  getVersion: (name) => {\n    const version = dependencies[name];\n    if (!version) return;\n    try {\n      let parsed = semver.parse(version);\n      if (parsed) return parsed;\n\n      const min = semver.minVersion(version);\n      if (min) return min;\n\n      parsed = semver.coerce(version);\n      if (parsed) return parsed;\n    } catch {\n      // noop\n    }\n    return;\n  },\n  isInstalled: (name) => Boolean(dependencies[name]),\n  satisfies: (nameOrVersion, range, optionsOrLoose) => {\n    const version =\n      typeof nameOrVersion === 'string'\n        ? dependencies[nameOrVersion]\n        : nameOrVersion;\n    return version ? satisfies(version, range, optionsOrLoose) : false;\n  },\n});\n","import {\n  illegalStartCharactersRegExp,\n  reservedBrowserGlobalsRegExp,\n  reservedJavaScriptGlobalsRegExp,\n  reservedJavaScriptKeywordsRegExp,\n  reservedNodeGlobalsRegExp,\n  reservedTypeScriptKeywordsRegExp,\n} from '~/utils/regexp';\n\nconst regexps = [\n  reservedJavaScriptKeywordsRegExp,\n  reservedTypeScriptKeywordsRegExp,\n  reservedJavaScriptGlobalsRegExp,\n  reservedNodeGlobalsRegExp,\n  reservedBrowserGlobalsRegExp,\n];\n\nexport const ensureValidIdentifier = (name: string): string => {\n  let identifier = name.replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '_');\n\n  illegalStartCharactersRegExp.lastIndex = 0;\n  if (illegalStartCharactersRegExp.test(identifier)) {\n    return `_${identifier}`;\n  }\n\n  for (const regexp of regexps) {\n    if (identifier.startsWith('_')) {\n      return identifier;\n    }\n\n    identifier = identifier.replace(regexp, '_$1');\n  }\n\n  return identifier;\n};\n","import { satisfies } from '~/config/utils/package';\nimport type { Context } from '~/ir/context';\nimport type { OpenApiV2_0_XTypes } from '~/openApi/2.0.x';\nimport type { OpenApiV3_0_XTypes } from '~/openApi/3.0.x';\nimport type { OpenApiV3_1_XTypes } from '~/openApi/3.1.x';\nimport { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';\nimport type { OpenApi } from '~/openApi/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiSchemasPlugin } from './types';\n\nconst stripSchema = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}) => {\n  if (plugin.config.type === 'form') {\n    if (schema.description) {\n      delete schema.description;\n    }\n\n    if (schema['x-enum-descriptions']) {\n      delete schema['x-enum-descriptions'];\n    }\n\n    if (schema['x-enum-varnames']) {\n      delete schema['x-enum-varnames'];\n    }\n\n    if (schema['x-enumNames']) {\n      delete schema['x-enumNames'];\n    }\n\n    if (schema.title) {\n      delete schema.title;\n    }\n  }\n};\n\nconst schemaToJsonSchemaDraft_04 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV2_0_XTypes['SchemaObject'];\n}): OpenApiV2_0_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV2_0_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.items as OpenApiV2_0_XTypes['SchemaObject'],\n    });\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_04({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchemaDraft_05 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject'];\n}):\n  | OpenApiV3_0_XTypes['SchemaObject']\n  | OpenApiV3_0_XTypes['ReferenceObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as\n      | OpenApiV3_0_XTypes['SchemaObject']\n      | OpenApiV3_0_XTypes['ReferenceObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if ('$ref' in schema) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_05({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchema2020_12 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV3_1_XTypes['SchemaObject'];\n}): OpenApiV3_1_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as OpenApiV3_1_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  stripSchema({ plugin, schema });\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n  }\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.prefixItems) {\n    schema.prefixItems = schema.prefixItems.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchema2020_12({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaName = ({\n  name,\n  plugin,\n  schema,\n}: {\n  name: string;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}): string => {\n  let customName = '';\n\n  if (plugin.config.nameBuilder) {\n    if (typeof plugin.config.nameBuilder === 'function') {\n      customName = plugin.config.nameBuilder(name, schema);\n    } else {\n      customName = plugin.config.nameBuilder.replace('{{name}}', name);\n    }\n  }\n\n  if (!customName) {\n    customName = `${name}Schema`;\n  }\n\n  return ensureValidIdentifier(customName);\n};\n\nconst schemasV2_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V2_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.definitions) {\n    return;\n  }\n\n  for (const name in context.spec.definitions) {\n    const schema = context.spec.definitions[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n      name: schemaName({ name, plugin, schema }),\n    });\n    const obj = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol.placeholder)\n      .export(symbol.exported)\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nconst schemasV3_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n      name: schemaName({ name, plugin, schema }),\n    });\n    const obj = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol.placeholder)\n      .export(symbol.exported)\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nconst schemasV3_1_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_1_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n      name: schemaName({ name, plugin, schema }),\n    });\n    const obj = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol.placeholder)\n      .export(symbol.exported)\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.setSymbolValue(symbol, statement);\n  }\n};\n\nexport const handler: HeyApiSchemasPlugin['Handler'] = ({ plugin }) => {\n  if ('swagger' in plugin.context.spec) {\n    schemasV2_0_X({\n      context: plugin.context as Context<OpenApi.V2_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    schemasV3_0_X({\n      context: plugin.context as Context<OpenApi.V3_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.1.0')) {\n    schemasV3_1_X({\n      context: plugin.context as Context<OpenApi.V3_1_X>,\n      plugin,\n    });\n    return;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { HeyApiSchemasPlugin } from './types';\n\nexport const defaultConfig: HeyApiSchemasPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n    nameBuilder: (name) => `${name}Schema`,\n    type: 'json',\n  },\n  handler,\n  name: '@hey-api/schemas',\n};\n\n/**\n * Type helper for `@hey-api/schemas` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport {\n  operationClasses,\n  operationParameters,\n  operationStatements,\n} from './operation';\n\ntype SdkClassEntry = {\n  /**\n   * Name of the class.\n   */\n  className: string;\n  /**\n   * Class names for child classes located inside this class.\n   */\n  classes: Set<string>;\n  /**\n   * Symbol ID for the class.\n   */\n  id: number;\n  /**\n   * Track unique added method nodes.\n   */\n  methods: Set<string>;\n  /**\n   * List of class nodes containing methods.\n   */\n  nodes: Array<TsDsl>;\n  /**\n   * Is this a root class?\n   */\n  root: boolean;\n};\n\nexport const registryName = '__registry';\n\nconst createRegistryClass = ({\n  sdkName,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  sdkName: string;\n  symbol: Symbol;\n}): TsDsl => {\n  const defaultKey = 'defaultKey';\n  const instances = 'instances';\n  return $.class(symbol.placeholder)\n    .export(symbol.exported)\n    .generic('T')\n    .field(defaultKey, (f) =>\n      f.private().readonly().assign($.literal('default')),\n    )\n    .newline()\n    .field(instances, (f) =>\n      f\n        .private()\n        .readonly()\n        .type($.type('Map').generics('string', 'T'))\n        .assign($.new('Map')),\n    )\n    .newline()\n    .method('get', (m) =>\n      m\n        .returns('T')\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $.const('instance').assign(\n            $('this')\n              .attr('instances')\n              .attr('get')\n              .call($('key').coalesce($('this').attr(defaultKey))),\n          ),\n          $.if($.not('instance')).do(\n            $.throw('Error').message(\n              $.template('No SDK client found. Create one with \"new ')\n                .add(sdkName)\n                .add('()\" to fix this error.'),\n            ),\n          ),\n          $.return('instance'),\n        ),\n    )\n    .newline()\n    .method('set', (m) =>\n      m\n        .returns('void')\n        .param('value', (p) => p.type('T'))\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $('this')\n            .attr(instances)\n            .attr('set')\n            .call($('key').coalesce($('this').attr(defaultKey)), 'value'),\n        ),\n    );\n};\n\nconst createClientClass = ({\n  plugin,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  symbol: Symbol;\n}): TsDsl => {\n  const symClient = plugin.getSymbol({\n    category: 'client',\n  });\n  const optionalClient = Boolean(plugin.config.client && symClient);\n  const symbolClient = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'client.Client',\n  });\n  return $.class(symbol.placeholder)\n    .export(symbol.exported)\n    .field('client', (f) => f.protected().type(symbolClient.placeholder))\n    .newline()\n    .init((i) =>\n      i\n        .param('args', (p) =>\n          p\n            .optional(optionalClient)\n            .type(\n              $.type\n                .object()\n                .prop('client', (p) =>\n                  p.optional(optionalClient).type(symbolClient.placeholder),\n                ),\n            ),\n        )\n        .do(\n          $('this')\n            .attr('client')\n            .assign(\n              $('args')\n                .attr('client')\n                .optional(optionalClient)\n                .$if(optionalClient, (a) => a.coalesce(symClient!.placeholder)),\n            ),\n        ),\n    );\n};\n\nexport const generateClassSdk = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}): void => {\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const sdkClasses = new Map<string, SdkClassEntry>();\n  /**\n   * Track unique added classes.\n   */\n  const generatedClasses = new Set<string>();\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n      const symbolResponse = isNuxtClient\n        ? plugin.querySymbol({\n            category: 'type',\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n          })\n        : undefined;\n\n      const classes = operationClasses({\n        context: plugin.context,\n        operation,\n        plugin,\n      });\n\n      for (const entry of classes.values()) {\n        entry.path.forEach((currentClassName, index) => {\n          const symbolCurrentClass = plugin.referenceSymbol({\n            category: 'utility',\n            resource: 'class',\n            resourceId: currentClassName,\n            tool: 'sdk',\n          });\n          if (!sdkClasses.has(symbolCurrentClass.meta!.resourceId!)) {\n            sdkClasses.set(symbolCurrentClass.meta!.resourceId!, {\n              className: symbolCurrentClass.meta!.resourceId!,\n              classes: new Set(),\n              id: symbolCurrentClass.id,\n              methods: new Set(),\n              nodes: [],\n              root: !index,\n            });\n          }\n\n          const parentClassName = entry.path[index - 1];\n          if (parentClassName) {\n            const symbolParentClass = plugin.referenceSymbol({\n              category: 'utility',\n              resource: 'class',\n              resourceId: parentClassName,\n              tool: 'sdk',\n            });\n            if (\n              symbolParentClass.meta?.resourceId !==\n              symbolCurrentClass.meta?.resourceId\n            ) {\n              const parentClass = sdkClasses.get(\n                symbolParentClass.meta!.resourceId!,\n              )!;\n              parentClass.classes.add(symbolCurrentClass.meta!.resourceId!);\n              sdkClasses.set(symbolParentClass.meta!.resourceId!, parentClass);\n            }\n          }\n\n          const isLast = entry.path.length === index + 1;\n          // add methods only to the last class\n          if (!isLast) {\n            return;\n          }\n\n          const currentClass = sdkClasses.get(\n            symbolCurrentClass.meta!.resourceId!,\n          )!;\n\n          // avoid duplicate methods\n          if (currentClass.methods.has(entry.methodName)) {\n            return;\n          }\n\n          const opParameters = operationParameters({\n            isRequiredOptions,\n            operation,\n            plugin,\n          });\n          const statements = operationStatements({\n            isRequiredOptions,\n            opParameters,\n            operation,\n            plugin,\n          });\n          const functionNode = $.method(entry.methodName, (m) =>\n            m\n              .$if(createOperationComment(operation), (m, v) => m.doc(v))\n              .public()\n              .static(!isAngularClient && !plugin.config.instance)\n              .$if(\n                isNuxtClient,\n                (m) =>\n                  m\n                    .generic(nuxtTypeComposable, (t) =>\n                      t\n                        .extends(\n                          plugin.referenceSymbol({\n                            category: 'external',\n                            resource: 'client.Composable',\n                          }).placeholder,\n                        )\n                        .default($.type.literal('$fetch')),\n                    )\n                    .generic(nuxtTypeDefault, (t) =>\n                      t.$if(symbolResponse, (t, s) =>\n                        t.extends(s.placeholder).default(s.placeholder),\n                      ),\n                    ),\n                (m) =>\n                  m.generic('ThrowOnError', (t) =>\n                    t\n                      .extends('boolean')\n                      .default(\n                        ('throwOnError' in client.config\n                          ? client.config.throwOnError\n                          : false) ?? false,\n                      ),\n                  ),\n              )\n              .params(...opParameters.parameters)\n              .do(...statements),\n          );\n\n          if (!currentClass.nodes.length) {\n            currentClass.nodes.push(functionNode);\n          } else {\n            currentClass.nodes.push($.newline(), functionNode);\n          }\n\n          currentClass.methods.add(entry.methodName);\n\n          sdkClasses.set(symbolCurrentClass.meta!.resourceId!, currentClass);\n        });\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const symbolHeyApiClient = plugin.config.instance\n    ? plugin.registerSymbol({\n        exported: false,\n        kind: 'class',\n        meta: {\n          category: 'utility',\n          resource: 'class',\n          resourceId: 'HeyApiClient',\n          tool: 'sdk',\n        },\n        name: 'HeyApiClient',\n      })\n    : undefined;\n  const symbolHeyApiRegistry = plugin.config.instance\n    ? plugin.registerSymbol({\n        exported: false,\n        kind: 'class',\n        meta: {\n          category: 'utility',\n          resource: 'class',\n          resourceId: 'HeyApiRegistry',\n          tool: 'sdk',\n        },\n        name: 'HeyApiRegistry',\n      })\n    : undefined;\n\n  const generateClass = (currentClass: SdkClassEntry) => {\n    if (generatedClasses.has(currentClass.className)) {\n      return;\n    }\n\n    const resourceId = currentClass.className;\n    generatedClasses.add(resourceId);\n\n    if (currentClass.classes.size) {\n      for (const childClassName of currentClass.classes) {\n        const childClass = sdkClasses.get(childClassName)!;\n        generateClass(childClass);\n\n        const refChildClass = plugin.referenceSymbol({\n          category: 'utility',\n          resource: 'class',\n          resourceId: childClass.className,\n          tool: 'sdk',\n        });\n\n        const originalMemberName = stringCase({\n          case: 'camelCase',\n          value: refChildClass.meta!.resourceId!,\n        });\n        // avoid collisions with existing method names\n        let memberName = originalMemberName;\n        if (currentClass.methods.has(memberName)) {\n          let index = 2;\n          let attempt = `${memberName}${index}`;\n          while (currentClass.methods.has(attempt)) {\n            attempt = `${memberName}${index++}`;\n          }\n          memberName = attempt;\n        }\n        currentClass.methods.add(memberName);\n\n        const subClassReferenceNode = plugin.isSymbolRegistered(\n          refChildClass.id,\n        )\n          ? $.field(memberName, (f) =>\n              f\n                .static(!plugin.config.instance)\n                .assign(\n                  plugin.config.instance\n                    ? $.new(refChildClass.placeholder).args(\n                        $.object().prop('client', $('this').attr('client')),\n                      )\n                    : $(refChildClass.placeholder),\n                ),\n            )\n          : $.getter(memberName, (g) =>\n              g\n                .$if(!plugin.config.instance, (g) => g.public().static())\n                .do(\n                  $.return(\n                    plugin.config.instance\n                      ? $.new(refChildClass.placeholder).args(\n                          $.object().prop('client', $('this').attr('client')),\n                        )\n                      : refChildClass.placeholder,\n                  ),\n                ),\n            );\n\n        if (!currentClass.nodes.length) {\n          currentClass.nodes.push(subClassReferenceNode);\n        } else {\n          currentClass.nodes.push($.newline(), subClassReferenceNode);\n        }\n      }\n    }\n\n    if (\n      symbolHeyApiClient &&\n      !plugin.gen.symbols.hasValue(symbolHeyApiClient.id)\n    ) {\n      const node = createClientClass({\n        plugin,\n        symbol: symbolHeyApiClient,\n      });\n      plugin.setSymbolValue(symbolHeyApiClient, node);\n    }\n\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      kind: 'class',\n      meta: {\n        category: 'utility',\n        resource: 'class',\n        resourceId,\n        tool: 'sdk',\n      },\n      name: resourceId,\n    });\n\n    if (currentClass.root && symbolHeyApiRegistry) {\n      const symClient = plugin.getSymbol({\n        category: 'client',\n      });\n      const isClientRequired = !plugin.config.client || !symClient;\n      const symbolClient = plugin.referenceSymbol({\n        category: 'external',\n        resource: 'client.Client',\n      });\n      const ctor = $.init((i) =>\n        i\n          .param('args', (p) =>\n            p.required(isClientRequired).type(\n              $.type\n                .object()\n                .prop('client', (p) =>\n                  p.required(isClientRequired).type(symbolClient.placeholder),\n                )\n                .prop('key', (p) => p.optional().type('string')),\n            ),\n          )\n          .do(\n            $('super').call('args'),\n            $(symbol.placeholder)\n              .attr(registryName)\n              .attr('set')\n              .call('this', $('args').attr('key').required(isClientRequired)),\n          ),\n      );\n\n      if (!currentClass.nodes.length) {\n        currentClass.nodes.unshift(ctor);\n      } else {\n        currentClass.nodes.unshift(ctor, $.newline());\n      }\n\n      const node = createRegistryClass({\n        plugin,\n        sdkName: symbol.placeholder,\n        symbol: symbolHeyApiRegistry,\n      });\n      plugin.setSymbolValue(symbolHeyApiRegistry, node);\n      const registryNode = $.field(registryName, (f) =>\n        f\n          .public()\n          .static()\n          .readonly()\n          .assign(\n            $.new(symbolHeyApiRegistry.placeholder).generic(symbol.placeholder),\n          ),\n      );\n      currentClass.nodes.unshift(registryNode, $.newline());\n    }\n\n    const node = $.class(symbol.placeholder)\n      .export(symbol.exported)\n      .extends(symbolHeyApiClient?.placeholder)\n      .$if(currentClass.root && isAngularClient, (c) =>\n        c.decorator(\n          plugin.referenceSymbol({\n            category: 'external',\n            resource: '@angular/core.Injectable',\n          }).placeholder,\n          $.object().prop('providedIn', $.literal('root')),\n        ),\n      )\n      .do(...currentClass.nodes);\n    plugin.setSymbolValue(symbol, node);\n  };\n\n  for (const sdkClass of sdkClasses.values()) {\n    generateClass(sdkClass);\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { reservedJavaScriptKeywordsRegExp } from '~/utils/regexp';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { operationParameters, operationStatements } from './operation';\n\nconst serviceFunctionIdentifier = ({\n  id,\n  operation,\n  plugin,\n}: {\n  id: string;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}) => {\n  if (plugin.config.methodNameBuilder) {\n    return plugin.config.methodNameBuilder(operation);\n  }\n\n  if (id.match(reservedJavaScriptKeywordsRegExp)) {\n    return `${id}_`;\n  }\n\n  return id;\n};\n\nexport const generateFlatSdk = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}): void => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  plugin.forEach(\n    'operation',\n    (event) => {\n      const { operation } = event;\n      const isRequiredOptions = isOperationOptionsRequired({\n        context: plugin.context,\n        operation,\n      });\n      const symbolResponse = isNuxtClient\n        ? plugin.querySymbol({\n            category: 'type',\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n          })\n        : undefined;\n      const opParameters = operationParameters({\n        isRequiredOptions,\n        operation,\n        plugin,\n      });\n      const statements = operationStatements({\n        isRequiredOptions,\n        opParameters,\n        operation,\n        plugin,\n      });\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        meta: {\n          category: 'sdk',\n          path: event._path,\n          resource: 'operation',\n          resourceId: operation.id,\n          tags: event.tags,\n          tool: 'sdk',\n        },\n        name: serviceFunctionIdentifier({\n          id: operation.id,\n          operation,\n          plugin,\n        }),\n      });\n      const node = $.const(symbol.placeholder)\n        .export(symbol.exported)\n        .$if(createOperationComment(operation), (c, v) => c.doc(v))\n        .assign(\n          $.func()\n            .params(...opParameters.parameters)\n            .$if(\n              isNuxtClient,\n              (f) =>\n                f\n                  .generic(nuxtTypeComposable, (g) =>\n                    g\n                      .extends(\n                        plugin.referenceSymbol({\n                          category: 'external',\n                          resource: 'client.Composable',\n                        }).placeholder,\n                      )\n                      .default($.type.literal('$fetch')),\n                  )\n                  .generic(nuxtTypeDefault, (g) =>\n                    g.$if(\n                      symbolResponse,\n                      (t, s) => t.extends(s.placeholder).default(s.placeholder),\n                      (t) => t.default('undefined'),\n                    ),\n                  ),\n              (f) =>\n                f.generic('ThrowOnError', (g) =>\n                  g\n                    .extends('boolean')\n                    .default(\n                      ('throwOnError' in client.config\n                        ? client.config.throwOnError\n                        : false) ?? false,\n                    ),\n                ),\n            )\n            .do(...statements),\n        );\n      plugin.setSymbolValue(symbol, node);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { nuxtTypeDefault, nuxtTypeResponse } from './constants';\n\nexport const createTypeOptions = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolTDataShape = plugin.registerSymbol({\n    external: clientModule,\n    kind: 'type',\n    name: 'TDataShape',\n  });\n  const symbolClient = plugin.registerSymbol({\n    external: clientModule,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'client.Client',\n      tool: client.name,\n    },\n    name: 'Client',\n  });\n  const symbolClientOptions = plugin.registerSymbol({\n    external: clientModule,\n    kind: 'type',\n    name: 'Options',\n  });\n  const symbolOptions = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'client-options',\n      tool: 'sdk',\n    },\n    name: 'Options',\n  });\n\n  const typeOptions = $.type\n    .alias(symbolOptions.placeholder)\n    .export(symbolOptions.exported)\n    .$if(\n      isNuxtClient,\n      (t) =>\n        t\n          .generic('TComposable', (g) =>\n            g\n              .extends(\n                plugin.referenceSymbol({\n                  category: 'external',\n                  resource: 'client.Composable',\n                }).placeholder,\n              )\n              .default($.type.literal('$fetch')),\n          )\n          .generic('TData', (g) =>\n            g\n              .extends(symbolTDataShape.placeholder)\n              .default(symbolTDataShape.placeholder),\n          )\n          .generic(nuxtTypeResponse, (g) => g.default('unknown'))\n          .generic(nuxtTypeDefault, (g) => g.default('undefined')),\n      (t) =>\n        t\n          .generic('TData', (g) =>\n            g\n              .extends(symbolTDataShape.placeholder)\n              .default(symbolTDataShape.placeholder),\n          )\n          .generic('ThrowOnError', (g) =>\n            g.extends('boolean').default('boolean'),\n          ),\n    )\n    .type(\n      $.type.and(\n        $.type(symbolClientOptions.placeholder).$if(\n          isNuxtClient,\n          (t) =>\n            t\n              .generic('TComposable')\n              .generic('TData')\n              .generic(nuxtTypeResponse)\n              .generic(nuxtTypeDefault),\n          (t) => t.generic('TData').generic('ThrowOnError'),\n        ),\n        $.type\n          .object()\n          .prop('client', (p) =>\n            p\n              .doc([\n                'You can provide a client instance returned by `createClient()` instead of',\n                'individual options. This might be also useful if you want to implement a',\n                'custom client.',\n              ])\n              .required(!plugin.config.client && !plugin.config.instance)\n              .type(symbolClient.placeholder),\n          )\n          .prop('meta', (p) =>\n            p\n              .doc([\n                'You can pass arbitrary values through the `meta` object. This can be',\n                \"used to access values that aren't defined as part of the SDK function.\",\n              ])\n              .optional()\n              .type($.type('Record').generics('string', 'unknown')),\n          ),\n      ),\n    );\n  plugin.setSymbolValue(symbolOptions, typeOptions);\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\n\nimport { generateClassSdk } from '../shared/class';\nimport { generateFlatSdk } from '../shared/functions';\nimport { createTypeOptions } from '../shared/typeOptions';\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport const handlerV1: HeyApiSdkPlugin['Handler'] = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.formDataBodySerializer',\n      tool: client.name,\n    },\n    name: 'formDataBodySerializer',\n  });\n  plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.urlSearchParamsBodySerializer',\n      tool: client.name,\n    },\n    name: 'urlSearchParamsBodySerializer',\n  });\n  plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.buildClientParams',\n      tool: client.name,\n    },\n    name: 'buildClientParams',\n  });\n  if (isNuxtClient) {\n    plugin.registerSymbol({\n      external: clientModule,\n      kind: 'type',\n      meta: {\n        category: 'external',\n        resource: 'client.Composable',\n        tool: client.name,\n      },\n      name: 'Composable',\n    });\n  }\n  if (isAngularClient && plugin.config.asClass) {\n    plugin.registerSymbol({\n      external: '@angular/core',\n      meta: {\n        category: 'external',\n        resource: '@angular/core.Injectable',\n      },\n      name: 'Injectable',\n    });\n  }\n\n  createTypeOptions({ plugin });\n\n  if (plugin.config.asClass) {\n    generateClassSdk({ plugin });\n  } else {\n    generateFlatSdk({ plugin });\n  }\n};\n","import type { HeyApiSdkPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiSdkPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { HeyApiSdkPlugin } from './types';\n\nexport const defaultConfig: HeyApiSdkPlugin['Config'] = {\n  config: {\n    asClass: false,\n    auth: true,\n    classNameBuilder: '{{name}}',\n    classStructure: 'auto',\n    client: true,\n    exportFromIndex: true,\n    instance: false,\n    operationId: true,\n    paramsStructure: 'grouped',\n    response: 'body',\n    responseStyle: 'fields',\n    transformer: false,\n    validator: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/sdk',\n  resolveConfig: (plugin, context) => {\n    if (plugin.config.client) {\n      if (typeof plugin.config.client === 'boolean') {\n        plugin.config.client = context.pluginByTag('client', {\n          defaultPlugin: '@hey-api/client-fetch',\n        });\n      }\n\n      plugin.dependencies.add(plugin.config.client!);\n    } else {\n      plugin.config.client = false;\n    }\n\n    if (plugin.config.transformer) {\n      if (typeof plugin.config.transformer === 'boolean') {\n        plugin.config.transformer = context.pluginByTag('transformer');\n      }\n\n      plugin.dependencies.add(plugin.config.transformer!);\n    } else {\n      plugin.config.transformer = false;\n    }\n\n    if (typeof plugin.config.validator !== 'object') {\n      plugin.config.validator = {\n        request: plugin.config.validator,\n        response: plugin.config.validator,\n      };\n    }\n\n    if (plugin.config.validator.request) {\n      if (typeof plugin.config.validator.request === 'boolean') {\n        plugin.config.validator.request = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.request!);\n    } else {\n      plugin.config.validator.request = false;\n    }\n\n    if (plugin.config.validator.response) {\n      if (typeof plugin.config.validator.response === 'boolean') {\n        plugin.config.validator.response = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.response!);\n    } else {\n      plugin.config.validator.response = false;\n    }\n\n    if (plugin.config.instance) {\n      if (typeof plugin.config.instance !== 'string') {\n        plugin.config.instance = 'Sdk';\n      }\n\n      plugin.config.asClass = true;\n    } else {\n      plugin.config.instance = false;\n    }\n\n    // Set default classNameBuilder based on client type\n    if (plugin.config.classNameBuilder === '{{name}}') {\n      if (plugin.config.client === '@hey-api/client-angular') {\n        plugin.config.classNameBuilder = '{{name}}Service';\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@hey-api/sdk` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { UserConfig } from './types';\n\nexport type ExpressionTransformer = ({\n  config,\n  dataExpression,\n  schema,\n}: {\n  config: Omit<UserConfig, 'name'>;\n  dataExpression?:\n    | ts.Expression\n    | ReturnType<typeof $.expr | typeof $.attr>\n    | string;\n  schema: IR.SchemaObject;\n}) => Array<ReturnType<typeof $.fromValue>> | undefined;\n\nexport const bigIntExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (schema.type !== 'integer' || schema.format !== 'int64') {\n    return;\n  }\n\n  const bigIntCallExpression =\n    dataExpression !== undefined\n      ? $('BigInt').call($.expr(dataExpression).attr('toString').call())\n      : undefined;\n\n  if (bigIntCallExpression) {\n    if (typeof dataExpression === 'string') {\n      return [bigIntCallExpression];\n    }\n\n    if (dataExpression) {\n      return [$.expr(dataExpression).assign(bigIntCallExpression)];\n    }\n  }\n\n  return;\n};\n\nexport const dateExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (\n    schema.type !== 'string' ||\n    !(schema.format === 'date' || schema.format === 'date-time')\n  ) {\n    return;\n  }\n\n  if (typeof dataExpression === 'string') {\n    return [$.new('Date').arg(dataExpression)];\n  }\n\n  if (dataExpression) {\n    return [$.expr(dataExpression).assign($.new('Date').arg(dataExpression))];\n  }\n\n  return;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { createOperationKey, operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { $ } from '~/ts-dsl';\nimport { TsDsl } from '~/ts-dsl';\nimport { refToName } from '~/utils/ref';\n\nimport type { HeyApiTransformersPlugin } from './types';\n\nconst dataVariableName = 'data';\n\n// Track symbols that are currently being built so recursive references\n// can emit calls to transformers that will be implemented later.\nconst buildingSymbols = new Set<number>();\n\ntype Expr = ReturnType<typeof $.fromValue | typeof $.return | typeof $.if>;\n\nconst ensureStatements = (\n  nodes: Array<Expr | ts.Expression | ts.Statement>,\n): Array<ts.Statement | ReturnType<typeof $.return>> =>\n  nodes.map((node) => $.stmt(node).$render());\n\nconst isNodeReturnStatement = ({\n  node,\n}: {\n  node: ts.Expression | ts.Statement | Expr;\n}) => {\n  if (node instanceof TsDsl) {\n    node = node.$render();\n  }\n  return node.kind === ts.SyntaxKind.ReturnStatement;\n};\n\nconst schemaResponseTransformerNodes = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<ts.Expression | ts.Statement | Expr> => {\n  const nodes = processSchemaType({\n    dataExpression: $(dataVariableName),\n    plugin,\n    schema,\n  });\n  // append return statement if one does not already exist\n  if (nodes.length) {\n    const last = nodes[nodes.length - 1]!;\n    if (!isNodeReturnStatement({ node: last })) {\n      nodes.push($.return(dataVariableName));\n    }\n  }\n  return nodes;\n};\n\nconst processSchemaType = ({\n  dataExpression,\n  plugin,\n  schema,\n}: {\n  dataExpression?:\n    | ts.Expression\n    | string\n    | ReturnType<typeof $.attr | typeof $.expr>;\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<Expr | ts.Expression | ts.Statement> => {\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    };\n\n    let symbol = plugin.getSymbol(query);\n\n    if (!symbol) {\n      // Register a placeholder symbol immediately and set its value to null\n      // as a stop token to prevent infinite recursion for self-referential\n      // schemas. We also mark this symbol as \"building\" so that nested\n      // references to it can emit calls that will be implemented later.\n      symbol = plugin.registerSymbol({\n        meta: query,\n        name: buildName({\n          config: {\n            case: 'camelCase',\n            name: '{{name}}SchemaResponseTransformer',\n          },\n          name: refToName(schema.$ref),\n        }),\n      });\n      plugin.setSymbolValue(symbol, null);\n    }\n\n    // Only compute the implementation if the symbol isn't already being built.\n    // This prevents infinite recursion on self-referential schemas. We still\n    // allow emitting a call when the symbol is currently being built so\n    // parent nodes can reference the transformer that will be emitted later.\n    const existingValue = plugin.gen.symbols.getValue(symbol.id);\n    if (!existingValue && !buildingSymbols.has(symbol.id)) {\n      buildingSymbols.add(symbol.id);\n      try {\n        const refSchema = plugin.context.resolveIrRef<IR.SchemaObject>(\n          schema.$ref,\n        );\n        const nodes = schemaResponseTransformerNodes({\n          plugin,\n          schema: refSchema,\n        });\n\n        if (nodes.length) {\n          const node = $.const(symbol.placeholder).assign(\n            // TODO: parser - add types, generate types without transforms\n            $.func()\n              .param(dataVariableName, (p) => p.type('any'))\n              .do(...ensureStatements(nodes)),\n          );\n          plugin.setSymbolValue(symbol, node);\n        }\n      } finally {\n        buildingSymbols.delete(symbol.id);\n      }\n    }\n\n    // Only emit a call if the symbol has a value (implementation) OR the\n    // symbol is currently being built (recursive reference) ‚Äî in the\n    // latter case we allow emitting a call that will be implemented later.\n    const currentValue = plugin.gen.symbols.getValue(symbol.id);\n    if (currentValue || buildingSymbols.has(symbol.id)) {\n      const ref = plugin.referenceSymbol(query);\n      const callExpression = $(ref.placeholder).call(dataExpression);\n\n      if (dataExpression) {\n        // In a map callback, the item needs to be returned, not just the transformation result\n        if (typeof dataExpression === 'string' && dataExpression === 'item') {\n          return [$.return(callExpression)];\n        }\n\n        return [\n          typeof dataExpression === 'string'\n            ? callExpression\n            : $(dataExpression).assign(callExpression),\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  if (schema.type === 'array') {\n    if (!dataExpression || typeof dataExpression === 'string') {\n      return [];\n    }\n\n    // TODO: parser - handle tuples and complex arrays\n    const nodes = !schema.items\n      ? []\n      : processSchemaType({\n          dataExpression: 'item',\n          plugin,\n          schema: schema.items?.[0]\n            ? schema.items[0]\n            : {\n                ...schema,\n                type: undefined,\n              },\n        });\n\n    if (!nodes.length) {\n      return [];\n    }\n\n    // Ensure the map callback has a return statement for the item\n    const mapCallbackStatements = ensureStatements(nodes);\n    const hasReturnStatement = mapCallbackStatements.some((stmt) =>\n      isNodeReturnStatement({ node: stmt }),\n    );\n\n    if (!hasReturnStatement) {\n      mapCallbackStatements.push($.return('item'));\n    }\n\n    return [\n      $(dataExpression).assign(\n        $(dataExpression)\n          .attr('map')\n          .call(\n            $.func()\n              .param('item', (p) => p.type('any'))\n              .do(...mapCallbackStatements),\n          ),\n      ),\n    ];\n  }\n\n  if (schema.type === 'object') {\n    let nodes: Array<ts.Expression | ts.Statement | Expr> = [];\n    const required = schema.required ?? [];\n\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n      const propertyAccessExpression = $(\n        dataExpression || dataVariableName,\n      ).attr(name);\n      const propertyNodes = processSchemaType({\n        dataExpression: propertyAccessExpression,\n        plugin,\n        schema: property,\n      });\n      if (!propertyNodes.length) {\n        continue;\n      }\n      const noNullableTypesInSchema = !property.items?.find(\n        (x) => x.type === 'null',\n      );\n      const requiredField = required.includes(name);\n      // Cannot fully rely on required fields\n      // Such value has to be present, but it doesn't guarantee that this value is not nullish\n      if (requiredField && noNullableTypesInSchema) {\n        nodes = nodes.concat(propertyNodes);\n      } else {\n        nodes.push(\n          // todo: Probably, it would make more sense to go with if(x !== undefined && x !== null) instead of if(x)\n          // this place influences all underlying transformers, while it's not exactly transformer itself\n          // Keep in mind that !!0 === false, so it already makes output for Bigint undesirable\n          $.if(propertyAccessExpression).do(...ensureStatements(propertyNodes)),\n        );\n      }\n    }\n\n    return nodes;\n  }\n\n  if (schema.items) {\n    if (schema.items.length === 1) {\n      return processSchemaType({\n        dataExpression: 'item',\n        plugin,\n        schema: schema.items[0]!,\n      });\n    }\n\n    let arrayNodes: Array<ts.Expression | ts.Statement | Expr> = [];\n    // process 2 items if one of them is null\n    if (\n      schema.logicalOperator === 'and' ||\n      (schema.items.length === 2 &&\n        schema.items.find(\n          (item) => item.type === 'null' || item.type === 'void',\n        ))\n    ) {\n      for (const item of schema.items) {\n        const nodes = processSchemaType({\n          dataExpression: dataExpression || 'item',\n          plugin,\n          schema: item,\n        });\n        if (nodes.length) {\n          if (dataExpression) {\n            arrayNodes = arrayNodes.concat(nodes);\n          } else {\n            // processed means the item was transformed\n            arrayNodes.push(\n              $.if('item').do(...ensureStatements(nodes)),\n              $.return('item'),\n            );\n          }\n        }\n      }\n      return arrayNodes;\n    }\n\n    // assume enums do not contain transformable values\n    if (schema.type !== 'enum') {\n      if (\n        !(schema.items ?? []).every((item) =>\n          (\n            ['boolean', 'integer', 'null', 'number', 'string'] as ReadonlyArray<\n              typeof item.type\n            >\n          ).includes(item.type),\n        )\n      ) {\n        console.warn(\n          `‚ùóÔ∏è Transformers warning: schema ${JSON.stringify(schema)} is too complex and won't be currently processed. This will likely produce an incomplete transformer which is not what you want. Please open an issue if you'd like this improved https://github.com/hey-api/openapi-ts/issues`,\n        );\n      }\n    }\n  }\n\n  for (const transformer of plugin.config.transformers) {\n    const t = transformer({\n      config: plugin.config,\n      dataExpression,\n      schema,\n    });\n    if (t) {\n      return t;\n    }\n  }\n\n  return [];\n};\n\n// handles only response transformers for now\nexport const handler: HeyApiTransformersPlugin['Handler'] = ({ plugin }) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const { response } = operationResponsesMap(operation);\n      if (!response) return;\n\n      if (response.items && response.items.length > 1) {\n        if (plugin.context.config.logs.level === 'debug') {\n          console.warn(\n            `‚ùóÔ∏è Transformers warning: route ${createOperationKey(operation)} has ${response.items.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`,\n          );\n        }\n        return;\n      }\n\n      const symbolResponse = plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'response',\n      });\n      if (!symbolResponse) return;\n\n      // TODO: parser - consider handling simple string response which is also a date\n      const nodes = schemaResponseTransformerNodes({\n        plugin,\n        schema: response,\n      });\n      if (!nodes.length) return;\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        meta: {\n          category: 'transform',\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'response',\n        },\n        name: buildName({\n          config: {\n            case: 'camelCase',\n            name: '{{name}}ResponseTransformer',\n          },\n          name: operation.id,\n        }),\n      });\n      const value = $.const(symbol.placeholder)\n        .export(symbol.exported)\n        .assign(\n          // TODO: parser - add types, generate types without transforms\n          $.func()\n            .async()\n            .param(dataVariableName, (p) => p.type('any'))\n            .returns($.type('Promise').generic(symbolResponse.placeholder))\n            .do(...ensureStatements(nodes)),\n        );\n      plugin.setSymbolValue(symbol, value);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { bigIntExpressions, dateExpressions } from './expressions';\nimport { handler } from './plugin';\nimport type { HeyApiTransformersPlugin } from './types';\n\nexport const defaultConfig: HeyApiTransformersPlugin['Config'] = {\n  config: {\n    bigInt: true,\n    dates: true,\n    exportFromIndex: false,\n    transformers: [],\n    typeTransformers: [],\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/transformers',\n  resolveConfig: (plugin) => {\n    if (!plugin.config.transformers) {\n      plugin.config.transformers = [];\n    }\n\n    if (plugin.config.dates) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        dateExpressions,\n      ];\n    }\n\n    if (plugin.config.bigInt) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        bigIntExpressions,\n      ];\n    }\n  },\n  tags: ['transformer'],\n};\n\n/**\n * Type helper for `@hey-api/transformers`, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { parseUrl } from '~/utils/url';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst serverToBaseUrlType = ({ server }: { server: IR.ServerObject }) => {\n  const url = parseUrl(server.url);\n\n  if (url.protocol && url.host) {\n    return $.type.literal(server.url);\n  }\n\n  return $.type\n    .template()\n    .add(url.protocol || $.type('string'))\n    .add('://')\n    .add(url.host || $.type('string'))\n    .add(url.port ? `:${url.port}` : '')\n    .add(url.path || '');\n};\n\nexport const createClientOptions = ({\n  plugin,\n  servers,\n  symbolClientOptions,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  servers: ReadonlyArray<IR.ServerObject>;\n  symbolClientOptions: Symbol;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n\n  const types: Array<TypeTsDsl> = servers.map((server) =>\n    serverToBaseUrlType({ server }),\n  );\n\n  if (!servers.length) {\n    types.push($.type('string'));\n  } else if (\n    !('strictBaseUrl' in client.config && client.config.strictBaseUrl)\n  ) {\n    types.push($.type.and($.type('string'), $.type.object()));\n  }\n\n  const node = $.type\n    .alias(symbolClientOptions.placeholder)\n    .export(symbolClientOptions.exported)\n    .type(\n      $.type\n        .object()\n        .prop(getClientBaseUrlKey(plugin.context.config), (p) =>\n          p.type($.type.or(...types)),\n        ),\n    );\n  plugin.setSymbolValue(symbolClientOptions, node);\n};\n","import type { IR } from '~/ir/types';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createSchemaComment = (\n  schema: IR.SchemaObject,\n): ReadonlyArray<string> | undefined => {\n  const comments: Array<string> = [];\n\n  if (schema.title) {\n    comments.push(escapeComment(schema.title));\n  }\n\n  if (schema.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between title and description\n    }\n    comments.push(escapeComment(schema.description));\n  }\n\n  if (schema.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { numberRegExp } from '~/utils/regexp';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst schemaToEnumObject = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n}) => {\n  const typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  > = [];\n\n  const obj = (schema.items ?? []).map((item, index) => {\n    const typeOfItemConst = typeof item.const;\n\n    if (!typeofItems.includes(typeOfItemConst)) {\n      // track types of enum values because some modes support\n      // only enums with string and number types\n      typeofItems.push(typeOfItemConst);\n    }\n\n    let key: string | undefined;\n    if (item.title) {\n      key = item.title;\n    } else if (typeOfItemConst === 'number' || typeOfItemConst === 'string') {\n      key = `${item.const}`;\n    } else if (typeOfItemConst === 'boolean') {\n      key = item.const ? 'true' : 'false';\n    } else if (item.const === null) {\n      key = 'null';\n    } else {\n      key = `${index}`;\n    }\n\n    if (key) {\n      key = stringCase({\n        case: plugin.config.enums.case,\n        stripLeadingSeparators: false,\n        value: key,\n      });\n\n      numberRegExp.lastIndex = 0;\n      // TypeScript enum keys cannot be numbers\n      if (\n        numberRegExp.test(key) &&\n        plugin.config.enums.enabled &&\n        (plugin.config.enums.mode === 'typescript' ||\n          plugin.config.enums.mode === 'typescript-const')\n      ) {\n        key = `_${key}`;\n      }\n    }\n\n    return {\n      key,\n      schema: item,\n    };\n  });\n\n  return {\n    obj,\n    typeofItems,\n  };\n};\n\nexport const exportType = ({\n  plugin,\n  schema,\n  symbol,\n  type,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  type: MaybeTsDsl<TypeTsDsl>;\n}) => {\n  // root enums have an additional export\n  if (schema.type === 'enum' && plugin.config.enums.enabled) {\n    const enumObject = schemaToEnumObject({ plugin, schema });\n\n    if (plugin.config.enums.mode === 'javascript') {\n      // JavaScript enums might want to ignore null values\n      if (\n        plugin.config.enums.constantsIgnoreNull &&\n        enumObject.typeofItems.includes('object')\n      ) {\n        enumObject.obj = enumObject.obj.filter(\n          (item) => item.schema.const !== null,\n        );\n      }\n\n      const objectNode = $.const(symbol.placeholder)\n        .export()\n        .$if(createSchemaComment(schema), (c, v) => c.doc(v))\n        .assign(\n          $.object(\n            ...enumObject.obj.map((item) =>\n              $.prop({ kind: 'prop', name: item.key })\n                .$if(createSchemaComment(item.schema), (p, v) => p.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          ).as('const'),\n        );\n\n      const node = $.type\n        .alias(symbol.placeholder)\n        .export()\n        .$if(createSchemaComment(schema), (t, v) => t.doc(v))\n        .type(\n          $.type(symbol.placeholder)\n            .idx($.type(symbol.placeholder).typeof().keyof())\n            .typeof(),\n        );\n      plugin.setSymbolValue(symbol, [objectNode, node]);\n      return;\n    } else if (\n      plugin.config.enums.mode === 'typescript' ||\n      plugin.config.enums.mode === 'typescript-const'\n    ) {\n      // TypeScript enums support only string and number values\n      const shouldCreateTypeScriptEnum = !enumObject.typeofItems.some(\n        (type) => type !== 'number' && type !== 'string',\n      );\n      if (shouldCreateTypeScriptEnum) {\n        const enumNode = $.enum(symbol.placeholder)\n          .export()\n          .$if(createSchemaComment(schema), (e, v) => e.doc(v))\n          .const(plugin.config.enums.mode === 'typescript-const')\n          .members(\n            ...enumObject.obj.map((item) =>\n              $.member(item.key)\n                .$if(createSchemaComment(item.schema), (m, v) => m.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          );\n        plugin.setSymbolValue(symbol, enumNode);\n        return;\n      }\n    }\n  }\n\n  const node = $.type\n    .alias(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(createSchemaComment(schema), (t, v) => t.doc(v))\n    .type(type);\n  plugin.setSymbolValue(symbol, node);\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { $ } from '~/ts-dsl';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst irParametersToIrSchema = ({\n  parameters,\n}: {\n  parameters: Record<string, IR.ParameterObject>;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {\n    type: 'object',\n  };\n\n  if (parameters) {\n    const properties: Record<string, IR.SchemaObject> = {};\n    const required: Array<string> = [];\n\n    for (const key in parameters) {\n      const parameter = parameters[key]!;\n\n      properties[parameter.name] = deduplicateSchema({\n        detectFormat: false,\n        schema: parameter.schema,\n      });\n\n      if (parameter.required) {\n        required.push(parameter.name);\n      }\n    }\n\n    irSchema.properties = properties;\n\n    if (required.length) {\n      irSchema.required = required;\n    }\n  }\n\n  return irSchema;\n};\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    data.properties.body = operation.body.schema;\n\n    if (operation.body.required) {\n      dataRequired.push('body');\n    }\n  } else {\n    data.properties.body = {\n      type: 'never',\n    };\n  }\n\n  // TODO: parser - handle cookie parameters\n\n  // do not set headers to never so we can always pass arbitrary values\n  if (operation.parameters?.header) {\n    data.properties.headers = irParametersToIrSchema({\n      parameters: operation.parameters.header,\n    });\n\n    if (data.properties.headers.required) {\n      dataRequired.push('headers');\n    }\n  }\n\n  if (operation.parameters?.path) {\n    data.properties.path = irParametersToIrSchema({\n      parameters: operation.parameters.path,\n    });\n\n    if (data.properties.path.required) {\n      dataRequired.push('path');\n    }\n  } else {\n    data.properties.path = {\n      type: 'never',\n    };\n  }\n\n  if (operation.parameters?.query) {\n    data.properties.query = irParametersToIrSchema({\n      parameters: operation.parameters.query,\n    });\n\n    if (data.properties.query.required) {\n      dataRequired.push('query');\n    }\n  } else {\n    data.properties.query = {\n      type: 'never',\n    };\n  }\n\n  data.properties.url = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('url');\n\n  data.required = dataRequired;\n\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      path: state.path.value,\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'data',\n      tags: state.tags?.value,\n      tool: 'typescript',\n    },\n    name: buildName({\n      config: plugin.config.requests,\n      name: operation.id,\n    }),\n  });\n  const node = $.type\n    .alias(symbol.placeholder)\n    .export(symbol.exported)\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.setSymbolValue(symbol, node);\n};\n\nexport const operationToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  operationToDataType({ operation, plugin, state });\n\n  const { error, errors, response, responses } =\n    operationResponsesMap(operation);\n\n  if (errors) {\n    const symbolErrors = plugin.registerSymbol({\n      exported: true,\n      kind: 'type',\n      meta: {\n        category: 'type',\n        path: state.path.value,\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'errors',\n        tags: state.tags?.value,\n        tool: 'typescript',\n      },\n      name: buildName({\n        config: plugin.config.errors,\n        name: operation.id,\n      }),\n    });\n    const node = $.type\n      .alias(symbolErrors.placeholder)\n      .export(symbolErrors.exported)\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: errors,\n          state,\n        }),\n      );\n    plugin.setSymbolValue(symbolErrors, node);\n\n    if (error) {\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'error',\n          tags: state.tags?.value,\n          tool: 'typescript',\n        },\n        name: buildName({\n          config: {\n            case: plugin.config.errors.case,\n            name: plugin.config.errors.error,\n          },\n          name: operation.id,\n        }),\n      });\n      const node = $.type\n        .alias(symbol.placeholder)\n        .export(symbol.exported)\n        .type(\n          $.type(symbolErrors.placeholder).idx(\n            $.type(symbolErrors.placeholder).keyof(),\n          ),\n        );\n      plugin.setSymbolValue(symbol, node);\n    }\n  }\n\n  if (responses) {\n    const symbolResponses = plugin.registerSymbol({\n      exported: true,\n      kind: 'type',\n      meta: {\n        category: 'type',\n        path: state.path.value,\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'responses',\n        tags: state.tags?.value,\n        tool: 'typescript',\n      },\n      name: buildName({\n        config: plugin.config.responses,\n        name: operation.id,\n      }),\n    });\n    const node = $.type\n      .alias(symbolResponses.placeholder)\n      .export(symbolResponses.exported)\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: responses,\n          state,\n        }),\n      );\n    plugin.setSymbolValue(symbolResponses, node);\n\n    if (response) {\n      const symbol = plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'response',\n          tags: state.tags?.value,\n          tool: 'typescript',\n        },\n        name: buildName({\n          config: {\n            case: plugin.config.responses.case,\n            name: plugin.config.responses.response,\n          },\n          name: operation.id,\n        }),\n      });\n      const node = $.type\n        .alias(symbol.placeholder)\n        .export(symbol.exported)\n        .type(\n          $.type(symbolResponses.placeholder).idx(\n            $.type(symbolResponses.placeholder).keyof(),\n          ),\n        );\n      plugin.setSymbolValue(symbol, node);\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): string => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    const symbolWebhookPayload = plugin.registerSymbol({\n      exported: true,\n      kind: 'type',\n      meta: {\n        category: 'type',\n        path: state.path.value,\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: state.tags?.value,\n        tool: 'typescript',\n      },\n      name: buildName({\n        config: {\n          case: plugin.config.webhooks.case,\n          name: plugin.config.webhooks.payload,\n        },\n        name: operation.id,\n      }),\n    });\n    const node = $.type\n      .alias(symbolWebhookPayload.placeholder)\n      .export(symbolWebhookPayload.exported)\n      .$if(createSchemaComment(operation.body.schema), (t, v) => t.doc(v))\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: operation.body.schema,\n          state,\n        }),\n      );\n    plugin.setSymbolValue(symbolWebhookPayload, node);\n\n    plugin.registerSymbol({\n      exported: true,\n      kind: 'type',\n      meta: {\n        category: 'type',\n        path: state.path.value,\n        resource: 'definition',\n        resourceId: symbolWebhookPayload.placeholder,\n        tags: state.tags?.value,\n        tool: 'typescript',\n      },\n      name: symbolWebhookPayload.name,\n      placeholder: symbolWebhookPayload.placeholder,\n    });\n    data.properties.body = { $ref: symbolWebhookPayload.placeholder };\n    dataRequired.push('body');\n  } else {\n    data.properties.body = { type: 'never' };\n  }\n\n  data.properties.key = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('key');\n\n  data.properties.path = { type: 'never' };\n  data.properties.query = { type: 'never' };\n\n  data.required = dataRequired;\n\n  const symbolWebhookRequest = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      path: state.path.value,\n      resource: 'webhook',\n      resourceId: operation.id,\n      role: 'data',\n      tags: state.tags?.value,\n      tool: 'typescript',\n    },\n    name: buildName({\n      config: plugin.config.webhooks,\n      name: operation.id,\n    }),\n  });\n  const node = $.type\n    .alias(symbolWebhookRequest.placeholder)\n    .export(symbolWebhookRequest.exported)\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.setSymbolValue(symbolWebhookRequest, node);\n\n  return symbolWebhookRequest.placeholder;\n};\n\nexport const webhookToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): string => {\n  const name = operationToDataType({ operation, plugin, state });\n  return name;\n\n  // don't handle webhook responses for now, users only need requestBody\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nexport const createWebhooks = ({\n  plugin,\n  symbolWebhooks,\n  webhookNames,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  symbolWebhooks: Symbol;\n  webhookNames: ReadonlyArray<string>;\n}) => {\n  if (!webhookNames.length) return;\n\n  const node = $.type\n    .alias(symbolWebhooks.placeholder)\n    .export(symbolWebhooks.exported)\n    .type($.type.or(...webhookNames));\n  plugin.setSymbolValue(symbolWebhooks, node);\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): TypeTsDsl => {\n  if (!schema.items) {\n    return $.type('Array').generic($.type(plugin.config.topType));\n  }\n\n  schema = deduplicateSchema({ detectFormat: true, schema });\n\n  const itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  if (itemTypes.length === 1) {\n    return $.type('Array').generic(itemTypes[0]!);\n  }\n\n  return schema.logicalOperator === 'and'\n    ? $.type('Array').generic($.type.and(...itemTypes))\n    : $.type('Array').generic($.type.or(...itemTypes));\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as boolean);\n  }\n\n  return $.type('boolean');\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  const type = irSchemaToAst({\n    plugin,\n    schema: {\n      ...schema,\n      type: undefined,\n    },\n    state,\n  });\n  return type;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'never'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('never');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): TypeTsDsl => {\n  const node = $.type.literal(null);\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as number);\n  }\n\n  if (schema.type === 'integer' && schema.format === 'int64') {\n    // TODO: parser - add ability to skip type transformers\n    if (plugin.getPlugin('@hey-api/transformers')?.config.bigInt) {\n      return $.type('bigint');\n    }\n  }\n\n  return $.type('number');\n};\n","import type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): TypeTsDsl => {\n  // TODO: parser - handle constants\n  const shape = $.type.object();\n  const required = schema.required ?? [];\n  let indexSchemas: Array<IR.SchemaObject> = [];\n  let hasOptionalProperties = false;\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const propertyType = irSchemaToAst({\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    const isRequired = required.includes(name);\n    shape.prop(name, (p) =>\n      p\n        .$if(createSchemaComment(property), (p, v) => p.doc(v))\n        .readonly(property.accessScope === 'read')\n        .required(isRequired)\n        .type(propertyType),\n    );\n    indexSchemas.push(property);\n\n    if (!isRequired) {\n      hasOptionalProperties = true;\n    }\n  }\n\n  // include pattern value schemas into the index union\n  if (schema.patternProperties) {\n    for (const pattern in schema.patternProperties) {\n      const ir = schema.patternProperties[pattern]!;\n      indexSchemas.unshift(ir);\n    }\n  }\n\n  const hasPatterns =\n    !!schema.patternProperties &&\n    Object.keys(schema.patternProperties).length > 0;\n\n  const addPropsRaw = schema.additionalProperties;\n  const addPropsObj =\n    addPropsRaw !== false && addPropsRaw\n      ? (addPropsRaw as IR.SchemaObject)\n      : undefined;\n  const shouldCreateIndex =\n    hasPatterns ||\n    (!!addPropsObj && (addPropsObj.type !== 'never' || !indexSchemas.length));\n\n  if (shouldCreateIndex) {\n    // only inject additionalProperties when it‚Äôs not \"never\"\n    const addProps = addPropsObj;\n    if (addProps && addProps.type !== 'never') {\n      indexSchemas.unshift(addProps);\n    } else if (\n      !hasPatterns &&\n      !indexSchemas.length &&\n      addProps &&\n      addProps.type === 'never'\n    ) {\n      // keep \"never\" only when there are NO patterns and NO explicit properties\n      indexSchemas = [addProps];\n    }\n\n    if (hasOptionalProperties) {\n      indexSchemas.push({ type: 'undefined' });\n    }\n\n    const type =\n      indexSchemas.length === 1\n        ? irSchemaToAst({\n            plugin,\n            schema: indexSchemas[0]!,\n            state,\n          })\n        : irSchemaToAst({\n            plugin,\n            schema: { items: indexSchemas, logicalOperator: 'or' },\n            state,\n          });\n\n    if (schema.propertyNames?.$ref) {\n      return $.type\n        .mapped('key')\n        .key(\n          irSchemaToAst({\n            plugin,\n            schema: {\n              $ref: schema.propertyNames.$ref,\n            },\n            state,\n          }),\n        )\n        .optional()\n        .type(type);\n    }\n\n    shape.idxSig('key', (i) => i.key('string').type(type));\n  }\n\n  return shape;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as string);\n  }\n\n  if (schema.format) {\n    if (schema.format === 'binary') {\n      return $.type.or($.type('Blob'), $.type('File'));\n    }\n\n    if (schema.format === 'date-time' || schema.format === 'date') {\n      // TODO: parser - add ability to skip type transformers\n      if (plugin.getPlugin('@hey-api/transformers')?.config.dates) {\n        return $.type('Date');\n      }\n    }\n\n    if (schema.format === 'typeid' && typeof schema.example === 'string') {\n      const parts = String(schema.example).split('_');\n      parts.pop(); // remove the ID part\n      const type = parts.join('_');\n\n      const query: SymbolMeta = {\n        category: 'type',\n        resource: 'type-id',\n        resourceId: type,\n        tool: 'typescript',\n      };\n      if (!plugin.getSymbol(query)) {\n        const queryTypeId: SymbolMeta = {\n          category: 'type',\n          resource: 'type-id',\n          tool: 'typescript',\n          variant: 'container',\n        };\n\n        if (!plugin.getSymbol(queryTypeId)) {\n          const symbolTypeId = plugin.registerSymbol({\n            exported: true,\n            kind: 'type',\n            meta: queryTypeId,\n            name: 'TypeID',\n          });\n          const nodeTypeId = $.type\n            .alias(symbolTypeId.placeholder)\n            .export(symbolTypeId.exported)\n            .generic('T', (g) => g.extends('string'))\n            .type(\n              $.type.template().add($.type('T')).add('_').add($.type('string')),\n            );\n          plugin.setSymbolValue(symbolTypeId, nodeTypeId);\n        }\n\n        const symbolTypeId = plugin.referenceSymbol(queryTypeId);\n        const symbolTypeName = plugin.registerSymbol({\n          exported: true,\n          kind: 'type',\n          meta: query,\n          name: stringCase({\n            case: plugin.config.case,\n            value: `${type}_id`,\n          }),\n        });\n        const node = $.type\n          .alias(symbolTypeName.placeholder)\n          .export(symbolTypeName.exported)\n          .type($.type(symbolTypeId.placeholder).generic($.type.literal(type)));\n        plugin.setSymbolValue(symbolTypeName, node);\n      }\n      const symbol = plugin.referenceSymbol(query);\n      return $.type(symbol.placeholder);\n    }\n  }\n\n  return $.type('string');\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  let itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.const && Array.isArray(schema.const)) {\n    itemTypes = schema.const.map((value) => $.type.fromValue(value));\n  } else if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  return $.type.tuple(...itemTypes);\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'undefined'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('undefined');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): TypeTsDsl => {\n  const node = $.type(plugin.config.topType);\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'void'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('void');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): MaybeTsDsl<TypeTsDsl> => {\n  const transformersPlugin = args.plugin.getPlugin('@hey-api/transformers');\n  if (transformersPlugin?.config.typeTransformers) {\n    for (const typeTransformer of transformersPlugin.config.typeTransformers) {\n      const typeNode = typeTransformer({ schema });\n      if (typeNode) {\n        return typeNode;\n      }\n    }\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRefs } from '~/plugins/shared/utils/refs';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { createClientOptions } from '../shared/clientOptions';\nimport { exportType } from '../shared/export';\nimport { operationToType } from '../shared/operation';\nimport type { IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { webhookToType } from '../shared/webhook';\nimport { createWebhooks } from '../shared/webhooks';\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): MaybeTsDsl<TypeTsDsl> => {\n  if (schema.$ref) {\n    const symbol = plugin.referenceSymbol({\n      category: 'type',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    });\n    return $.type(symbol.placeholder);\n  }\n\n  if (schema.type) {\n    return irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n  }\n\n  if (schema.items) {\n    schema = deduplicateSchema({ detectFormat: false, schema });\n    if (schema.items) {\n      const itemTypes = schema.items.map((item) =>\n        irSchemaToAst({ plugin, schema: item, state }),\n      );\n      return schema.logicalOperator === 'and'\n        ? $.type.and(...itemTypes)\n        : $.type.or(...itemTypes);\n    }\n\n    return irSchemaToAst({ plugin, schema, state });\n  }\n\n  // catch-all fallback for failed schemas\n  return irSchemaWithTypeToAst({\n    plugin,\n    schema: {\n      type: 'unknown',\n    },\n    state,\n  });\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}) => {\n  const type = irSchemaToAst({ plugin, schema, state });\n\n  // Don't tag enums as 'type' since they export runtime artifacts (values)\n  const isEnum = schema.type === 'enum' && plugin.config.enums.enabled;\n\n  const $ref = pathToJsonPointer(state.path.value);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    kind: isEnum ? undefined : 'type',\n    meta: {\n      category: 'type',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'typescript',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: refToName($ref),\n    }),\n  });\n  exportType({\n    plugin,\n    schema,\n    symbol,\n    type,\n  });\n};\n\nexport const handlerV1: HeyApiTypeScriptPlugin['Handler'] = ({ plugin }) => {\n  // reserve identifier for ClientOptions\n  const symbolClientOptions = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'client',\n      role: 'options',\n      tool: 'typescript',\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'ClientOptions',\n    }),\n  });\n  // reserve identifier for Webhooks\n  const symbolWebhooks = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'webhook',\n      tool: 'typescript',\n      variant: 'container',\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'Webhooks',\n    }),\n  });\n\n  const servers: Array<IR.ServerObject> = [];\n  const webhookNames: Array<string> = [];\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'server',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          operationToType({\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'server':\n          servers.push(event.server);\n          break;\n        case 'webhook':\n          webhookNames.push(\n            webhookToType({\n              operation: event.operation,\n              plugin,\n              state,\n            }),\n          );\n          break;\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  createClientOptions({ plugin, servers, symbolClientOptions });\n  createWebhooks({ plugin, symbolWebhooks, webhookNames });\n};\n","import type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport { irSchemaToAstV1 } from './v1/api';\n\nexport type IApi = {\n  schemaToType: (\n    args: Parameters<typeof irSchemaToAstV1>[0],\n  ) => MaybeTsDsl<TypeTsDsl>;\n};\n\nexport class Api implements IApi {\n  schemaToType(\n    args: Parameters<typeof irSchemaToAstV1>[0],\n  ): MaybeTsDsl<TypeTsDsl> {\n    return irSchemaToAstV1(args);\n  }\n}\n","import type { HeyApiTypeScriptPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiTypeScriptPlugin['Handler'] = (args) =>\n  handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { HeyApiTypeScriptPlugin } from './types';\n\nexport const defaultConfig: HeyApiTypeScriptPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    exportFromIndex: true,\n    topType: 'unknown',\n  },\n  handler,\n  name: '@hey-api/typescript',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.enums = context.valueToObject({\n      defaultValue: {\n        case: 'SCREAMING_SNAKE_CASE',\n        constantsIgnoreNull: false,\n        enabled: Boolean(plugin.config.enums),\n        mode: 'javascript',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        string: (mode) => ({ mode }),\n      },\n      value: plugin.config.enums,\n    });\n\n    plugin.config.errors = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        error: '{{name}}Error',\n        name: '{{name}}Errors',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.errors,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Data',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Responses',\n        response: '{{name}}Response',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}WebhookRequest',\n        payload: '{{name}}WebhookPayload',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n};\n\n/**\n * Type helper for `@hey-api/typescript` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const handleMeta = (\n  plugin: PiniaColadaPlugin['Instance'],\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  const typeData = operationOptionsType({ operation, plugin: pluginSdk });\n  return typeData;\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const client = getClientPlugin(plugin.context.config);\n\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n\n  let typeErrorName: string | undefined = symbolErrorType?.placeholder;\n  if (!typeErrorName) {\n    typeErrorName = 'Error';\n  }\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'axios.AxiosError',\n    });\n    typeErrorName = `${symbol.placeholder}<${typeErrorName}>`;\n  }\n  return typeErrorName;\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): string => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return symbolResponseType?.placeholder || 'unknown';\n};\n","import { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const getPublicTypeData = ({\n  plugin,\n  typeData,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n  typeData: string;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const strippedTypeData = isNuxtClient\n    ? `Omit<${typeData}, 'composable'>`\n    : typeData;\n\n  return { isNuxtClient, strippedTypeData };\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\n\nimport { handleMeta } from './meta';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData, useTypeError, useTypeResponse } from './useType';\nimport { getPublicTypeData } from './utils';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  queryFn: string;\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.UseMutationOptions`,\n  });\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n  const { isNuxtClient, strippedTypeData } = getPublicTypeData({\n    plugin,\n    typeData,\n  });\n  // TODO: better types syntax\n  const mutationType = isNuxtClient\n    ? `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${strippedTypeData}, ${typeError}>`\n    : `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${typeData}, ${typeError}>`;\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkFn = $(queryFn)\n    .call(\n      $.object()\n        .pretty()\n        .spread('options')\n        .spread(fnOptions)\n        .prop('throwOnError', $.literal(true)),\n    )\n    .await();\n\n  const statements: Array<ReturnType<typeof $.var | typeof $.return>> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const mutationOpts = $.object()\n    .pretty()\n    .prop(\n      'mutation',\n      $.func()\n        .async()\n        .param(fnOptions, (p) =>\n          p.$if(isNuxtClient, (f) => f.type(`Partial<${strippedTypeData}>`)),\n        )\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'mutationOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n  const symbolMutationOptions = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.mutationOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = $.const(symbolMutationOptions.placeholder)\n    .export(symbolMutationOptions.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p.optional().type(`Partial<${strippedTypeData}>`),\n        )\n        .returns(mutationType)\n        .do($.return(mutationOpts)),\n    );\n  plugin.setSymbolValue(symbolMutationOptions, statement);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { clientFolderAbsolutePath } from '~/generate/client';\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { getClientBaseUrlKey } from '~/plugins/@hey-api/client-core/utils';\nimport { $ } from '~/ts-dsl';\n\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\nimport { getPublicTypeData } from './utils';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolCreateQueryKey = plugin.registerSymbol({\n    meta: {\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createQueryKey',\n    }),\n  });\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const symbolJsonValue = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}._JSONValue`,\n  });\n\n  const returnType = $.type(symbolQueryKeyType.placeholder)\n    .generic(TOptionsType)\n    .idx(0);\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolSerializeQueryValue = plugin.registerSymbol({\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: `${clientModule}.serializeQueryKeyValue`,\n    },\n    name: 'serializeQueryKeyValue',\n  });\n\n  const fn = $.const(symbolCreateQueryKey.placeholder).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .returns($.type.tuple(returnType))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions.placeholder))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                `options?.${baseUrlKey} || (options?.client ?? ${symbolClient?.placeholder}).getConfig().${baseUrlKey}`,\n              )\n              .as(returnType),\n          ),\n        $.if('tags').do(\n          $('params')\n            .attr('tags')\n            .assign($('tags').as('unknown').as(symbolJsonValue.placeholder)),\n        ),\n        $.if($('options').attr('body').optional().neq($.id('undefined'))).do(\n          $.const('normalizedBody').assign(\n            $(symbolSerializeQueryValue.placeholder).call(\n              $('options').attr('body'),\n            ),\n          ),\n          $.if($('normalizedBody').neq($.id('undefined'))).do(\n            $('params').attr('body').assign('normalizedBody'),\n          ),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional().neq($.id('undefined'))).do(\n          $.const('normalizedQuery').assign(\n            $(symbolSerializeQueryValue.placeholder).call(\n              $('options').attr('query'),\n            ),\n          ),\n          $.if($('normalizedQuery').neq($.id('undefined'))).do(\n            $('params').attr('query').assign('normalizedQuery'),\n          ),\n        ),\n        $.return($.array($('params'))),\n      ),\n  );\n  plugin.setSymbolValue(symbolCreateQueryKey, fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  operation,\n  plugin,\n}: {\n  id: string;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const config = plugin.config.queryKeys;\n  let tagsExpression: ReturnType<typeof $.array> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsExpression = $.array(...operation.tags.map((tag) => $.literal(tag)));\n  }\n\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey.placeholder).call(\n    $.literal(id),\n    'options',\n    tagsExpression,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolJsonValue = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}._JSONValue`,\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n    name: 'QueryKey',\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType.placeholder)\n    .export(symbolQueryKeyType.exported)\n    .generic(TOptionsType, (g) => g.extends($.type(symbolOptions.placeholder)))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(`Pick<${TOptionsType}, 'path'>`),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop(getClientBaseUrlKey(plugin.context.config), (p) =>\n              p.optional().type(symbolJsonValue.placeholder),\n            )\n            .prop('body', (p) => p.optional().type(symbolJsonValue.placeholder))\n            .prop('query', (p) =>\n              p.optional().type(symbolJsonValue.placeholder),\n            )\n            .prop('tags', (p) =>\n              p.optional().type(symbolJsonValue.placeholder),\n            ),\n        ),\n      ),\n    );\n  plugin.setSymbolValue(symbolQueryKeyType, queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  operation,\n  plugin,\n  symbol,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const { strippedTypeData } = getPublicTypeData({ plugin, typeData });\n  const statement = $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p\n            .required(hasOperationDataRequired(operation))\n            .type(strippedTypeData),\n        )\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\n\nimport { handleMeta } from './meta';\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from './queryKey';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\nimport { getPublicTypeData } from './utils';\n\nconst optionsParamName = 'options';\nconst fnOptions = 'context';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  queryFn: string;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  let keyExpression: ReturnType<typeof $.call>;\n  if (plugin.config.queryKeys.enabled) {\n    const symbolQueryKey = plugin.registerSymbol({\n      exported: true,\n      name: buildName({\n        config: plugin.config.queryKeys,\n        name: operation.id,\n      }),\n    });\n    const node = queryKeyStatement({\n      operation,\n      plugin,\n      symbol: symbolQueryKey,\n    });\n    plugin.setSymbolValue(symbolQueryKey, node);\n    keyExpression = $(symbolQueryKey.placeholder).call(optionsParamName);\n  } else {\n    const symbolCreateQueryKey = plugin.referenceSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    });\n    // Optionally include tags when configured\n    let tagsExpr: ReturnType<typeof $.array> | undefined;\n    if (\n      plugin.config.queryKeys.tags &&\n      operation.tags &&\n      operation.tags.length > 0\n    ) {\n      tagsExpr = $.array(...operation.tags.map((t) => $.literal(t)));\n    }\n    keyExpression = $(symbolCreateQueryKey.placeholder).call(\n      $.literal(operation.id),\n      optionsParamName,\n      tagsExpr,\n    );\n  }\n\n  const typeData = useTypeData({ operation, plugin });\n  const { strippedTypeData } = getPublicTypeData({\n    plugin,\n    typeData,\n  });\n  const awaitSdkFn = $(queryFn)\n    .call(\n      $.object()\n        .spread(optionsParamName)\n        .spread(fnOptions)\n        .prop('throwOnError', $.literal(true)),\n    )\n    .await();\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const queryOpts = $.object()\n    .pretty()\n    .prop('key', keyExpression)\n    .prop(\n      'query',\n      $.func()\n        .async()\n        .param(fnOptions)\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n\n  const symbolQueryOptionsFn = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'hook',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'queryOptions',\n      tool: plugin.name,\n    },\n    name: buildName({\n      config: plugin.config.queryOptions,\n      name: operation.id,\n    }),\n  });\n  const symbolDefineQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.defineQueryOptions`,\n  });\n  const statement = $.const(symbolQueryOptionsFn.placeholder)\n    .export(symbolQueryOptionsFn.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $(symbolDefineQueryOptions.placeholder).call(\n        $.func()\n          .param(optionsParamName, (p) =>\n            p.required(isRequiredOptions).type(strippedTypeData),\n          )\n          .do($.return(queryOpts)),\n      ),\n    );\n  plugin.setSymbolValue(symbolQueryOptionsFn, statement);\n};\n","import { registryName } from '~/plugins/@hey-api/sdk/shared/class';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { stringCase } from '~/utils/stringCase';\n\nimport { createMutationOptions } from '../mutationOptions';\nimport { createQueryOptions } from '../queryOptions';\nimport type { PiniaColadaPlugin } from '../types';\n\nexport const handlerV0: PiniaColadaPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.defineQueryOptions`,\n    },\n    name: 'defineQueryOptions',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseMutationOptions`,\n    },\n    name: 'UseMutationOptions',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseQueryOptions`,\n    },\n    name: 'UseQueryOptions',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}._JSONValue`,\n    },\n    name: '_JSONValue',\n  });\n  plugin.registerSymbol({\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n    name: 'AxiosError',\n  });\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const classes = sdkPlugin.config.asClass\n        ? operationClasses({\n            context: plugin.context,\n            operation,\n            plugin: sdkPlugin,\n          })\n        : undefined;\n      const entry = classes ? classes.values().next().value : undefined;\n      // TODO: this should use class graph to determine correct path string\n      // as it's really easy to break once we change the class casing\n      let queryFn: string;\n      if (entry) {\n        const symbolClass = plugin.referenceSymbol({\n          category: 'utility',\n          resource: 'class',\n          resourceId: entry.path[0],\n          tool: 'sdk',\n        });\n        queryFn = [\n          symbolClass.placeholder,\n          ...(sdkPlugin.config.instance ? [registryName, 'get()'] : []),\n          ...entry.path.slice(1).map((className) =>\n            stringCase({\n              case: 'camelCase',\n              value: className,\n            }),\n          ),\n          entry.methodName,\n        ]\n          .filter(Boolean)\n          .join('.');\n      } else {\n        queryFn = plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }).placeholder;\n      }\n\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin, queryFn });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin, queryFn });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PiniaColadaPlugin } from './types';\nimport { handlerV0 } from './v0/plugin';\n\nexport const handler: PiniaColadaPlugin['Handler'] = (args) => handlerV0(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const defaultConfig: PiniaColadaPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript', '@hey-api/sdk'],\n  handler: handler as PiniaColadaPlugin['Handler'],\n  name: '@pinia/colada',\n  resolveConfig: (plugin, context) => {\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@pinia/colada` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\n\nimport type { PluginInstance } from '../types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  const typeData = operationOptionsType({ operation, plugin: pluginSdk });\n  return typeData;\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const client = getClientPlugin(plugin.context.config);\n\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n\n  let typeErrorName: string | undefined = symbolErrorType?.placeholder;\n  if (!typeErrorName) {\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: `${plugin.name}.DefaultError`,\n    });\n    typeErrorName = symbol.placeholder;\n  }\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'axios.AxiosError',\n    });\n    typeErrorName = `${symbol.placeholder}<${typeErrorName}>`;\n  }\n  return typeErrorName;\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): string => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return symbolResponseType?.placeholder || 'unknown';\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { getClientBaseUrlKey } from '~/plugins/@hey-api/client-core/utils';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport { useTypeData } from './shared/useType';\nimport type { PluginInstance } from './types';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateQueryKey = plugin.registerSymbol({\n    meta: {\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createQueryKey',\n    }),\n  });\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const returnType = $.type(symbolQueryKeyType.placeholder)\n    .generic(TOptionsType)\n    .idx(0);\n\n  const fn = $.const(symbolCreateQueryKey.placeholder).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('infinite', (p) => p.optional().type('boolean'))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions.placeholder))\n      .returns($.type.tuple(returnType))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                `options?.${baseUrlKey} || (options?.client ?? ${symbolClient?.placeholder}).getConfig().${baseUrlKey}`,\n              )\n              .as(returnType),\n          ),\n        $.if('infinite').do($('params').attr('_infinite').assign('infinite')),\n        $.if('tags').do($('params').attr('tags').assign('tags')),\n        $.if($('options').attr('body').optional()).do(\n          $('params').attr('body').assign($('options').attr('body')),\n        ),\n        $.if($('options').attr('headers').optional()).do(\n          $('params').attr('headers').assign($('options').attr('headers')),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional()).do(\n          $('params').attr('query').assign($('options').attr('query')),\n        ),\n        $.return($.array().element($('params'))),\n      ),\n  );\n  plugin.setSymbolValue(symbolCreateQueryKey, fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  isInfinite,\n  operation,\n  plugin,\n}: {\n  id: string;\n  isInfinite?: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}) => {\n  const config = isInfinite\n    ? plugin.config.infiniteQueryKeys\n    : plugin.config.queryKeys;\n  let tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsArray = $.array().elements(...operation.tags);\n  }\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey.placeholder).call(\n    $.literal(id),\n    'options',\n    isInfinite || tagsArray ? $.literal(Boolean(isInfinite)) : undefined,\n    tagsArray,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({ plugin }: { plugin: PluginInstance }) => {\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n    name: 'QueryKey',\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType.placeholder)\n    .export(symbolQueryKeyType.exported)\n    .generic(TOptionsType, (g) => g.extends(symbolOptions.placeholder))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(\n            `Pick<${TOptionsType}, '${getClientBaseUrlKey(plugin.context.config)}' | 'body' | 'headers' | 'path' | 'query'>`,\n          ),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop('_infinite', (p) => p.optional().type('boolean'))\n            .prop('tags', (p) => p.optional().type('ReadonlyArray<string>')),\n        ),\n      ),\n    );\n  plugin.setSymbolValue(symbolQueryKeyType, queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  isInfinite,\n  operation,\n  plugin,\n  symbol,\n  typeQueryKey,\n}: {\n  isInfinite: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  symbol: Symbol;\n  typeQueryKey?: string;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const statement = $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p.required(hasOperationDataRequired(operation)).type(typeData),\n        )\n        .$if(isInfinite && typeQueryKey, (f, v) => f.returns(v))\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            isInfinite,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { PluginInstance } from '../types';\n\nexport const handleMeta = (\n  plugin: PluginInstance,\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'infiniteQueryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import { operationPagination } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst createInfiniteParamsFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateInfiniteParams = plugin.registerSymbol({\n    meta: {\n      category: 'utility',\n      resource: 'createInfiniteParams',\n      tool: plugin.name,\n    },\n    name: buildName({\n      config: {\n        case: plugin.config.case,\n      },\n      name: 'createInfiniteParams',\n    }),\n  });\n\n  const fn = $.const(symbolCreateInfiniteParams.placeholder).assign(\n    $.func()\n      .generic('K', (g) =>\n        g.extends(\n          \"Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>\",\n        ),\n      )\n      .param('queryKey', (p) => p.type('QueryKey<Options>'))\n      .param('page', (p) => p.type('K'))\n      .do(\n        $.const('params').assign($.object().spread($('queryKey').attr(0))),\n        $.if($('page').attr('body')).do(\n          $('params')\n            .attr('body')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('body').as('any'))\n                .spread($('page').attr('body').as('any')),\n            ),\n        ),\n        $.if($('page').attr('headers')).do(\n          $('params')\n            .attr('headers')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('headers'))\n                .spread($('page').attr('headers')),\n            ),\n        ),\n        $.if($('page').attr('path')).do(\n          $('params')\n            .attr('path')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('path').as('any'))\n                .spread($('page').attr('path').as('any')),\n            ),\n        ),\n        $.if($('page').attr('query')).do(\n          $('params')\n            .attr('query')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('query').as('any'))\n                .spread($('page').attr('query').as('any')),\n            ),\n        ),\n        $.return($('params').as('unknown').as($('page').typeofType())),\n      ),\n  );\n  plugin.setSymbolValue(symbolCreateInfiniteParams, fn);\n};\n\nexport const createInfiniteQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  const pagination = operationPagination({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!pagination) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createInfiniteParams',\n      tool: plugin.name,\n    })\n  ) {\n    createInfiniteParamsFunction({ plugin });\n  }\n\n  const symbolInfiniteQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.infiniteQueryOptions`,\n  });\n  const symbolInfiniteDataType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.InfiniteData`,\n  });\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const typeQueryKey = `${symbolQueryKeyType.placeholder}<${typeData}>`;\n  const typePageObjectParam = `Pick<${typeQueryKey}[0], 'body' | 'headers' | 'path' | 'query'>`;\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const type = pluginTypeScript.api.schemaToType({\n    plugin: pluginTypeScript,\n    schema: pagination.schema,\n    state: {\n      path: {\n        value: [],\n      },\n    },\n  });\n\n  const symbolInfiniteQueryKey = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.infiniteQueryKeys,\n      name: operation.id,\n    }),\n  });\n  const node = queryKeyStatement({\n    isInfinite: true,\n    operation,\n    plugin,\n    symbol: symbolInfiniteQueryKey,\n    typeQueryKey,\n  });\n  plugin.setSymbolValue(symbolInfiniteQueryKey, node);\n\n  const awaitSdkFn = $(queryFn)\n    .call(\n      $.object()\n        .spread('options')\n        .spread('params')\n        .prop('signal', $('signal'))\n        .prop('throwOnError', $.literal(true)),\n    )\n    .await();\n\n  const symbolCreateInfiniteParams = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createInfiniteParams',\n    tool: plugin.name,\n  });\n\n  const statements: Array<TsDsl<any>> = [\n    $.const('page')\n      .type(typePageObjectParam)\n      .hint('@ts-ignore')\n      .assign(\n        $.ternary($('pageParam').typeof().eq($.literal('object')))\n          .do('pageParam')\n          .otherwise(\n            $.object()\n              .pretty()\n              .prop(\n                pagination.in,\n                $.object().pretty().prop(pagination.name, $('pageParam')),\n              ),\n          ),\n      ),\n    $.const('params').assign(\n      $(symbolCreateInfiniteParams.placeholder).call('queryKey', 'page'),\n    ),\n  ];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const symbolInfiniteQueryOptionsFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.infiniteQueryOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = $.const(symbolInfiniteQueryOptionsFn.placeholder)\n    .export(symbolInfiniteQueryOptionsFn.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param('options', (p) => p.required(isRequiredOptions).type(typeData))\n        .do(\n          $.return(\n            $(symbolInfiniteQueryOptions.placeholder)\n              .call(\n                $.object()\n                  .pretty()\n                  .hint('@ts-ignore')\n                  .prop(\n                    'queryFn',\n                    $.func()\n                      .async()\n                      .param((p) => p.object('pageParam', 'queryKey', 'signal'))\n                      .do(...statements),\n                  )\n                  .prop(\n                    'queryKey',\n                    $(symbolInfiniteQueryKey.placeholder).call('options'),\n                  )\n                  .$if(\n                    handleMeta(plugin, operation, 'infiniteQueryOptions'),\n                    (o, v) => o.prop('meta', v),\n                  ),\n              )\n              .generics(\n                // TODO: better types syntax\n                typeResponse,\n                typeError || 'unknown',\n                `${symbolInfiniteDataType.placeholder}<${typeResponse}>`,\n                typeQueryKey,\n                $.type.or(type, typePageObjectParam),\n              ),\n          ),\n        ),\n    );\n  plugin.setSymbolValue(symbolInfiniteQueryOptionsFn, statement);\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.MutationOptions`,\n  });\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n  // TODO: better types syntax\n  const mutationType = `${symbolMutationOptionsType.placeholder}<${typeResponse}, ${typeError}, ${typeData}>`;\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkFn = $(queryFn)\n    .call(\n      $.object()\n        .spread('options')\n        .spread(fnOptions)\n        .prop('throwOnError', $.literal(true)),\n    )\n    .await();\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const mutationOptionsFn = 'mutationOptions';\n  const symbolMutationOptions = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.mutationOptions,\n      name: operation.id,\n    }),\n  });\n  const statement = $.const(symbolMutationOptions.placeholder)\n    .export(symbolMutationOptions.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param('options', (p) => p.optional().type(`Partial<${typeData}>`))\n        .returns(mutationType)\n        .do(\n          $.const(mutationOptionsFn)\n            .type(mutationType)\n            .assign(\n              $.object()\n                .pretty()\n                .prop(\n                  'mutationFn',\n                  $.func()\n                    .async()\n                    .param(fnOptions)\n                    .do(...statements),\n                )\n                .$if(handleMeta(plugin, operation, 'mutationOptions'), (c, v) =>\n                  c.prop('meta', v),\n                ),\n            ),\n          $(mutationOptionsFn).return(),\n        ),\n    );\n  plugin.setSymbolValue(symbolMutationOptions, statement);\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  queryFn: string;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  const symbolQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.queryOptions`,\n  });\n\n  const symbolQueryKey = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.queryKeys,\n      name: operation.id,\n    }),\n  });\n  const node = queryKeyStatement({\n    isInfinite: false,\n    operation,\n    plugin,\n    symbol: symbolQueryKey,\n  });\n  plugin.setSymbolValue(symbolQueryKey, node);\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeError = useTypeError({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const awaitSdkFn = $(queryFn)\n    .call(\n      $.object()\n        .spread(optionsParamName)\n        .spread($('queryKey').attr(0))\n        .prop('signal', $('signal'))\n        .prop('throwOnError', $.literal(true)),\n    )\n    .await();\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const queryOptionsObj = $.object()\n    .pretty()\n    .prop(\n      'queryFn',\n      $.func()\n        .async()\n        .param((p) => p.object('queryKey', 'signal'))\n        .do(...statements),\n    )\n    .prop('queryKey', $(symbolQueryKey.placeholder).call(optionsParamName))\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n\n  const symbolQueryOptionsFn = plugin.registerSymbol({\n    exported: plugin.config.queryOptions.exported,\n    meta: {\n      category: 'hook',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'queryOptions',\n      tool: plugin.name,\n    },\n    name: buildName({\n      config: plugin.config.queryOptions,\n      name: operation.id,\n    }),\n  });\n  // TODO: add type error\n  // TODO: AxiosError<PutSubmissionMetaError>\n  const statement = $.const(symbolQueryOptionsFn.placeholder)\n    .export(symbolQueryOptionsFn.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) =>\n          p.required(isRequiredOptions).type(typeData),\n        )\n        .do(\n          $(symbolQueryOptions.placeholder)\n            .call(queryOptionsObj)\n            .generics(\n              typeResponse,\n              typeError,\n              typeResponse,\n              $(symbolQueryKey.placeholder).returnType(),\n            )\n            .return(),\n        ),\n    );\n  plugin.setSymbolValue(symbolQueryOptionsFn, statement);\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\n\nimport { useTypeData } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createUseQuery = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  if (!('useQuery' in plugin.config)) {\n    return;\n  }\n\n  const symbolUseQueryFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.useQuery,\n      name: operation.id,\n    }),\n  });\n\n  const symbolUseQuery = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.useQuery`,\n  });\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const typeData = useTypeData({ operation, plugin });\n\n  const symbolQueryOptionsFn = plugin.referenceSymbol({\n    category: 'hook',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'queryOptions',\n    tool: plugin.name,\n  });\n  const statement = $.const(symbolUseQueryFn.placeholder)\n    .export(symbolUseQueryFn.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) =>\n          p.required(isRequiredOptions).type(typeData),\n        )\n        .do(\n          $(symbolUseQuery.placeholder)\n            .call($(symbolQueryOptionsFn.placeholder).call(optionsParamName))\n            .return(),\n        ),\n    );\n  plugin.setSymbolValue(symbolUseQueryFn, statement);\n};\n","import { registryName } from '~/plugins/@hey-api/sdk/shared/class';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { PluginHandler } from '../types';\nimport { createInfiniteQueryOptions } from './infiniteQueryOptions';\nimport { createMutationOptions } from './mutationOptions';\nimport { createQueryOptions } from './queryOptions';\nimport { createUseQuery } from './useQuery';\n\nexport const handlerV5: PluginHandler = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.DefaultError`,\n    },\n    name: 'DefaultError',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.InfiniteData`,\n    },\n    name: 'InfiniteData',\n  });\n  const mutationsType =\n    plugin.name === '@tanstack/angular-query-experimental' ||\n    plugin.name === '@tanstack/svelte-query' ||\n    plugin.name === '@tanstack/solid-query'\n      ? 'MutationOptions'\n      : 'UseMutationOptions';\n  plugin.registerSymbol({\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.MutationOptions`,\n    },\n    name: mutationsType,\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.infiniteQueryOptions`,\n    },\n    name: 'infiniteQueryOptions',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.queryOptions`,\n    },\n    name: 'queryOptions',\n  });\n  plugin.registerSymbol({\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.useQuery`,\n    },\n    name: 'useQuery',\n  });\n  plugin.registerSymbol({\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n    name: 'AxiosError',\n  });\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const classes = sdkPlugin.config.asClass\n        ? operationClasses({\n            context: plugin.context,\n            operation,\n            plugin: sdkPlugin,\n          })\n        : undefined;\n      const entry = classes ? classes.values().next().value : undefined;\n      // TODO: this should use class graph to determine correct path string\n      // as it's really easy to break once we change the class casing\n      let queryFn: string;\n      if (entry) {\n        const symbolClass = plugin.referenceSymbol({\n          category: 'utility',\n          resource: 'class',\n          resourceId: entry.path[0],\n          tool: 'sdk',\n        });\n        queryFn = [\n          symbolClass.placeholder,\n          ...(sdkPlugin.config.instance ? [registryName, 'get()'] : []),\n          ...entry.path.slice(1).map((className) =>\n            stringCase({\n              case: 'camelCase',\n              value: className,\n            }),\n          ),\n          entry.methodName,\n        ]\n          .filter(Boolean)\n          .join('.');\n      } else {\n        queryFn = plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }).placeholder;\n      }\n\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin, queryFn });\n        }\n\n        if (plugin.config.infiniteQueryOptions.enabled) {\n          createInfiniteQueryOptions({ operation, plugin, queryFn });\n        }\n\n        if ('useQuery' in plugin.config && plugin.config.useQuery.enabled) {\n          createUseQuery({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin, queryFn });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PluginHandler } from './types';\nimport { handlerV5 } from './v5/plugin';\n\nexport const handler: PluginHandler = (args) =>\n  handlerV5(args as Parameters<PluginHandler>[0]);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackAngularQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackAngularQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackAngularQueryPlugin['Handler'],\n  name: '@tanstack/angular-query-experimental',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/angular-query-experimental` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackReactQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackReactQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackReactQueryPlugin['Handler'],\n  name: '@tanstack/react-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useQuery = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: false,\n        name: 'use{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useQuery,\n    });\n\n    if (plugin.config.useQuery.enabled) {\n      // useQuery hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@tanstack/react-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackSolidQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSolidQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSolidQueryPlugin['Handler'],\n  name: '@tanstack/solid-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/solid-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackSvelteQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSvelteQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSvelteQueryPlugin['Handler'],\n  name: '@tanstack/svelte-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/svelte-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackVueQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackVueQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackVueQueryPlugin['Handler'],\n  name: '@tanstack/vue-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/vue-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  // const out = User({\n  //   name: \"Alan Turing\",\n  //   device: {\n  //     platform: \"enigma\",\n  //     versions: [0, \"1\", 0n]\n  //   }\n  // })\n  // if (out instanceof type.errors) {\n  //   // hover out.summary to see validation errors\n  //   console.error(out.summary)\n  // } else {\n  //   // hover out to see your validated data\n  //   console.log(`Hello, ${out.name}`)\n  // }\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do(\n      $(symbol.placeholder)\n        .attr('parseAsync')\n        .call(dataParameterName)\n        .await()\n        .return(),\n    );\n};\n\nexport const createResponseValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do(\n      $(symbol.placeholder)\n        .attr('parseAsync')\n        .call(dataParameterName)\n        .await()\n        .return(),\n    );\n};\n","import type { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV2, createResponseValidatorV2 } from './v2/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV2(args);\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV2(args);\n  }\n}\n","export const identifiers = {\n  keywords: {\n    false: 'false',\n    true: 'true',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#number Number}\n   */\n  number: {\n    Infinity: 'Infinity',\n    NaN: 'NaN',\n    NegativeInfinity: 'NegativeInfinity',\n    epoch: 'epoch',\n    integer: 'integer',\n    safe: 'safe',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives Primitives}\n   */\n  primitives: {\n    bigint: 'bigint',\n    boolean: 'boolean',\n    keywords: 'keywords',\n    null: 'null',\n    number: 'number',\n    string: 'string',\n    symbol: 'symbol',\n    undefined: 'undefined',\n    unit: 'unit',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#string String}\n   */\n  string: {\n    NFC: 'NFC',\n    NFD: 'NFD',\n    NFKC: 'NFKC',\n    NFKD: 'NFKD',\n    alpha: 'alpha',\n    alphanumeric: 'alphanumeric',\n    base64: 'base64',\n    capitalize: 'capitalize',\n    creditCard: 'creditCard',\n    date: 'date',\n    digits: 'digits',\n    email: 'email',\n    epoch: 'epoch',\n    hex: 'hex',\n    integer: 'integer',\n    ip: 'ip',\n    iso: 'iso',\n    json: 'json',\n    lower: 'lower',\n    normalize: 'normalize',\n    numeric: 'numeric',\n    parse: 'parse',\n    preformatted: 'preformatted',\n    regex: 'regex',\n    semver: 'semver',\n    trim: 'trim',\n    upper: 'upper',\n    url: 'url',\n    uuid: 'uuid',\n    v1: 'v1',\n    v2: 'v2',\n    v3: 'v3',\n    v4: 'v4',\n    v5: 'v5',\n    v6: 'v6',\n    v7: 'v7',\n    v8: 'v8',\n  },\n  /**\n   * {@link https://arktype.io/docs/type-api Type API}\n   */\n  type: {\n    $: '$',\n    allows: 'allows',\n    and: 'and',\n    array: 'array',\n    as: 'as',\n    assert: 'assert',\n    brand: 'brand',\n    configure: 'configure',\n    default: 'default',\n    describe: 'describe',\n    description: 'description',\n    equals: 'equals',\n    exclude: 'exclude',\n    expression: 'expression',\n    extends: 'extends',\n    extract: 'extract',\n    filter: 'filter',\n    from: 'from',\n    ifEquals: 'ifEquals',\n    ifExtends: 'ifExtends',\n    infer: 'infer',\n    inferIn: 'inferIn',\n    intersect: 'intersect',\n    json: 'json',\n    meta: 'meta',\n    narrow: 'narrow',\n    onDeepUndeclaredKey: 'onDeepUndeclaredKey',\n    onUndeclaredKey: 'onUndeclaredKey',\n    optional: 'optional',\n    or: 'or',\n    overlaps: 'overlaps',\n    pipe: 'pipe',\n    select: 'select',\n    to: 'to',\n    toJsonSchema: 'toJsonSchema',\n  },\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ArktypePlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ArktypePlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const type = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'arktype.type',\n  });\n\n  const statement = $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    // .type(\n    //   ast.typeName\n    //     ? (tsc.propertyAccessExpression({\n    //         expression: z.placeholder,\n    //         name: ast.typeName,\n    //       }) as unknown as ts.TypeNode)\n    //     : undefined,\n    // )\n    .assign(\n      $(type.placeholder).call(ast.def ? $.literal(ast.def) : ast.expression),\n    );\n  plugin.setSymbolValue(symbol, statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol.placeholder)\n      .export(typeInferSymbol.exported)\n      .type(\n        $.type(symbol.placeholder).attr(identifiers.type.infer).typeofType(),\n      );\n    plugin.setSymbolValue(typeInferSymbol, inferType);\n  }\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.def = identifiers.primitives.null;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\n// import { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // if (propertyAst.hasCircularReference) {\n    //   properties.push(\n    //     tsc.getAccessorDeclaration({\n    //       name: propertyName,\n    //       // @ts-expect-error\n    //       returnType: propertyAst.typeName\n    //         ? tsc.propertyAccessExpression({\n    //             expression: 'TODO',\n    //             name: propertyAst.typeName,\n    //           })\n    //         : undefined,\n    //       statements: [\n    //         tsc.returnStatement({\n    //           expression: propertyAst.expression,\n    //         }),\n    //       ],\n    //     }),\n    //   );\n    // } else {\n    //   properties.push(\n    //     tsc.propertyAssignment({\n    //       initializer: propertyAst.expression,\n    //       name: ts.factory.createComputedPropertyName(\n    //         ts.factory.createStringLiteral(`${propertyName}?`),\n    //       ),\n    //     }),\n    //   );\n    // }\n\n    shape.prop(isRequired ? name : `${name}?`, propertyAst.expression);\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    // name: identifiers.record,\n    result.expression = $('TODO').attr('record').call(\n      // name: identifiers.string,\n      $('TODO').attr('string').call(),\n      additionalAst.expression,\n    );\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // Return with typeName for circular references\n    if (result.hasLazyExpression) {\n      return {\n        ...result,\n        typeName: 'TODO',\n      } as Ast;\n    }\n\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = shape;\n\n  // return with typeName for circular references\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'TODO',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'string') {\n    result.def = schema.const;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  let def = identifiers.primitives.string;\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n      case 'date-time':\n      case 'time':\n        def = `${def}.${identifiers.string.date}.${identifiers.string.iso}`;\n        break;\n      case 'email':\n        def = `${def}.${identifiers.string.email}`;\n        break;\n      case 'ipv4':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v4}`;\n        break;\n      case 'ipv6':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v6}`;\n        break;\n      case 'uri':\n        def = `${def}.${identifiers.string.url}`;\n        break;\n      case 'uuid':\n        def = `${def}.${identifiers.string.uuid}`;\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    def = `${schema.minLength} <= ${def} <= ${schema.maxLength}`;\n  } else {\n    if (schema.maxLength !== undefined) {\n      def = `${def} <= ${schema.maxLength}`;\n\n      if (schema.minLength !== undefined) {\n        def = `${schema.minLength} <= ${def}`;\n      }\n    } else if (schema.minLength !== undefined) {\n      def = `${def} >= ${schema.minLength}`;\n    }\n  }\n\n  if (schema.pattern) {\n    def = `/${schema.pattern}/`;\n  }\n\n  result.def = def;\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { $ } from '~/ts-dsl';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { nullToAst } from './null';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\n// import { arrayToAst } from \"./array\";\n// import { booleanToAst } from \"./boolean\";\n// import { enumToAst } from \"./enum\";\n// import { neverToAst } from \"./never\";\n// import { numberToAst } from \"./number\";\n// import { tupleToAst } from \"./tuple\";\n// import { undefinedToAst } from \"./undefined\";\n// import { unknownToAst } from \"./unknown\";\n// import { voidToAst } from \"./void\";\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    // case 'array':\n    //   return arrayToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'array'>,\n    //   });\n    // case 'boolean':\n    //   return booleanToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'boolean'>,\n    //   });\n    // case 'enum':\n    //   return enumToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'enum'>,\n    //   });\n    // case 'integer':\n    // case 'number':\n    //   return numberToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'integer' | 'number'>,\n    //   });\n    // case 'never':\n    //   return neverToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'never'>,\n    //   });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    // case 'tuple':\n    //   return tupleToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'tuple'>,\n    //   });\n    // case 'undefined':\n    //   return undefinedToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'undefined'>,\n    //   });\n    // case 'unknown':\n    //   return unknownToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'unknown'>,\n    //   });\n    // case 'void':\n    //   return voidToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'void'>,\n    //   });\n  }\n\n  const type = args.plugin.referenceSymbol({\n    category: 'external',\n    resource: 'arktype.type',\n  });\n\n  const expression = $(type.placeholder).call(\n    $.object()\n      .prop('name', $.literal('string'))\n      .prop('platform', $.literal(\"'android' | 'ios'\"))\n      .prop('versions?', $.literal('(number | string)[]')),\n  );\n\n  return {\n    def: '',\n    expression,\n    hasLazyExpression: false,\n  };\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport type { ArktypePlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  // optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  // const z = plugin.referenceSymbol({\n  //   category: 'external',\n  //   resource: 'arktype.type',\n  // });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'arktype',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol.placeholder);\n      ast.expression = ref;\n    } else {\n      // expression: z.placeholder,\n      // name: identifiers.lazy,\n      const lazyExpression = $('TODO')\n        .attr('TODO')\n        .call($.func().returns('any').do($.return(refSymbol.placeholder)));\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      // TODO: add description\n      // ast.expression = tsc.callExpression({\n      //   functionName: tsc.propertyAccessExpression({\n      //     expression: ast.expression,\n      //     name: identifiers.register,\n      //   }),\n      //   parameters: [\n      //     tsc.propertyAccessExpression({\n      //       expression: z.placeholder,\n      //       name: identifiers.globalRegistry,\n      //     }),\n      //     tsc.objectExpression({\n      //       obj: [\n      //         {\n      //           key: 'description',\n      //           value: tsc.stringLiteral({ text: schema.description }),\n      //         },\n      //       ],\n      //     }),\n      //   ],\n      // });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      //     const itemSchemas = schema.items.map((item, index) =>\n      //       irSchemaToAst({\n      //         plugin,\n      //         schema: item,\n      //         state: {\n      //           ...state,\n      //           _path: [...state._path, 'items', index],\n      //         },\n      //       }),\n      //     );\n      //     if (schema.logicalOperator === 'and') {\n      //       const firstSchema = schema.items[0]!;\n      //       // we want to add an intersection, but not every schema can use the same API.\n      //       // if the first item contains another array or not an object, we cannot use\n      //       // `.merge()` as that does not exist on `.union()` and non-object schemas.\n      //       if (\n      //         firstSchema.logicalOperator === 'or' ||\n      //         (firstSchema.type && firstSchema.type !== 'object')\n      //       ) {\n      //         ast.expression = tsc.callExpression({\n      //           functionName: tsc.propertyAccessExpression({\n      //             expression: z.placeholder,\n      //             name: identifiers.intersection,\n      //           }),\n      //           parameters: itemSchemas.map((schema) => schema.expression),\n      //         });\n      //       } else {\n      //         ast.expression = itemSchemas[0]!.expression;\n      //         itemSchemas.slice(1).forEach((schema) => {\n      //           ast.expression = tsc.callExpression({\n      //             functionName: tsc.propertyAccessExpression({\n      //               expression: ast.expression!,\n      //               name: identifiers.and,\n      //             }),\n      //             parameters: [\n      //               schema.hasCircularReference\n      //                 ? tsc.callExpression({\n      //                     functionName: tsc.propertyAccessExpression({\n      //                       expression: z.placeholder,\n      //                       name: identifiers.lazy,\n      //                     }),\n      //                     parameters: [\n      //                       tsc.arrowFunction({\n      //                         statements: [\n      //                           tsc.returnStatement({\n      //                             expression: schema.expression,\n      //                           }),\n      //                         ],\n      //                       }),\n      //                     ],\n      //                   })\n      //                 : schema.expression,\n      //             ],\n      //           });\n      //         });\n      //       }\n      //     } else {\n      //       ast.expression = tsc.callExpression({\n      //         functionName: tsc.propertyAccessExpression({\n      //           expression: z.placeholder,\n      //           name: identifiers.union,\n      //         }),\n      //         parameters: [\n      //           tsc.arrayLiteralExpression({\n      //             elements: itemSchemas.map((schema) => schema.expression),\n      //           }),\n      //         ],\n      //       });\n      //     }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n  }\n\n  // TODO: remove later\n  if (!ast.expression) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n  // END TODO: remove later\n\n  // if (ast.expression) {\n  //   if (schema.accessScope === 'read') {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: ast.expression,\n  //         name: identifiers.readonly,\n  //       }),\n  //     });\n  //   }\n\n  //   if (optional) {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: z.placeholder,\n  //         name: identifiers.optional,\n  //       }),\n  //       parameters: [ast.expression],\n  //     });\n  //     ast.typeName = identifiers.ZodOptional;\n  //   }\n\n  //   if (schema.default !== undefined) {\n  //     const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n  //     const callParameter = numberParameter({\n  //       isBigInt,\n  //       value: schema.default,\n  //     });\n  //     if (callParameter) {\n  //       ast.expression = tsc.callExpression({\n  //         functionName: tsc.propertyAccessExpression({\n  //           expression: ast.expression,\n  //           name: identifiers.default,\n  //         }),\n  //         parameters: [callParameter],\n  //       });\n  //     }\n  //   }\n  // }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'schema',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'arktype',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'definition',\n          resourceId: $ref,\n          tool: 'arktype',\n          variant: 'infer',\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV2: ArktypePlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'arktype',\n    meta: {\n      category: 'external',\n      resource: 'arktype.type',\n    },\n    name: 'type',\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        //   case 'operation':\n        //     operationToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        //   case 'webhook':\n        //     webhookToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n      }\n    },\n  );\n};\n","import type { ArktypePlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: ArktypePlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ArktypePlugin } from './types';\n\nexport const defaultConfig: ArktypePlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'arktype',\n  resolveConfig: (plugin, context) => {\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Data',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Response',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequest',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Arktype plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { operationResponsesMap } from '~/ir/operation';\nimport { hasParameterGroupObjectRequired } from '~/ir/parameter';\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { FastifyPlugin } from './types';\n\nconst operationToRouteHandler = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: FastifyPlugin['Instance'];\n}) => {\n  const type = $.type.object();\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  if (symbolDataType) {\n    if (operation.body) {\n      type.prop('Body', (p) =>\n        p\n          .required(operation.body!.required)\n          .type($.type(symbolDataType.placeholder).idx($.type.literal('body'))),\n      );\n    }\n\n    if (operation.parameters) {\n      if (operation.parameters.header) {\n        type.prop('Headers', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.header),\n            )\n            .type(\n              $.type(symbolDataType.placeholder).idx($.type.literal('headers')),\n            ),\n        );\n      }\n\n      if (operation.parameters.path) {\n        type.prop('Params', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.path),\n            )\n            .type(\n              $.type(symbolDataType.placeholder).idx($.type.literal('path')),\n            ),\n        );\n      }\n\n      if (operation.parameters.query) {\n        type.prop('Querystring', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.query),\n            )\n            .type(\n              $.type(symbolDataType.placeholder).idx($.type.literal('query')),\n            ),\n        );\n      }\n    }\n  }\n\n  const { errors, responses } = operationResponsesMap(operation);\n\n  let errorsTypeReference: ReturnType<typeof $.type> | undefined;\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'errors',\n  });\n  if (symbolErrorType && errors && errors.properties) {\n    const keys = Object.keys(errors.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        errorsTypeReference = $.type(symbolErrorType.placeholder);\n      } else if (keys.length > 1) {\n        errorsTypeReference = $.type('Omit', (t) =>\n          t.generics(\n            $.type(symbolErrorType.placeholder),\n            $.type.literal('default'),\n          ),\n        );\n      }\n    }\n  }\n\n  let responsesTypeReference: ReturnType<typeof $.type> | undefined = undefined;\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n  });\n  if (symbolResponseType && responses && responses.properties) {\n    const keys = Object.keys(responses.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        responsesTypeReference = $.type(symbolResponseType.placeholder);\n      } else if (keys.length > 1) {\n        responsesTypeReference = $.type('Omit', (t) =>\n          t.generics(\n            $.type(symbolResponseType.placeholder),\n            $.type.literal('default'),\n          ),\n        );\n      }\n    }\n  }\n\n  const replyTypes = [errorsTypeReference, responsesTypeReference].filter(\n    (t): t is ReturnType<typeof $.type> => t !== undefined,\n  );\n  if (replyTypes.length) {\n    type.prop('Reply', (p) => p.type($.type.and(...replyTypes)));\n  }\n\n  if (type.isEmpty) {\n    return;\n  }\n\n  const symbolRouteHandler = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'route-handler',\n    tool: 'fastify',\n  });\n  return {\n    name: operation.id,\n    type: $.type(symbolRouteHandler.placeholder, (t) => t.generic(type)),\n  };\n};\n\nexport const handler: FastifyPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'fastify',\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'route-handler',\n      tool: 'fastify',\n    },\n    name: 'RouteHandler',\n  });\n\n  const symbolRouteHandlers = plugin.registerSymbol({\n    exported: true,\n    kind: 'type',\n    name: 'RouteHandlers',\n  });\n\n  const type = $.type.object();\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const routeHandler = operationToRouteHandler({ operation, plugin });\n      if (routeHandler) {\n        type.prop(routeHandler.name, (p) => p.type(routeHandler.type));\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const node = $.type\n    .alias(symbolRouteHandlers.placeholder)\n    .export(symbolRouteHandlers.exported)\n    .type(type);\n  plugin.setSymbolValue(symbolRouteHandlers, node);\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { FastifyPlugin } from './types';\n\nexport const defaultConfig: FastifyPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: 'fastify',\n};\n\n/**\n * Type helper for `fastify` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport {\n  createOperationComment,\n  hasOperationSse,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { SwrPlugin } from '../types';\n\nexport const createUseSwr = ({\n  operation,\n  plugin,\n  queryFn,\n}: {\n  operation: IR.OperationObject;\n  plugin: SwrPlugin['Instance'];\n  queryFn: string;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const symbolUseSwr = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'swr',\n  });\n  const symbolUseQueryFn = plugin.registerSymbol({\n    exported: true,\n    name: buildName({\n      config: plugin.config.useSwr,\n      name: operation.id,\n    }),\n  });\n\n  const awaitSdkFn = $(queryFn)\n    .call($.object().prop('throwOnError', $.literal(true)))\n    .await();\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const statement = $.const(symbolUseQueryFn.placeholder)\n    .export(symbolUseQueryFn.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func().do(\n        $(symbolUseSwr.placeholder)\n          .call(\n            $.literal(operation.path),\n            $.func()\n              .async()\n              .do(...statements),\n          )\n          .return(),\n      ),\n    );\n  plugin.setSymbolValue(symbolUseQueryFn, statement);\n};\n","import { registryName } from '~/plugins/@hey-api/sdk/shared/class';\nimport { operationClasses } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { SwrPlugin } from '../types';\nimport { createUseSwr } from './useSwr';\n\nexport const handlerV2: SwrPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'swr',\n    importKind: 'default',\n    kind: 'function',\n    meta: {\n      category: 'external',\n      resource: 'swr',\n    },\n    name: 'useSWR',\n  });\n\n  const sdkPlugin = plugin.getPluginOrThrow('@hey-api/sdk');\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const classes = sdkPlugin.config.asClass\n        ? operationClasses({\n            context: plugin.context,\n            operation,\n            plugin: sdkPlugin,\n          })\n        : undefined;\n      const entry = classes ? classes.values().next().value : undefined;\n      // TODO: this should use class graph to determine correct path string\n      // as it's really easy to break once we change the class casing\n      let queryFn: string;\n      if (entry) {\n        const symbolClass = plugin.referenceSymbol({\n          category: 'utility',\n          resource: 'class',\n          resourceId: entry.path[0],\n          tool: 'sdk',\n        });\n        queryFn = [\n          symbolClass.placeholder,\n          ...(sdkPlugin.config.instance ? [registryName, 'get()'] : []),\n          ...entry.path.slice(1).map((className) =>\n            stringCase({\n              case: 'camelCase',\n              value: className,\n            }),\n          ),\n          entry.methodName,\n        ]\n          .filter(Boolean)\n          .join('.');\n      } else {\n        queryFn = plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }).placeholder;\n      }\n\n      if (plugin.hooks.operation.isQuery(operation)) {\n        // if (plugin.config.queryOptions.enabled) {\n        //   createQueryOptions({ operation, plugin, queryFn });\n        // }\n\n        // if (plugin.config.infiniteQueryOptions.enabled) {\n        //   createInfiniteQueryOptions({ operation, plugin, queryFn });\n        // }\n\n        if (plugin.config.useSwr.enabled) {\n          createUseSwr({ operation, plugin, queryFn });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { SwrPlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: SwrPlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { SwrPlugin } from './types';\n\nexport const defaultConfig: SwrPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as SwrPlugin['Handler'],\n  name: 'swr',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useSwr = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'use{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useSwr,\n    });\n\n    if (plugin.config.useSwr.enabled) {\n      // useSwr hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `swr` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const identifiers = {\n  /**\n   * {@link https://valibot.dev/api/#actions Actions}\n   */\n  actions: {\n    args: 'args',\n    base64: 'base64',\n    bic: 'bic',\n    brand: 'brand',\n    bytes: 'bytes',\n    check: 'check',\n    checkItems: 'checkItems',\n    creditCard: 'creditCard',\n    cuid2: 'cuid2',\n    decimal: 'decimal',\n    description: 'description',\n    digits: 'digits',\n    email: 'email',\n    emoji: 'emoji',\n    empty: 'empty',\n    endsWith: 'endsWith',\n    entries: 'entries',\n    everyItem: 'everyItem',\n    excludes: 'excludes',\n    filterItems: 'filterItems',\n    findItem: 'findItem',\n    finite: 'finite',\n    flavor: 'flavor',\n    graphemes: 'graphemes',\n    gtValue: 'gtValue',\n    hash: 'hash',\n    hexColor: 'hexColor',\n    hexadecimal: 'hexadecimal',\n    imei: 'imei',\n    includes: 'includes',\n    integer: 'integer',\n    ip: 'ip',\n    ipv4: 'ipv4',\n    ipv6: 'ipv6',\n    isoDate: 'isoDate',\n    isoDateTime: 'isoDateTime',\n    isoTime: 'isoTime',\n    isoTimeSecond: 'isoTimeSecond',\n    isoTimestamp: 'isoTimestamp',\n    isoWeek: 'isoWeek',\n    length: 'length',\n    ltValue: 'ltValue',\n    mac: 'mac',\n    mac48: 'mac48',\n    mac64: 'mac64',\n    mapItems: 'mapItems',\n    maxBytes: 'maxBytes',\n    maxEntries: 'maxEntries',\n    maxGraphemes: 'maxGraphemes',\n    maxLength: 'maxLength',\n    maxSize: 'maxSize',\n    maxValue: 'maxValue',\n    maxWords: 'maxWords',\n    metadata: 'metadata',\n    mimeType: 'mimeType',\n    minBytes: 'minBytes',\n    minEntries: 'minEntries',\n    minGraphemes: 'minGraphemes',\n    minLength: 'minLength',\n    minSize: 'minSize',\n    minValue: 'minValue',\n    minWords: 'minWords',\n    multipleOf: 'multipleOf',\n    nanoid: 'nanoid',\n    nonEmpty: 'nonEmpty',\n    normalize: 'normalize',\n    notBytes: 'notBytes',\n    notEntries: 'notEntries',\n    notGraphemes: 'notGraphemes',\n    notLength: 'notLength',\n    notSize: 'notSize',\n    notValue: 'notValue',\n    notValues: 'notValues',\n    notWords: 'notWords',\n    octal: 'octal',\n    parseJson: 'parseJson',\n    partialCheck: 'partialCheck',\n    rawCheck: 'rawCheck',\n    rawTransform: 'rawTransform',\n    readonly: 'readonly',\n    reduceItems: 'reduceItems',\n    regex: 'regex',\n    returns: 'returns',\n    rfcEmail: 'rfcEmail',\n    safeInteger: 'safeInteger',\n    size: 'size',\n    slug: 'slug',\n    someItem: 'someItem',\n    sortItems: 'sortItems',\n    startsWith: 'startsWith',\n    stringifyJson: 'stringifyJson',\n    title: 'title',\n    toLowerCase: 'toLowerCase',\n    toMaxValue: 'toMaxValue',\n    toMinValue: 'toMinValue',\n    toUpperCase: 'toUpperCase',\n    transform: 'transform',\n    trim: 'trim',\n    trimEnd: 'trimEnd',\n    trimStart: 'trimStart',\n    ulid: 'ulid',\n    url: 'url',\n    uuid: 'uuid',\n    value: 'value',\n    values: 'values',\n    words: 'words',\n  },\n  /**\n   * {@link https://valibot.dev/api/#async Async}\n   */\n  async: {\n    argsAsync: 'argsAsync',\n    arrayAsync: 'arrayAsync',\n    awaitAsync: 'awaitAsync',\n    checkAsync: 'checkAsync',\n    checkItemsAsync: 'checkItemsAsync',\n    customAsync: 'customAsync',\n    exactOptionalAsync: 'exactOptionalAsync',\n    fallbackAsync: 'fallbackAsync',\n    forwardAsync: 'forwardAsync',\n    getDefaultsAsync: 'getDefaultsAsync',\n    getFallbacksAsync: 'getFallbacksAsync',\n    intersectAsync: 'intersectAsync',\n    lazyAsync: 'lazyAsync',\n    looseObjectAsync: 'looseObjectAsync',\n    looseTupleAsync: 'looseTupleAsync',\n    mapAsync: 'mapAsync',\n    nonNullableAsync: 'nonNullableAsync',\n    nonNullishAsync: 'nonNullishAsync',\n    nonOptionalAsync: 'nonOptionalAsync',\n    nullableAsync: 'nullableAsync',\n    nullishAsync: 'nullishAsync',\n    objectAsync: 'objectAsync',\n    objectWithRestAsync: 'objectWithRestAsync',\n    optionalAsync: 'optionalAsync',\n    parseAsync: 'parseAsync',\n    parserAsync: 'parserAsync',\n    partialAsync: 'partialAsync',\n    partialCheckAsync: 'partialCheckAsync',\n    pipeAsync: 'pipeAsync',\n    rawCheckAsync: 'rawCheckAsync',\n    rawTransformAsync: 'rawTransformAsync',\n    recordAsync: 'recordAsync',\n    requiredAsync: 'requiredAsync',\n    returnsAsync: 'returnsAsync',\n    safeParseAsync: 'safeParseAsync',\n    safeParserAsync: 'safeParserAsync',\n    setAsync: 'setAsync',\n    strictObjectAsync: 'strictObjectAsync',\n    strictTupleAsync: 'strictTupleAsync',\n    transformAsync: 'transformAsync',\n    tupleAsync: 'tupleAsync',\n    tupleWithRestAsync: 'tupleWithRestAsync',\n    undefinedableAsync: 'undefinedableAsync',\n    unionAsync: 'unionAsync',\n    variantAsync: 'variantAsync',\n  },\n  /**\n   * {@link https://valibot.dev/api/#methods Methods}\n   */\n  methods: {\n    assert: 'assert',\n    config: 'config',\n    fallback: 'fallback',\n    flatten: 'flatten',\n    forward: 'forward',\n    getDefault: 'getDefault',\n    getDefaults: 'getDefaults',\n    getDescription: 'getDescription',\n    getFallback: 'getFallback',\n    getFallbacks: 'getFallbacks',\n    getMetadata: 'getMetadata',\n    getTitle: 'getTitle',\n    is: 'is',\n    keyof: 'keyof',\n    message: 'message',\n    omit: 'omit',\n    parse: 'parse',\n    parser: 'parser',\n    partial: 'partial',\n    pick: 'pick',\n    pipe: 'pipe',\n    required: 'required',\n    safeParse: 'safeParse',\n    safeParser: 'safeParser',\n    summarize: 'summarize',\n    unwrap: 'unwrap',\n  },\n  /**\n   * {@link https://valibot.dev/api/#schemas Schemas}\n   */\n  schemas: {\n    any: 'any',\n    array: 'array',\n    bigInt: 'bigint',\n    blob: 'blob',\n    boolean: 'boolean',\n    custom: 'custom',\n    date: 'date',\n    enum: 'enum',\n    exactOptional: 'exactOptional',\n    file: 'file',\n    function: 'function',\n    instance: 'instance',\n    intersect: 'intersect',\n    lazy: 'lazy',\n    literal: 'literal',\n    looseObject: 'looseObject',\n    looseTuple: 'looseTuple',\n    map: 'map',\n    nan: 'nan',\n    never: 'never',\n    nonNullable: 'nonNullable',\n    nonNullish: 'nonNullish',\n    nonOptional: 'nonOptional',\n    null: 'null',\n    nullable: 'nullable',\n    nullish: 'nullish',\n    number: 'number',\n    object: 'object',\n    objectWithRest: 'objectWithRest',\n    optional: 'optional',\n    picklist: 'picklist',\n    promise: 'promise',\n    record: 'record',\n    set: 'set',\n    strictObject: 'strictObject',\n    strictTuple: 'strictTuple',\n    string: 'string',\n    symbol: 'symbol',\n    tuple: 'tuple',\n    tupleWithRest: 'tupleWithRest',\n    undefined: 'undefined',\n    undefinedable: 'undefinedable',\n    union: 'union',\n    unknown: 'unknown',\n    variant: 'variant',\n    void: 'void',\n  },\n  /**\n   * {@link https://valibot.dev/api/#storages Storages}\n   */\n  storages: {\n    // TODO: implement if necessary\n  },\n  /**\n   * {@link https://valibot.dev/api/#types Types}\n   */\n  types: {\n    // TODO: implement if necessary\n    GenericSchema: 'GenericSchema',\n  },\n  /**\n   * {@link https://valibot.dev/api/#utils Utils}\n   */\n  utils: {\n    // TODO: implement if necessary\n  },\n};\n","import { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverArgs } from '../types';\nimport { identifiers } from './constants';\n\nconst defaultValidatorResolver = ({\n  schema,\n  v,\n}: ValidatorResolverArgs): ReturnType<typeof $.return> =>\n  $(v.placeholder)\n    .attr(identifiers.async.parseAsync)\n    .call(schema.placeholder, 'data')\n    .await()\n    .return();\n\nexport const createRequestValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const args: ValidatorResolverArgs = {\n    $,\n    operation,\n    pipes: [],\n    plugin,\n    schema: symbol,\n    v,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const args: ValidatorResolverArgs = {\n    $,\n    operation,\n    pipes: [],\n    plugin,\n    schema: symbol,\n    v,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV1, createResponseValidatorV1 } from './v1/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV1(args);\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV1(args);\n  }\n}\n","import { $ } from '~/ts-dsl';\n\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from '../v1/constants';\n\nexport const pipesToAst = ({\n  pipes,\n  plugin,\n}: {\n  pipes: ReadonlyArray<ReturnType<typeof $.call | typeof $.expr>>;\n  plugin: ValibotPlugin['Instance'];\n}): ReturnType<typeof $.call | typeof $.expr> => {\n  if (pipes.length === 1) {\n    return pipes[0]!;\n  }\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  return $(v.placeholder)\n    .attr(identifiers.methods.pipe)\n    .call(...pipes);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../v1/constants';\nimport { pipesToAst } from './pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  state,\n  symbol,\n}: IrSchemaToAstOptions & {\n  ast: Ast;\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n}): void => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const statement = $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    .$if(state.hasLazyExpression.value, (c) =>\n      c.type(\n        $.type(v.placeholder).attr(\n          ast.typeName || identifiers.types.GenericSchema,\n        ),\n      ),\n    )\n    .assign(pipesToAst({ pipes: ast.pipes, plugin }));\n  plugin.setSymbolValue(symbol, statement);\n};\n","import { $ } from '~/ts-dsl';\n\nexport const INTEGER_FORMATS = {\n  int16: {\n    max: 32767,\n    maxError: 'Invalid value: Expected int16 to be <= 2^15-1',\n    min: -32768,\n    minError: 'Invalid value: Expected int16 to be >= -2^15',\n    needsBigInt: false,\n  },\n  int32: {\n    max: 2147483647,\n    maxError: 'Invalid value: Expected int32 to be <= 2^31-1',\n    min: -2147483648,\n    minError: 'Invalid value: Expected int32 to be >= -2^31',\n    needsBigInt: false,\n  },\n  int64: {\n    max: '9223372036854775807',\n    maxError: 'Invalid value: Expected int64 to be <= 2^63-1',\n    min: '-9223372036854775808',\n    minError: 'Invalid value: Expected int64 to be >= -2^63',\n    needsBigInt: true,\n  },\n  int8: {\n    max: 127,\n    maxError: 'Invalid value: Expected int8 to be <= 2^7-1',\n    min: -128,\n    minError: 'Invalid value: Expected int8 to be >= -2^7',\n    needsBigInt: false,\n  },\n  uint16: {\n    max: 65535,\n    maxError: 'Invalid value: Expected uint16 to be <= 2^16-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint16 to be >= 0',\n    needsBigInt: false,\n  },\n  uint32: {\n    max: 4294967295,\n    maxError: 'Invalid value: Expected uint32 to be <= 2^32-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint32 to be >= 0',\n    needsBigInt: false,\n  },\n  uint64: {\n    max: '18446744073709551615',\n    maxError: 'Invalid value: Expected uint64 to be <= 2^64-1',\n    min: '0',\n    minError: 'Invalid value: Expected uint64 to be >= 0',\n    needsBigInt: true,\n  },\n  uint8: {\n    max: 255,\n    maxError: 'Invalid value: Expected uint8 to be <= 2^8-1',\n    min: 0,\n    minError: 'Invalid value: Expected uint8 to be >= 0',\n    needsBigInt: false,\n  },\n} as const;\n\nexport type IntegerFormat = keyof typeof INTEGER_FORMATS;\n\nexport const isIntegerFormat = (\n  format: string | undefined,\n): format is IntegerFormat => format !== undefined && format in INTEGER_FORMATS;\n\nexport const needsBigIntForFormat = (format: string | undefined): boolean =>\n  isIntegerFormat(format) && INTEGER_FORMATS[format].needsBigInt;\n\nexport const numberParameter = ({\n  isBigInt,\n  value,\n}: {\n  isBigInt: boolean;\n  value: unknown;\n}): ReturnType<typeof $.call | typeof $.fromValue> => {\n  const expression = $.fromValue(value);\n\n  if (\n    isBigInt &&\n    (typeof value === 'bigint' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean')\n  ) {\n    return $('BigInt').call(expression);\n  }\n\n  return expression;\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        path: state.path.value,\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tags: state.tags?.value,\n        tool: 'valibot',\n      },\n      name: buildName({\n        config: plugin.config.requests,\n        name: operation.id,\n      }),\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...state.path.value, 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.registerSymbol({\n          exported: true,\n          meta: {\n            category: 'schema',\n            path,\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'responses',\n            tags: state.tags?.value,\n            tool: 'valibot',\n          },\n          name: buildName({\n            config: plugin.config.responses,\n            name: operation.id,\n          }),\n        });\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          state,\n          symbol,\n        });\n      }\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        path: state.path.value,\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: state.tags?.value,\n        tool: 'valibot',\n      },\n      name: buildName({\n        config: plugin.config.webhooks,\n        name: operation.id,\n      }),\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v.placeholder).attr(identifiers.schemas.unknown).call();\n  return expression;\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Omit<Ast, 'typeName'> = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const functionName = $(v.placeholder).attr(identifiers.schemas.array);\n\n  if (!schema.items) {\n    const expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n    result.pipes.push(expression);\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToAst({ pipes: itemAst.pipes, plugin });\n    });\n\n    if (itemExpressions.length === 1) {\n      const expression = functionName.call(...itemExpressions);\n      result.pipes.push(expression);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        // TODO: parser - handle intersection\n        // return tsc.typeArrayNode(\n        //   tsc.typeIntersectionNode({ types: itemExpressions }),\n        // );\n      }\n\n      // TODO: parser - handle union\n      // return tsc.typeArrayNode(tsc.typeUnionNode({ types: itemExpressions }));\n\n      const expression = functionName.call(\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }),\n      );\n      result.pipes.push(expression);\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.length)\n      .call($.fromValue(schema.minItems));\n    result.pipes.push(expression);\n  } else {\n    if (schema.minItems !== undefined) {\n      const expression = $(v.placeholder)\n        .attr(identifiers.actions.minLength)\n        .call($.fromValue(schema.minItems));\n      result.pipes.push(expression);\n    }\n\n    if (schema.maxItems !== undefined) {\n      const expression = $(v.placeholder)\n        .attr(identifiers.actions.maxLength)\n        .call($.fromValue(schema.maxItems));\n      result.pipes.push(expression);\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call | typeof $.expr> => {\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    pipes.push(\n      $(v.placeholder)\n        .attr(identifiers.schemas.literal)\n        .call($.literal(schema.const)),\n    );\n    return pipesToAst({ pipes, plugin });\n  }\n\n  pipes.push($(v.placeholder).attr(identifiers.schemas.boolean).call());\n  return pipesToAst({ pipes, plugin });\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ReturnType<typeof $.call> => {\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n\n  let isNullable = false;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports only string enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      enumMembers.push($.literal(item.const));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!enumMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  let resultExpression = $(v.placeholder)\n    .attr(identifiers.schemas.picklist)\n    .call($.array(...enumMembers));\n\n  if (isNullable) {\n    resultExpression = $(v.placeholder)\n      .attr(identifiers.schemas.nullable)\n      .call(resultExpression);\n  }\n\n  return resultExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const expression = $(v.placeholder).attr(identifiers.schemas.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const expression = $(v.placeholder).attr(identifiers.schemas.null).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport {\n  INTEGER_FORMATS,\n  isIntegerFormat,\n  needsBigIntForFormat,\n  numberParameter,\n} from '../../shared/numbers';\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}) => {\n  const format = schema.format;\n  const isInteger = schema.type === 'integer';\n  const isBigInt = needsBigIntForFormat(format);\n  const formatInfo = isIntegerFormat(format) ? INTEGER_FORMATS[format] : null;\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  // Return early if const is defined since we can create a literal type directly without additional validation\n  if (schema.const !== undefined && schema.const !== null) {\n    const constValue = schema.const;\n    let literalValue: ReturnType<typeof $.fromValue>;\n\n    // Case 1: Number with no format -> generate literal with the number\n    if (typeof constValue === 'number' && !format) {\n      literalValue = $.literal(constValue);\n    }\n    // Case 2: Number with format -> check if format needs BigInt, generate appropriate literal\n    else if (typeof constValue === 'number' && format) {\n      if (isBigInt) {\n        // Format requires BigInt, convert number to BigInt\n        literalValue = $('BigInt').call($.literal(constValue));\n      } else {\n        // Regular format, use number as-is\n        literalValue = $.literal(constValue);\n      }\n    }\n    // Case 3: Format that allows string -> generate BigInt literal (for int64/uint64 formats)\n    else if (typeof constValue === 'string' && isBigInt) {\n      // Remove 'n' suffix if present in string\n      const cleanString = constValue.endsWith('n')\n        ? constValue.slice(0, -1)\n        : constValue;\n      literalValue = $('BigInt').call($.literal(cleanString));\n    }\n    // Case 4: Const is typeof bigint (literal) -> transform from literal to BigInt()\n    else if (typeof constValue === 'bigint') {\n      // Convert BigInt to string and remove 'n' suffix that toString() adds\n      const bigintString = constValue.toString();\n      const cleanString = bigintString.endsWith('n')\n        ? bigintString.slice(0, -1)\n        : bigintString;\n      literalValue = $('BigInt').call($.literal(cleanString));\n    }\n    // Default case: use value as-is for other types\n    else {\n      literalValue = $.fromValue(constValue);\n    }\n\n    return $(v.placeholder)\n      .attr(identifiers.schemas.literal)\n      .call(literalValue);\n  }\n\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  // For bigint formats (int64, uint64), create union of number, string, and bigint with transform\n  if (isBigInt) {\n    const unionExpression = $(v.placeholder)\n      .attr(identifiers.schemas.union)\n      .call(\n        $.array(\n          $(v.placeholder).attr(identifiers.schemas.number).call(),\n          $(v.placeholder).attr(identifiers.schemas.string).call(),\n          $(v.placeholder).attr(identifiers.schemas.bigInt).call(),\n        ),\n      );\n    pipes.push(unionExpression);\n\n    // Add transform to convert to BigInt\n    const transformExpression = $(v.placeholder)\n      .attr(identifiers.actions.transform)\n      .call($.func().param('x').do($('BigInt').call('x').return()));\n    pipes.push(transformExpression);\n  } else {\n    // For regular number formats, use number schema\n    const expression = $(v.placeholder).attr(identifiers.schemas.number).call();\n    pipes.push(expression);\n  }\n\n  // Add integer validation for integer types (except when using bigint union)\n  if (!isBigInt && isInteger) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.integer)\n      .call();\n    pipes.push(expression);\n  }\n\n  // Add format-specific range validations\n  if (formatInfo) {\n    const minValue = formatInfo.min;\n    const maxValue = formatInfo.max;\n    const minErrorMessage = formatInfo.minError;\n    const maxErrorMessage = formatInfo.maxError;\n\n    // Add minimum value validation\n    const minExpression = $(v.placeholder)\n      .attr(identifiers.actions.minValue)\n      .call(\n        isBigInt ? $('BigInt').call($.literal(minValue)) : $.literal(minValue),\n        $.literal(minErrorMessage),\n      );\n    pipes.push(minExpression);\n\n    // Add maximum value validation\n    const maxExpression = $(v.placeholder)\n      .attr(identifiers.actions.maxValue)\n      .call(\n        isBigInt ? $('BigInt').call($.literal(maxValue)) : $.literal(maxValue),\n        $.literal(maxErrorMessage),\n      );\n    pipes.push(maxExpression);\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.gtValue)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMinimum }));\n    pipes.push(expression);\n  } else if (schema.minimum !== undefined) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.minValue)\n      .call(numberParameter({ isBigInt, value: schema.minimum }));\n    pipes.push(expression);\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.ltValue)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMaximum }));\n    pipes.push(expression);\n  } else if (schema.maximum !== undefined) {\n    const expression = $(v.placeholder)\n      .attr(identifiers.actions.maxValue)\n      .call(numberParameter({ isBigInt, value: schema.maximum }));\n    pipes.push(expression);\n  }\n\n  return pipesToAst({ pipes, plugin });\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectBaseResolverArgs } from '../../types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\n\nfunction defaultObjectBaseResolver({\n  additional,\n  pipes,\n  plugin,\n  shape,\n}: ObjectBaseResolverArgs): number {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  // Handle `additionalProperties: { type: 'never' }` ‚Üí v.strictObject()\n  if (additional === null) {\n    return pipes.push(\n      $(v.placeholder).attr(identifiers.schemas.strictObject).call(shape),\n    );\n  }\n\n  // Handle additionalProperties as schema ‚Üí v.record() or v.objectWithRest()\n  if (additional) {\n    if (shape.isEmpty) {\n      return pipes.push(\n        $(v.placeholder)\n          .attr(identifiers.schemas.record)\n          .call(\n            $(v.placeholder).attr(identifiers.schemas.string).call(),\n            additional,\n          ),\n      );\n    }\n\n    // If there are named properties, use v.objectWithRest() to validate both\n    return pipes.push(\n      $(v.placeholder)\n        .attr(identifiers.schemas.objectWithRest)\n        .call(shape, additional),\n    );\n  }\n\n  // Default case ‚Üí v.object()\n  return pipes.push(\n    $(v.placeholder).attr(identifiers.schemas.object).call(shape),\n  );\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) result.hasLazyExpression = true;\n\n    shape.prop(name, pipesToAst({ pipes: propertyAst.pipes, plugin }));\n  }\n\n  let additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined;\n  if (schema.additionalProperties && schema.additionalProperties.type) {\n    if (schema.additionalProperties.type === 'never') {\n      additional = null;\n    } else {\n      const additionalAst = irSchemaToAst({\n        plugin,\n        schema: schema.additionalProperties,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'additionalProperties']),\n        },\n      });\n      if (additionalAst.hasLazyExpression) result.hasLazyExpression = true;\n      additional = pipesToAst({ pipes: additionalAst.pipes, plugin });\n    }\n  }\n\n  const args: ObjectBaseResolverArgs = {\n    $,\n    additional,\n    pipes,\n    plugin,\n    schema,\n    shape,\n  };\n  const resolver = plugin.config['~resolvers']?.object?.base;\n  if (!resolver?.(args)) defaultObjectBaseResolver(args);\n\n  result.pipes = [pipesToAst({ pipes, plugin })];\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport type { FormatResolverArgs } from '../../types';\nimport { identifiers } from '../constants';\n\nconst defaultFormatResolver = ({\n  pipes,\n  plugin,\n  schema,\n}: FormatResolverArgs): boolean | number => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  switch (schema.format) {\n    case 'date':\n      return pipes.push(\n        $(v.placeholder).attr(identifiers.actions.isoDate).call(),\n      );\n    case 'date-time':\n      return pipes.push(\n        $(v.placeholder).attr(identifiers.actions.isoTimestamp).call(),\n      );\n    case 'email':\n      return pipes.push(\n        $(v.placeholder).attr(identifiers.actions.email).call(),\n      );\n    case 'ipv4':\n    case 'ipv6':\n      return pipes.push($(v.placeholder).attr(identifiers.actions.ip).call());\n    case 'time':\n      return pipes.push(\n        $(v.placeholder).attr(identifiers.actions.isoTimeSecond).call(),\n      );\n    case 'uri':\n      return pipes.push($(v.placeholder).attr(identifiers.actions.url).call());\n    case 'uuid':\n      return pipes.push($(v.placeholder).attr(identifiers.actions.uuid).call());\n  }\n\n  return true;\n};\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): ReturnType<typeof $.call | typeof $.expr> => {\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (typeof schema.const === 'string') {\n    pipes.push(\n      $(v.placeholder)\n        .attr(identifiers.schemas.literal)\n        .call($.literal(schema.const)),\n    );\n    return pipesToAst({ pipes, plugin });\n  }\n\n  pipes.push($(v.placeholder).attr(identifiers.schemas.string).call());\n\n  if (schema.format) {\n    const args: FormatResolverArgs = { $, pipes, plugin, schema };\n    const resolver =\n      plugin.config['~resolvers']?.string?.formats?.[schema.format];\n    if (!resolver?.(args)) defaultFormatResolver(args);\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    pipes.push(\n      $(v.placeholder)\n        .attr(identifiers.actions.length)\n        .call($.literal(schema.minLength)),\n    );\n  } else {\n    if (schema.minLength !== undefined) {\n      pipes.push(\n        $(v.placeholder)\n          .attr(identifiers.actions.minLength)\n          .call($.literal(schema.minLength)),\n      );\n    }\n\n    if (schema.maxLength !== undefined) {\n      pipes.push(\n        $(v.placeholder)\n          .attr(identifiers.actions.maxLength)\n          .call($.literal(schema.maxLength)),\n      );\n    }\n  }\n\n  if (schema.pattern) {\n    pipes.push(\n      $(v.placeholder)\n        .attr(identifiers.actions.regex)\n        .call($.regexp(schema.pattern)),\n    );\n  }\n\n  return pipesToAst({ pipes, plugin });\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(v.placeholder)\n        .attr(identifiers.schemas.literal)\n        .call($.fromValue(value)),\n    );\n    result.pipes = [\n      $(v.placeholder)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  if (schema.items) {\n    const tupleElements = schema.items.map((item, index) => {\n      const schemaPipes = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (schemaPipes.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToAst({ pipes: schemaPipes.pipes, plugin });\n    });\n    result.pipes = [\n      $(v.placeholder)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  return {\n    pipes: [\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    ],\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v.placeholder)\n    .attr(identifiers.schemas.undefined)\n    .call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v.placeholder).attr(identifiers.schemas.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { $ } from '~/ts-dsl';\n\nimport { pipesToAst } from '../../shared/pipesToAst';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): {\n  anyType?: string;\n  expression: ReturnType<typeof $.call | typeof $.expr>;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return {\n        expression: pipesToAst({\n          pipes: arrayToAst({\n            ...args,\n            schema: schema as SchemaWithType<'array'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToAst({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return {\n        expression: pipesToAst({\n          pipes: objectToAst({\n            ...args,\n            schema: schema as SchemaWithType<'object'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'string':\n      // For string schemas with int64/uint64 formats, use number handler to generate union with transform\n      if (schema.format === 'int64' || schema.format === 'uint64') {\n        return {\n          expression: numberToAst({\n            ...args,\n            schema: schema as SchemaWithType<'integer' | 'number'>,\n          }),\n        };\n      }\n      return {\n        expression: stringToAst({\n          ...args,\n          schema: schema as SchemaWithType<'string'>,\n        }),\n      };\n    case 'tuple':\n      return {\n        expression: pipesToAst({\n          pipes: tupleToAst({\n            ...args,\n            schema: schema as SchemaWithType<'tuple'>,\n          }).pipes,\n          plugin: args.plugin,\n        }),\n      };\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport { pipesToAst } from '../shared/pipesToAst';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from './constants';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  const ast: Ast = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'valibot',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol.placeholder);\n      ast.pipes.push(ref);\n    } else {\n      const lazyExpression = $(v.placeholder)\n        .attr(identifiers.schemas.lazy)\n        .call($.func().do($(refSymbol.placeholder).return()));\n      ast.pipes.push(lazyExpression);\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n\n    if (plugin.config.metadata && schema.description) {\n      const expression = $(v.placeholder)\n        .attr(identifiers.actions.metadata)\n        .call($.object().prop('description', $.literal(schema.description)));\n      ast.pipes.push(expression);\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemsAst = schema.items.map((item, index) => {\n        const itemAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        });\n        return pipesToAst({ pipes: itemAst.pipes, plugin });\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const intersectExpression = $(v.placeholder)\n          .attr(identifiers.schemas.intersect)\n          .call($.array(...itemsAst));\n        ast.pipes.push(intersectExpression);\n      } else {\n        const unionExpression = $(v.placeholder)\n          .attr(identifiers.schemas.union)\n          .call($.array(...itemsAst));\n        ast.pipes.push(unionExpression);\n      }\n    } else {\n      const schemaPipes = irSchemaToAst({ plugin, schema, state });\n      ast.pipes.push(...schemaPipes.pipes);\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n  }\n\n  if (ast.pipes.length) {\n    if (schema.accessScope === 'read') {\n      const readonlyExpression = $(v.placeholder)\n        .attr(identifiers.actions.readonly)\n        .call();\n      ast.pipes.push(readonlyExpression);\n    }\n\n    let callParameter: ReturnType<typeof $.fromValue> | undefined;\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      callParameter = numberParameter({ isBigInt, value: schema.default });\n      ast.pipes = [\n        $(v.placeholder)\n          .attr(identifiers.schemas.optional)\n          .call(pipesToAst({ pipes: ast.pipes, plugin }), callParameter),\n      ];\n    }\n\n    if (optional && !callParameter) {\n      ast.pipes = [\n        $(v.placeholder)\n          .attr(identifiers.schemas.optional)\n          .call(pipesToAst({ pipes: ast.pipes, plugin })),\n      ];\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'schema',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'valibot',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n  });\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    state,\n    symbol,\n  });\n};\n\nexport const handlerV1: ValibotPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: 'valibot',\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'valibot.v',\n    },\n    name: 'v',\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { ValibotPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: ValibotPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ValibotPlugin } from './types';\n\nexport const defaultConfig: ValibotPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'valibot',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Data',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Response',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}WebhookRequest',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Valibot plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","// TODO: this is inaccurate, it combines identifiers for all supported versions\nexport const identifiers = {\n  ZodMiniOptional: 'ZodMiniOptional',\n  ZodOptional: 'ZodOptional',\n  _default: '_default',\n  and: 'and',\n  array: 'array',\n  bigint: 'bigint',\n  boolean: 'boolean',\n  check: 'check',\n  coerce: 'coerce',\n  date: 'date',\n  datetime: 'datetime',\n  default: 'default',\n  describe: 'describe',\n  email: 'email',\n  enum: 'enum',\n  globalRegistry: 'globalRegistry',\n  gt: 'gt',\n  gte: 'gte',\n  infer: 'infer',\n  int: 'int',\n  intersection: 'intersection',\n  ip: 'ip',\n  ipv4: 'ipv4',\n  ipv6: 'ipv6',\n  iso: 'iso',\n  lazy: 'lazy',\n  length: 'length',\n  literal: 'literal',\n  lt: 'lt',\n  lte: 'lte',\n  max: 'max',\n  maxLength: 'maxLength',\n  min: 'min',\n  minLength: 'minLength',\n  never: 'never',\n  null: 'null',\n  nullable: 'nullable',\n  number: 'number',\n  object: 'object',\n  optional: 'optional',\n  parseAsync: 'parseAsync',\n  readonly: 'readonly',\n  record: 'record',\n  regex: 'regex',\n  register: 'register',\n  string: 'string',\n  time: 'time',\n  tuple: 'tuple',\n  undefined: 'undefined',\n  union: 'union',\n  unknown: 'unknown',\n  url: 'url',\n  uuid: 'uuid',\n  void: 'void',\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverArgs } from '../types';\n\nconst defaultValidatorResolver = ({\n  schema,\n}: ValidatorResolverArgs): ReturnType<typeof $.return> =>\n  $(schema.placeholder)\n    .attr(identifiers.parseAsync)\n    .call('data')\n    .await()\n    .return();\n\nexport const createRequestValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverArgs } from '../types';\n\nconst defaultValidatorResolver = ({\n  schema,\n}: ValidatorResolverArgs): ReturnType<typeof $.return> =>\n  $(schema.placeholder)\n    .attr(identifiers.parseAsync)\n    .call('data')\n    .await()\n    .return();\n\nexport const createRequestValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverArgs } from '../types';\n\nconst defaultValidatorResolver = ({\n  schema,\n}: ValidatorResolverArgs): ReturnType<typeof $.return> =>\n  $(schema.placeholder)\n    .attr(identifiers.parseAsync)\n    .call('data')\n    .await()\n    .return();\n\nexport const createRequestValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const args: ValidatorResolverArgs = {\n    $,\n    chain: undefined,\n    operation,\n    plugin,\n    schema: symbol,\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, defaultValidatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(args);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '~/ts-dsl';\n\nimport {\n  createRequestValidatorMini,\n  createResponseValidatorMini,\n} from './mini/api';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV3, createResponseValidatorV3 } from './v3/api';\nimport { createRequestValidatorV4, createResponseValidatorV4 } from './v4/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createRequestValidatorV3(args);\n      case 'mini':\n        return createRequestValidatorMini(args);\n      case 4:\n      default:\n        return createRequestValidatorV4(args);\n    }\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createResponseValidatorV3(args);\n      case 'mini':\n        return createResponseValidatorMini(args);\n      case 4:\n      default:\n        return createResponseValidatorV4(args);\n    }\n  }\n}\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ZodPlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ZodPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const statement = $.const(symbol.placeholder)\n    .export(symbol.exported)\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    .$if(ast.typeName, (c, v) => c.type($.type(z.placeholder).attr(v)))\n    .assign(ast.expression);\n  plugin.setSymbolValue(symbol, statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol.placeholder)\n      .export(typeInferSymbol.exported)\n      .type(\n        $.type(z.placeholder)\n          .attr(identifiers.infer)\n          .generic($(symbol.placeholder).typeofType()),\n      );\n    plugin.setSymbolValue(typeInferSymbol, inferType);\n  }\n};\n","import type { ZodPlugin } from '../types';\n\nexport const getZodModule = ({\n  plugin,\n}: {\n  plugin: ZodPlugin['Instance'];\n}): string => {\n  const version = plugin.package.getVersion('zod');\n\n  if (version) {\n    if (plugin.package.satisfies(version, '<4.0.0')) {\n      switch (plugin.config.compatibilityVersion) {\n        case 3:\n        default:\n          return 'zod';\n        case 4:\n          return 'zod/v4';\n        case 'mini':\n          return 'zod/v4-mini';\n      }\n    }\n  }\n\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return 'zod/v3';\n    case 4:\n    default:\n      return 'zod';\n    case 'mini':\n      return 'zod/mini';\n  }\n};\n","import { $ } from '~/ts-dsl';\n\nexport const numberParameter = ({\n  isBigInt,\n  value,\n}: {\n  isBigInt: boolean;\n  value: unknown;\n}): ReturnType<typeof $.call | typeof $.fromValue> => {\n  const expr = $.fromValue(value);\n\n  if (\n    isBigInt &&\n    (typeof value === 'bigint' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean')\n  ) {\n    return $('BigInt').call(expr);\n  }\n\n  return expr;\n};\n","import { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}): void => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        path: state.path.value,\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tags: state.tags?.value,\n        tool: 'zod',\n      },\n      name: buildName({\n        config: plugin.config.requests,\n        name: operation.id,\n      }),\n    });\n    const typeInferSymbol = plugin.config.requests.types.infer.enabled\n      ? plugin.registerSymbol({\n          exported: true,\n          kind: 'type',\n          meta: {\n            category: 'type',\n            path: state.path.value,\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'data',\n            tags: state.tags?.value,\n            tool: 'zod',\n            variant: 'infer',\n          },\n          name: buildName({\n            config: plugin.config.requests.types.infer,\n            name: operation.id,\n          }),\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...state.path.value, 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.registerSymbol({\n          exported: true,\n          meta: {\n            category: 'schema',\n            path,\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'responses',\n            tags: state.tags?.value,\n            tool: 'zod',\n          },\n          name: buildName({\n            config: plugin.config.responses,\n            name: operation.id,\n          }),\n        });\n        const typeInferSymbol = plugin.config.responses.types.infer.enabled\n          ? plugin.registerSymbol({\n              exported: true,\n              kind: 'type',\n              meta: {\n                category: 'type',\n                path,\n                resource: 'operation',\n                resourceId: operation.id,\n                role: 'responses',\n                tags: state.tags?.value,\n                tool: 'zod',\n                variant: 'infer',\n              },\n              name: buildName({\n                config: plugin.config.responses.types.infer,\n                name: operation.id,\n              }),\n            })\n          : undefined;\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          symbol,\n          typeInferSymbol,\n        });\n      }\n    }\n  }\n};\n","import type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, state.path.value);\n    const symbol = plugin.registerSymbol({\n      exported: true,\n      meta: {\n        category: 'schema',\n        path: state.path.value,\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: state.tags?.value,\n        tool: 'zod',\n      },\n      name: buildName({\n        config: plugin.config.webhooks,\n        name: operation.id,\n      }),\n    });\n    const typeInferSymbol = plugin.config.webhooks.types.infer.enabled\n      ? plugin.registerSymbol({\n          exported: true,\n          kind: 'type',\n          meta: {\n            category: 'type',\n            path: state.path.value,\n            resource: 'webhook',\n            resourceId: operation.id,\n            role: 'data',\n            tags: state.tags?.value,\n            tool: 'zod',\n            variant: 'infer',\n          },\n          name: buildName({\n            config: plugin.config.webhooks.types.infer,\n            name: operation.id,\n          }),\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z.placeholder).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const functionName = $(z.placeholder).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.intersection()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.expr | typeof $.call>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = $(z.placeholder)\n              .attr(identifiers.intersection)\n              .call(intersectionExpression, itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z.placeholder)\n          .attr(identifiers.array)\n          .call(\n            $(z.placeholder)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  const checks: Array<ReturnType<typeof $.call>> = [];\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.length)\n        .call($.fromValue(schema.minItems)),\n    );\n  } else {\n    if (schema.minItems !== undefined) {\n      checks.push(\n        $(z.placeholder)\n          .attr(identifiers.minLength)\n          .call($.fromValue(schema.minItems)),\n      );\n    }\n\n    if (schema.maxItems !== undefined) {\n      checks.push(\n        $(z.placeholder)\n          .attr(identifiers.maxLength)\n          .call($.fromValue(schema.maxItems)),\n      );\n    }\n  }\n\n  if (checks.length) {\n    result.expression = result.expression\n      .attr(identifiers.check)\n      .call(...checks);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0]!;\n  } else {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.nullable)\n      .call(result.expression);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z.placeholder).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z.placeholder).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    result.expression = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = isBigInt\n    ? $(z.placeholder).attr(identifiers.coerce).attr(identifiers.bigint).call()\n    : $(z.placeholder).attr(identifiers.number).call();\n\n  if (!isBigInt && schema.type === 'integer') {\n    result.expression = $(z.placeholder).attr(identifiers.int).call();\n  }\n\n  const checks: Array<ReturnType<typeof $.call>> = [];\n\n  if (schema.exclusiveMinimum !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.gt)\n        .call(numberParameter({ isBigInt, value: schema.exclusiveMinimum })),\n    );\n  } else if (schema.minimum !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.gte)\n        .call(numberParameter({ isBigInt, value: schema.minimum })),\n    );\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.lt)\n        .call(numberParameter({ isBigInt, value: schema.exclusiveMaximum })),\n    );\n  } else if (schema.maximum !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.lte)\n        .call(numberParameter({ isBigInt, value: schema.maximum })),\n    );\n  }\n\n  if (checks.length) {\n    result.expression = result.expression\n      .attr(identifiers.check)\n      .call(...checks);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectBaseResolverArgs } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction defaultObjectBaseResolver({\n  additional,\n  plugin,\n  shape,\n}: ObjectBaseResolverArgs): ReturnType<typeof $.call> {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (additional) {\n    return $(z.placeholder)\n      .attr(identifiers.record)\n      .call($(z.placeholder).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z.placeholder).attr(identifiers.object).call(shape);\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    if (propertyAst.hasLazyExpression) {\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  let additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined;\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    if (additionalAst.hasLazyExpression) result.hasLazyExpression = true;\n    additional = additionalAst.expression;\n  }\n\n  const args: ObjectBaseResolverArgs = {\n    $,\n    additional,\n    chain: undefined,\n    plugin,\n    schema,\n    shape,\n  };\n  const resolver = plugin.config['~resolvers']?.object?.base;\n  const chain = resolver?.(args) ?? defaultObjectBaseResolver(args);\n  result.expression = chain;\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { FormatResolverArgs } from '../../types';\n\nconst defaultFormatResolver = ({\n  chain,\n  plugin,\n  schema,\n}: FormatResolverArgs): ReturnType<typeof $.call> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  switch (schema.format) {\n    case 'date':\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.date)\n        .call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z.placeholder).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z.placeholder).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z.placeholder).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.time)\n        .call();\n    case 'uri':\n      return $(z.placeholder).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z.placeholder).attr(identifiers.uuid).call();\n    default:\n      return chain;\n  }\n};\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'string') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.string).call();\n\n  if (schema.format) {\n    const args: FormatResolverArgs = { $, chain, plugin, schema };\n    const resolver =\n      plugin.config['~resolvers']?.string?.formats?.[schema.format];\n    chain = resolver?.(args) ?? defaultFormatResolver(args);\n  }\n\n  const checks: Array<ReturnType<typeof $.call>> = [];\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    checks.push(\n      $(z.placeholder)\n        .attr(identifiers.length)\n        .call($.literal(schema.minLength)),\n    );\n  } else {\n    if (schema.minLength !== undefined) {\n      checks.push(\n        $(z.placeholder)\n          .attr(identifiers.minLength)\n          .call($.literal(schema.minLength)),\n      );\n    }\n\n    if (schema.maxLength !== undefined) {\n      checks.push(\n        $(z.placeholder)\n          .attr(identifiers.maxLength)\n          .call($.literal(schema.maxLength)),\n      );\n    }\n  }\n\n  if (schema.pattern) {\n    checks.push(\n      $(z.placeholder).attr(identifiers.regex).call($.regexp(schema.pattern)),\n    );\n  }\n\n  if (checks.length) {\n    chain = chain.attr(identifiers.check).call(...checks);\n  }\n\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z.placeholder).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z.placeholder)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z.placeholder)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z.placeholder).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z.placeholder).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol.placeholder);\n    } else {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol.placeholder).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z.placeholder).attr(identifiers.globalRegistry),\n          $.object()\n            .pretty()\n            .prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = $(z.placeholder)\n              .attr(identifiers.intersection)\n              .call(\n                ast.expression,\n                schema.hasLazyExpression\n                  ? $(z.placeholder)\n                      .attr(identifiers.lazy)\n                      .call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z.placeholder)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.readonly)\n        .call(ast.expression);\n    }\n\n    if (optional) {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.optional)\n        .call(ast.expression);\n      ast.typeName = identifiers.ZodMiniOptional;\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      ast.expression = $(z.placeholder)\n        .attr(identifiers._default)\n        .call(\n          ast.expression,\n          numberParameter({\n            isBigInt,\n            value: schema.default,\n          }),\n        );\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'schema',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'zod',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'definition',\n          resourceId: $ref,\n          tags: state.tags?.value,\n          tool: 'zod',\n          variant: 'infer',\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerMini: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n    name: 'z',\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z.placeholder).attr(identifiers.unknown).call();\n  return expression;\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const functionName = $(z.placeholder).attr(identifiers.array);\n\n  let arrayExpression: ReturnType<typeof $.call> | undefined;\n  let hasLazyExpression = false;\n\n  if (!schema.items) {\n    arrayExpression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      arrayExpression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        arrayExpression = functionName.call(intersectionExpression);\n      } else {\n        arrayExpression = $(z.placeholder)\n          .attr(identifiers.array)\n          .call(\n            $(z.placeholder)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    arrayExpression = arrayExpression\n      .attr(identifiers.length)\n      .call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      arrayExpression = arrayExpression\n        .attr(identifiers.min)\n        .call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      arrayExpression = arrayExpression\n        .attr(identifiers.max)\n        .call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return {\n    expression: arrayExpression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call> => {\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    return chain;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.boolean).call();\n  return chain;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ReturnType<typeof $.call> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  let enumExpression: ReturnType<typeof $.call>;\n  if (allStrings && enumMembers.length > 0) {\n    enumExpression = $(z.placeholder)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    enumExpression = literalMembers[0]!;\n  } else {\n    enumExpression = $(z.placeholder)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    enumExpression = enumExpression.attr(identifiers.nullable).call();\n  }\n\n  return enumExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z.placeholder).attr(identifiers.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z.placeholder).attr(identifiers.null).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    const expression = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    return expression;\n  }\n\n  let numberExpression = isBigInt\n    ? $(z.placeholder).attr(identifiers.coerce).attr(identifiers.bigint).call()\n    : $(z.placeholder).attr(identifiers.number).call();\n\n  if (!isBigInt && schema.type === 'integer') {\n    numberExpression = numberExpression.attr(identifiers.int).call();\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    numberExpression = numberExpression\n      .attr(identifiers.gt)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMinimum }));\n  } else if (schema.minimum !== undefined) {\n    numberExpression = numberExpression\n      .attr(identifiers.gte)\n      .call(numberParameter({ isBigInt, value: schema.minimum }));\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    numberExpression = numberExpression\n      .attr(identifiers.lt)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMaximum }));\n  } else if (schema.maximum !== undefined) {\n    numberExpression = numberExpression\n      .attr(identifiers.lte)\n      .call(numberParameter({ isBigInt, value: schema.maximum }));\n  }\n\n  return numberExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectBaseResolverArgs } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction defaultObjectBaseResolver({\n  additional,\n  plugin,\n  shape,\n}: ObjectBaseResolverArgs): ReturnType<typeof $.call> {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (additional) {\n    return $(z.placeholder).attr(identifiers.record).call(additional);\n  }\n\n  return $(z.placeholder).attr(identifiers.object).call(shape);\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  let hasLazyExpression = false;\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyExpression = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n\n    if (propertyExpression.hasLazyExpression) hasLazyExpression = true;\n\n    shape.prop(name, propertyExpression.expression);\n  }\n\n  let additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined;\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    hasLazyExpression = additionalAst.hasLazyExpression || hasLazyExpression;\n    additional = additionalAst.expression;\n  }\n\n  const args: ObjectBaseResolverArgs = {\n    $,\n    additional,\n    chain: undefined,\n    plugin,\n    schema,\n    shape,\n  };\n  const resolver = plugin.config['~resolvers']?.object?.base;\n  const chain = resolver?.(args) ?? defaultObjectBaseResolver(args);\n  result.expression = chain;\n\n  return {\n    anyType: 'AnyZodObject',\n    expression: result.expression!,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport type { FormatResolverArgs } from '../../types';\n\nconst defaultFormatResolver = ({\n  chain,\n  plugin,\n  schema,\n}: FormatResolverArgs): ReturnType<typeof $.call> => {\n  switch (schema.format) {\n    case 'date':\n      return chain.attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return chain\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return chain.attr(identifiers.email).call();\n    case 'ipv4':\n    case 'ipv6':\n      return chain.attr(identifiers.ip).call();\n    case 'time':\n      return chain.attr(identifiers.time).call();\n    case 'uri':\n      return chain.attr(identifiers.url).call();\n    case 'uuid':\n      return chain.attr(identifiers.uuid).call();\n    default:\n      return chain;\n  }\n};\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): ReturnType<typeof $.call> => {\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'string') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    return chain;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.string).call();\n\n  if (schema.format) {\n    const args: FormatResolverArgs = { $, chain, plugin, schema };\n    const resolver =\n      plugin.config['~resolvers']?.string?.formats?.[schema.format];\n    chain = resolver?.(args) ?? defaultFormatResolver(args);\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    chain = chain.attr(identifiers.length).call($.literal(schema.minLength));\n  } else {\n    if (schema.minLength !== undefined) {\n      chain = chain.attr(identifiers.min).call($.literal(schema.minLength));\n    }\n\n    if (schema.maxLength !== undefined) {\n      chain = chain.attr(identifiers.max).call($.literal(schema.maxLength));\n    }\n  }\n\n  if (schema.pattern) {\n    chain = chain.attr(identifiers.regex).call($.regexp(schema.pattern));\n  }\n\n  return chain;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  let hasLazyExpression = false;\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z.placeholder).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    const expression = $(z.placeholder)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return {\n      expression,\n      hasLazyExpression,\n    };\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n    });\n  }\n\n  const expression = $(z.placeholder)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return {\n    expression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z.placeholder).attr(identifiers.undefined).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z.placeholder).attr(identifiers.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToAst({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return {\n        expression: stringToAst({\n          ...args,\n          schema: schema as SchemaWithType<'string'>,\n        }),\n      };\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol.placeholder);\n    } else {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.lazy)\n        .call($.func().do($(refSymbol.placeholder).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.describe)\n        .call($.literal(schema.description));\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemTypes = schema.items.map((item, index) => {\n        const typeAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        });\n        return typeAst.expression;\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemTypes);\n        } else {\n          ast.expression = itemTypes[0];\n          itemTypes.slice(1).forEach((item) => {\n            ast.expression = ast.expression!.attr(identifiers.and).call(item);\n          });\n        }\n      } else {\n        ast.expression = $(z.placeholder)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemTypes),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = ast.expression.attr(identifiers.optional).call();\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      ast.expression = ast.expression.attr(identifiers.default).call(\n        numberParameter({\n          isBigInt,\n          value: schema.default,\n        }),\n      );\n    }\n  }\n\n  if (state.hasLazyExpression.value) {\n    if (!ast.typeName) {\n      ast.typeName = 'ZodTypeAny';\n    }\n  } else if (ast.typeName) {\n    ast.typeName = undefined;\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'schema',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'zod',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'definition',\n          resourceId: $ref,\n          tags: state.tags?.value,\n          tool: 'zod',\n          variant: 'infer',\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV3: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n    name: 'z',\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z.placeholder).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const functionName = $(z.placeholder).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z.placeholder)\n          .attr(identifiers.array)\n          .call(\n            $(z.placeholder)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.length)\n      .call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.min)\n        .call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.max)\n        .call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push(\n        $(z.placeholder).attr(identifiers.literal).call(literal),\n      );\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0]!;\n  } else {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    result.expression = $(z.placeholder)\n      .attr(identifiers.nullable)\n      .call(result.expression);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z.placeholder).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z.placeholder).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport { numberParameter } from '../../shared/numbers';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'number') {\n    // TODO: parser - handle bigint constants\n    result.expression = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = isBigInt\n    ? $(z.placeholder).attr(identifiers.coerce).attr(identifiers.bigint).call()\n    : $(z.placeholder).attr(identifiers.number).call();\n\n  if (!isBigInt && schema.type === 'integer') {\n    result.expression = $(z.placeholder).attr(identifiers.int).call();\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.gt)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMinimum }));\n  } else if (schema.minimum !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.gte)\n      .call(numberParameter({ isBigInt, value: schema.minimum }));\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.lt)\n      .call(numberParameter({ isBigInt, value: schema.exclusiveMaximum }));\n  } else if (schema.maximum !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.lte)\n      .call(numberParameter({ isBigInt, value: schema.maximum }));\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectBaseResolverArgs } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction defaultObjectBaseResolver({\n  additional,\n  plugin,\n  shape,\n}: ObjectBaseResolverArgs): ReturnType<typeof $.call> {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (additional) {\n    return $(z.placeholder)\n      .attr(identifiers.record)\n      .call($(z.placeholder).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z.placeholder).attr(identifiers.object).call(shape);\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    if (propertyAst.hasLazyExpression) {\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  let additional: ReturnType<typeof $.call | typeof $.expr> | null | undefined;\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: toRef([...state.path.value, 'additionalProperties']),\n      },\n    });\n    if (additionalAst.hasLazyExpression) result.hasLazyExpression = true;\n    additional = additionalAst.expression;\n  }\n\n  const args: ObjectBaseResolverArgs = {\n    $,\n    additional,\n    chain: undefined,\n    plugin,\n    schema,\n    shape,\n  };\n  const resolver = plugin.config['~resolvers']?.object?.base;\n  const chain = resolver?.(args) ?? defaultObjectBaseResolver(args);\n  result.expression = chain;\n\n  // Return with typeName for circular references\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'ZodType',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { FormatResolverArgs } from '../../types';\n\nconst defaultFormatResolver = ({\n  chain,\n  plugin,\n  schema,\n}: FormatResolverArgs): ReturnType<typeof $.call> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  switch (schema.format) {\n    case 'date':\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.date)\n        .call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z.placeholder).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z.placeholder).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z.placeholder).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z.placeholder)\n        .attr(identifiers.iso)\n        .attr(identifiers.time)\n        .call();\n    case 'uri':\n      return $(z.placeholder).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z.placeholder).attr(identifiers.uuid).call();\n    default:\n      return chain;\n  }\n};\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'string') {\n    chain = $(z.placeholder)\n      .attr(identifiers.literal)\n      .call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z.placeholder).attr(identifiers.string).call();\n\n  if (schema.format) {\n    const args: FormatResolverArgs = { $, chain, plugin, schema };\n    const resolver =\n      plugin.config['~resolvers']?.string?.formats?.[schema.format];\n    chain = resolver?.(args) ?? defaultFormatResolver(args);\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    chain = chain.attr(identifiers.length).call($.literal(schema.minLength));\n  } else {\n    if (schema.minLength !== undefined) {\n      chain = chain.attr(identifiers.min).call($.literal(schema.minLength));\n    }\n\n    if (schema.maxLength !== undefined) {\n      chain = chain.attr(identifiers.max).call($.literal(schema.maxLength));\n    }\n  }\n\n  if (schema.pattern) {\n    chain = chain.attr(identifiers.regex).call($.regexp(schema.pattern));\n  }\n\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { toRef } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z.placeholder).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z.placeholder)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: toRef([...state.path.value, 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z.placeholder)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z.placeholder).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z.placeholder).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { SchemaWithType } from '~/plugins';\nimport { toRef, toRefs } from '~/plugins/shared/utils/refs';\nimport { $ } from '~/ts-dsl';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { numberParameter } from '../shared/numbers';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol.placeholder);\n    } else {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol.placeholder).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression.value = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z.placeholder).attr(identifiers.globalRegistry),\n          $.object()\n            .pretty()\n            .prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: toRef([...state.path.value, 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z.placeholder)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = ast\n              .expression!.attr(identifiers.and)\n              .call(\n                schema.hasLazyExpression\n                  ? $(z.placeholder)\n                      .attr(identifiers.lazy)\n                      .call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z.placeholder)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({\n        plugin,\n        schema,\n        state,\n      });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = $(z.placeholder)\n        .attr(identifiers.optional)\n        .call(ast.expression);\n      ast.typeName = identifiers.ZodOptional;\n    }\n\n    if (schema.default !== undefined) {\n      const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n      ast.expression = ast.expression.attr(identifiers.default).call(\n        numberParameter({\n          isBigInt,\n          value: schema.default,\n        }),\n      );\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(state.path.value);\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.registerSymbol({\n    exported: true,\n    meta: {\n      category: 'schema',\n      path: state.path.value,\n      resource: 'definition',\n      resourceId: $ref,\n      tags: state.tags?.value,\n      tool: 'zod',\n    },\n    name: buildName({\n      config: plugin.config.definitions,\n      name: baseName,\n    }),\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.registerSymbol({\n        exported: true,\n        kind: 'type',\n        meta: {\n          category: 'type',\n          path: state.path.value,\n          resource: 'definition',\n          resourceId: $ref,\n          tags: state.tags?.value,\n          tool: 'zod',\n          variant: 'infer',\n        },\n        name: buildName({\n          config: plugin.config.definitions.types.infer,\n          name: baseName,\n        }),\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV4: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.registerSymbol({\n    external: getZodModule({ plugin }),\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n    name: 'z',\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = toRefs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = toRefs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import { handlerMini } from './mini/plugin';\nimport type { ZodPlugin } from './types';\nimport { handlerV3 } from './v3/plugin';\nimport { handlerV4 } from './v4/plugin';\n\nexport const handler: ZodPlugin['Handler'] = (args) => {\n  const { plugin } = args;\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return handlerV3(args);\n    case 'mini':\n      return handlerMini(args);\n    case 4:\n    default:\n      return handlerV4(args);\n  }\n};\n","import colors from 'ansi-colors';\n\nimport { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ZodPlugin } from './types';\n\ntype CompatibilityVersion = NonNullable<\n  ZodPlugin['Config']['config']['compatibilityVersion']\n>;\n\nexport const defaultConfig: ZodPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'zod',\n  resolveConfig: (plugin, context) => {\n    const packageName = 'zod';\n    const version = context.package.getVersion(packageName);\n\n    const inferCompatibleVersion = (): CompatibilityVersion => {\n      if (version && (version.major === 4 || version.major === 3)) {\n        return version.major;\n      }\n\n      // default compatibility version\n      return 4;\n    };\n\n    const ensureCompatibleVersion = (\n      compatibilityVersion: CompatibilityVersion | undefined,\n    ): CompatibilityVersion => {\n      if (!compatibilityVersion) {\n        return inferCompatibleVersion();\n      }\n\n      if (!version) {\n        return compatibilityVersion;\n      }\n\n      if (\n        compatibilityVersion === 4 ||\n        compatibilityVersion === 3 ||\n        compatibilityVersion === 'mini'\n      ) {\n        if (!context.package.satisfies(version, '>=3.25.0 <5.0.0')) {\n          const compatibleVersion = inferCompatibleVersion();\n          console.warn(\n            `üîå ${colors.yellow('Warning:')} Installed ${colors.cyan(packageName)} ${colors.cyan(`v${version.version}`)} does not support compatibility version ${colors.yellow(String(compatibilityVersion))}, using ${colors.yellow(String(compatibleVersion))}.`,\n          );\n          return compatibleVersion;\n        }\n      }\n\n      return compatibilityVersion;\n    };\n\n    plugin.config.compatibilityVersion = ensureCompatibleVersion(\n      plugin.config.compatibilityVersion,\n    );\n\n    plugin.config.dates = context.valueToObject({\n      defaultValue: {\n        local: false,\n        offset: false,\n      },\n      value: plugin.config.dates,\n    });\n\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}DataZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ResponseZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequestZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Zod plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Plugin } from '~/plugins';\nimport type { AngularCommonPlugin } from '~/plugins/@angular/common';\nimport { defaultConfig as angularCommon } from '~/plugins/@angular/common';\nimport type { HeyApiClientAngularPlugin } from '~/plugins/@hey-api/client-angular';\nimport { defaultConfig as heyApiClientAngular } from '~/plugins/@hey-api/client-angular';\nimport type { HeyApiClientAxiosPlugin } from '~/plugins/@hey-api/client-axios';\nimport { defaultConfig as heyApiClientAxios } from '~/plugins/@hey-api/client-axios';\nimport type { HeyApiClientFetchPlugin } from '~/plugins/@hey-api/client-fetch';\nimport { defaultConfig as heyApiClientFetch } from '~/plugins/@hey-api/client-fetch';\nimport type { HeyApiClientKyPlugin } from '~/plugins/@hey-api/client-ky';\nimport { defaultConfig as heyApiClientKy } from '~/plugins/@hey-api/client-ky';\nimport type { HeyApiClientNextPlugin } from '~/plugins/@hey-api/client-next';\nimport { defaultConfig as heyApiClientNext } from '~/plugins/@hey-api/client-next';\nimport type { HeyApiClientNuxtPlugin } from '~/plugins/@hey-api/client-nuxt';\nimport { defaultConfig as heyApiClientNuxt } from '~/plugins/@hey-api/client-nuxt';\nimport type { HeyApiClientOfetchPlugin } from '~/plugins/@hey-api/client-ofetch';\nimport { defaultConfig as heyApiClientOfetch } from '~/plugins/@hey-api/client-ofetch';\nimport type { HeyApiSchemasPlugin } from '~/plugins/@hey-api/schemas';\nimport { defaultConfig as heyApiSchemas } from '~/plugins/@hey-api/schemas';\nimport type { HeyApiSdkPlugin } from '~/plugins/@hey-api/sdk';\nimport { defaultConfig as heyApiSdk } from '~/plugins/@hey-api/sdk';\nimport type { HeyApiTransformersPlugin } from '~/plugins/@hey-api/transformers';\nimport { defaultConfig as heyApiTransformers } from '~/plugins/@hey-api/transformers';\nimport type { HeyApiTypeScriptPlugin } from '~/plugins/@hey-api/typescript';\nimport { defaultConfig as heyApiTypeScript } from '~/plugins/@hey-api/typescript';\nimport type { PiniaColadaPlugin } from '~/plugins/@pinia/colada';\nimport { defaultConfig as piniaColada } from '~/plugins/@pinia/colada';\nimport type { TanStackAngularQueryPlugin } from '~/plugins/@tanstack/angular-query-experimental';\nimport { defaultConfig as tanStackAngularQuery } from '~/plugins/@tanstack/angular-query-experimental';\nimport type { TanStackReactQueryPlugin } from '~/plugins/@tanstack/react-query';\nimport { defaultConfig as tanStackReactQuery } from '~/plugins/@tanstack/react-query';\nimport type { TanStackSolidQueryPlugin } from '~/plugins/@tanstack/solid-query';\nimport { defaultConfig as tanStackSolidQuery } from '~/plugins/@tanstack/solid-query';\nimport type { TanStackSvelteQueryPlugin } from '~/plugins/@tanstack/svelte-query';\nimport { defaultConfig as tanStackSvelteQuery } from '~/plugins/@tanstack/svelte-query';\nimport type { TanStackVueQueryPlugin } from '~/plugins/@tanstack/vue-query';\nimport { defaultConfig as tanStackVueQuery } from '~/plugins/@tanstack/vue-query';\nimport type { ArktypePlugin } from '~/plugins/arktype';\nimport { defaultConfig as arktype } from '~/plugins/arktype';\nimport type { FastifyPlugin } from '~/plugins/fastify';\nimport { defaultConfig as fastify } from '~/plugins/fastify';\nimport type { SwrPlugin } from '~/plugins/swr';\nimport { defaultConfig as swr } from '~/plugins/swr';\nimport type { PluginNames } from '~/plugins/types';\nimport type { ValibotPlugin } from '~/plugins/valibot';\nimport { defaultConfig as valibot } from '~/plugins/valibot';\nimport type { ZodPlugin } from '~/plugins/zod';\nimport { defaultConfig as zod } from '~/plugins/zod';\n\nexport interface PluginConfigMap {\n  '@angular/common': AngularCommonPlugin['Types'];\n  '@hey-api/client-angular': HeyApiClientAngularPlugin['Types'];\n  '@hey-api/client-axios': HeyApiClientAxiosPlugin['Types'];\n  '@hey-api/client-fetch': HeyApiClientFetchPlugin['Types'];\n  '@hey-api/client-ky': HeyApiClientKyPlugin['Types'];\n  '@hey-api/client-next': HeyApiClientNextPlugin['Types'];\n  '@hey-api/client-nuxt': HeyApiClientNuxtPlugin['Types'];\n  '@hey-api/client-ofetch': HeyApiClientOfetchPlugin['Types'];\n  '@hey-api/schemas': HeyApiSchemasPlugin['Types'];\n  '@hey-api/sdk': HeyApiSdkPlugin['Types'];\n  '@hey-api/transformers': HeyApiTransformersPlugin['Types'];\n  '@hey-api/typescript': HeyApiTypeScriptPlugin['Types'];\n  '@pinia/colada': PiniaColadaPlugin['Types'];\n  '@tanstack/angular-query-experimental': TanStackAngularQueryPlugin['Types'];\n  '@tanstack/react-query': TanStackReactQueryPlugin['Types'];\n  '@tanstack/solid-query': TanStackSolidQueryPlugin['Types'];\n  '@tanstack/svelte-query': TanStackSvelteQueryPlugin['Types'];\n  '@tanstack/vue-query': TanStackVueQueryPlugin['Types'];\n  arktype: ArktypePlugin['Types'];\n  fastify: FastifyPlugin['Types'];\n  swr: SwrPlugin['Types'];\n  valibot: ValibotPlugin['Types'];\n  zod: ZodPlugin['Types'];\n}\n\nexport const defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n} = {\n  '@angular/common': angularCommon,\n  '@hey-api/client-angular': heyApiClientAngular,\n  '@hey-api/client-axios': heyApiClientAxios,\n  '@hey-api/client-fetch': heyApiClientFetch,\n  '@hey-api/client-ky': heyApiClientKy,\n  '@hey-api/client-next': heyApiClientNext,\n  '@hey-api/client-nuxt': heyApiClientNuxt,\n  '@hey-api/client-ofetch': heyApiClientOfetch,\n  '@hey-api/schemas': heyApiSchemas,\n  '@hey-api/sdk': heyApiSdk,\n  '@hey-api/transformers': heyApiTransformers,\n  '@hey-api/typescript': heyApiTypeScript,\n  '@pinia/colada': piniaColada,\n  '@tanstack/angular-query-experimental': tanStackAngularQuery,\n  '@tanstack/react-query': tanStackReactQuery,\n  '@tanstack/solid-query': tanStackSolidQuery,\n  '@tanstack/svelte-query': tanStackSvelteQuery,\n  '@tanstack/vue-query': tanStackVueQuery,\n  arktype,\n  fastify,\n  swr,\n  valibot,\n  zod,\n};\n","import { defaultPluginConfigs } from '~/plugins/config';\nimport type {\n  AnyPluginName,\n  PluginContext,\n  PluginNames,\n} from '~/plugins/types';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\nimport { packageFactory } from './utils/package';\n\n/**\n * Default plugins used to generate artifacts if plugins aren't specified.\n */\nexport const defaultPlugins = [\n  '@hey-api/typescript',\n  '@hey-api/sdk',\n] as const satisfies ReadonlyArray<PluginNames>;\n\nconst getPluginsConfig = ({\n  dependencies,\n  userPlugins,\n  userPluginsConfig,\n}: {\n  dependencies: Record<string, string>;\n  userPlugins: ReadonlyArray<AnyPluginName>;\n  userPluginsConfig: Config['plugins'];\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const circularReferenceTracker = new Set<AnyPluginName>();\n  const pluginOrder = new Set<AnyPluginName>();\n  const plugins: Config['plugins'] = {};\n\n  const dfs = (name: AnyPluginName) => {\n    if (circularReferenceTracker.has(name)) {\n      throw new Error(`Circular reference detected at '${name}'`);\n    }\n\n    if (pluginOrder.has(name)) {\n      return;\n    }\n\n    circularReferenceTracker.add(name);\n\n    const defaultPlugin = defaultPluginConfigs[name as PluginNames];\n    const userPlugin = userPluginsConfig[name as PluginNames];\n\n    if (!defaultPlugin && !userPlugin) {\n      throw new Error(\n        `unknown plugin dependency \"${name}\" - do you need to register a custom plugin with this name?`,\n      );\n    }\n\n    const plugin = {\n      ...defaultPlugin,\n      ...userPlugin,\n      config: {\n        ...defaultPlugin?.config,\n        ...userPlugin?.config,\n      },\n      dependencies: new Set([\n        ...(defaultPlugin?.dependencies || []),\n        ...(userPlugin?.dependencies || []),\n      ]),\n    };\n\n    if (plugin.resolveConfig) {\n      const context: PluginContext = {\n        package: packageFactory(dependencies),\n        pluginByTag: (tag, props = {}) => {\n          const { defaultPlugin, errorMessage } = props;\n\n          for (const userPlugin of userPlugins) {\n            const defaultConfig =\n              defaultPluginConfigs[userPlugin as PluginNames] ||\n              userPluginsConfig[userPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              userPlugin !== name\n            ) {\n              return userPlugin as any;\n            }\n          }\n\n          if (defaultPlugin) {\n            const defaultConfig =\n              defaultPluginConfigs[defaultPlugin as PluginNames] ||\n              userPluginsConfig[defaultPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              defaultPlugin !== name\n            ) {\n              return defaultPlugin;\n            }\n          }\n\n          throw new Error(\n            errorMessage ||\n              `missing plugin - no plugin with tag \"${tag}\" found`,\n          );\n        },\n        valueToObject,\n      };\n      // @ts-expect-error\n      plugin.resolveConfig(plugin, context);\n    }\n\n    for (const dependency of plugin.dependencies) {\n      dfs(dependency);\n    }\n\n    circularReferenceTracker.delete(name);\n    pluginOrder.add(name);\n\n    // @ts-expect-error\n    plugins[name] = plugin;\n  };\n\n  for (const name of userPlugins) {\n    dfs(name);\n  }\n\n  return {\n    pluginOrder: Array.from(pluginOrder) as ReadonlyArray<PluginNames>,\n    plugins,\n  };\n};\n\nconst isPluginClient = (plugin: Required<UserConfig>['plugins'][number]) => {\n  if (typeof plugin === 'string') {\n    return plugin.startsWith('@hey-api/client');\n  }\n\n  return (\n    plugin.name.startsWith('@hey-api/client') ||\n    // @ts-expect-error\n    (plugin.tags && plugin.tags.includes('client'))\n  );\n};\n\nexport const getPlugins = ({\n  dependencies,\n  userConfig,\n}: {\n  dependencies: Record<string, string>;\n  userConfig: UserConfig;\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const userPluginsConfig: Config['plugins'] = {};\n\n  let definedPlugins: UserConfig['plugins'] = defaultPlugins;\n\n  if (userConfig.plugins) {\n    userConfig.plugins = userConfig.plugins.filter(\n      (plugin) =>\n        (typeof plugin === 'string' && plugin) ||\n        (typeof plugin !== 'string' && plugin.name),\n    );\n    if (\n      userConfig.plugins.length === 1 &&\n      isPluginClient(userConfig.plugins[0]!)\n    ) {\n      definedPlugins = [...defaultPlugins, ...userConfig.plugins];\n    } else {\n      definedPlugins = userConfig.plugins;\n    }\n  }\n\n  const userPlugins = definedPlugins\n    .map((plugin) => {\n      if (typeof plugin === 'string') {\n        return plugin;\n      }\n\n      const pluginName = plugin.name;\n\n      if (pluginName) {\n        // @ts-expect-error\n        if (plugin.handler) {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = plugin;\n        } else {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = {\n            config: { ...plugin },\n          };\n          // @ts-expect-error\n          delete userPluginsConfig[pluginName]!.config.name;\n        }\n      }\n\n      return pluginName;\n    })\n    .filter(Boolean);\n\n  return getPluginsConfig({ dependencies, userPlugins, userPluginsConfig });\n};\n","import path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { ConfigError } from '~/error';\nimport type { Config, UserConfig } from '~/types/config';\nimport type { ArrayOnly } from '~/types/utils';\nimport type { Logger } from '~/utils/logger';\n\nimport { getInput } from './input';\nimport { getLogs } from './logs';\nimport { mergeConfigs } from './merge';\nimport { getOutput } from './output';\nimport { getProjectDependencies } from './packages';\nimport { getParser } from './parser';\nimport { getPlugins } from './plugins';\n\ntype ConfigResult = {\n  config: Config;\n  errors: ReadonlyArray<Error>;\n  jobIndex: number;\n};\n\nexport type Configs = {\n  dependencies: Record<string, string>;\n  results: ReadonlyArray<ConfigResult>;\n};\n\n/**\n * Detect if the current session is interactive based on TTY status and environment variables.\n * This is used as a fallback when the user doesn't explicitly set the interactive option.\n * @internal\n */\nexport const detectInteractiveSession = (): boolean =>\n  Boolean(\n    process.stdin.isTTY &&\n      process.stdout.isTTY &&\n      !process.env.CI &&\n      !process.env.NO_INTERACTIVE &&\n      !process.env.NO_INTERACTION,\n  );\n\n/**\n * @internal\n */\nexport const initConfigs = async ({\n  logger,\n  userConfigs,\n}: {\n  logger: Logger;\n  userConfigs: ReadonlyArray<UserConfig>;\n}): Promise<Configs> => {\n  const configs: Array<UserConfig> = [];\n  let dependencies: Record<string, string> = {};\n\n  const eventLoad = logger.timeEvent('load');\n  for (const userConfig of userConfigs) {\n    let configurationFile: string | undefined = undefined;\n    if (userConfig?.configFile) {\n      const parts = userConfig.configFile.split('.');\n      configurationFile = parts.slice(0, parts.length - 1).join('.');\n    }\n\n    const eventC12 = logger.timeEvent('c12');\n    // c12 is ESM-only since v3\n    const { loadConfig } = await import('c12');\n    const { config: configFromFile, configFile: loadedConfigFile } =\n      await loadConfig<UserConfig>({\n        configFile: configurationFile,\n        name: 'openapi-ts',\n      });\n    eventC12.timeEnd();\n\n    if (!Object.keys(dependencies).length) {\n      // TODO: handle dependencies for multiple configs properly?\n      dependencies = getProjectDependencies(\n        Object.keys(configFromFile).length ? loadedConfigFile : undefined,\n      );\n    }\n\n    const mergedConfigs =\n      configFromFile instanceof Array\n        ? configFromFile.map((config) => mergeConfigs(config, userConfig))\n        : [mergeConfigs(configFromFile, userConfig)];\n\n    for (const mergedConfig of mergedConfigs) {\n      const input = getInput(mergedConfig);\n\n      if (mergedConfig.output instanceof Array) {\n        const countInputs = input.length;\n        const countOutputs = mergedConfig.output.length;\n        if (countOutputs > 1) {\n          if (countInputs !== countOutputs) {\n            console.warn(\n              `‚öôÔ∏è ${colors.yellow('Warning:')} You provided ${colors.cyan(String(countInputs))} ${colors.cyan(countInputs === 1 ? 'input' : 'inputs')} and ${colors.yellow(String(countOutputs))} ${colors.yellow('outputs')}. This is probably not what you want as it will produce identical output in multiple locations. You most likely want to provide a single output or the same number of outputs as inputs.`,\n            );\n            for (const output of mergedConfig.output) {\n              configs.push({ ...mergedConfig, input, output });\n            }\n          } else {\n            mergedConfig.output.forEach((output, index) => {\n              configs.push({ ...mergedConfig, input: input[index]!, output });\n            });\n          }\n        } else {\n          configs.push({\n            ...mergedConfig,\n            input,\n            output: mergedConfig.output[0] ?? '',\n          });\n        }\n      } else {\n        configs.push({ ...mergedConfig, input });\n      }\n    }\n  }\n  eventLoad.timeEnd();\n\n  const results: Array<ArrayOnly<ConfigResult>> = [];\n\n  const eventBuild = logger.timeEvent('build');\n  for (const userConfig of configs) {\n    const logs = getLogs(userConfig);\n    const input = getInput(userConfig);\n    const output = getOutput(userConfig);\n    const parser = getParser(userConfig);\n\n    const errors: Array<Error> = [];\n\n    if (!input.length) {\n      errors.push(\n        new ConfigError(\n          'missing input - which OpenAPI specification should we use to generate your output?',\n        ),\n      );\n    }\n\n    if (!output.path) {\n      errors.push(\n        new ConfigError(\n          'missing output - where should we generate your output?',\n        ),\n      );\n    }\n\n    output.path = path.resolve(process.cwd(), output.path);\n\n    let plugins: Pick<Config, 'plugins' | 'pluginOrder'>;\n\n    try {\n      plugins = getPlugins({ dependencies, userConfig });\n    } catch (error) {\n      errors.push(error);\n      plugins = {\n        pluginOrder: [],\n        plugins: {},\n      };\n    }\n\n    const config: Config = {\n      configFile: userConfig.configFile ?? '',\n      dryRun: userConfig.dryRun ?? false,\n      input,\n      interactive: userConfig.interactive ?? detectInteractiveSession(),\n      logs,\n      output,\n      parser,\n      pluginOrder: plugins.pluginOrder,\n      plugins: plugins.plugins,\n    };\n\n    const jobIndex = results.length;\n\n    if (logs.level === 'debug') {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      console.warn(`${jobPrefix}${colors.cyan('config:')}`, config);\n    }\n\n    results.push({ config, errors, jobIndex });\n  }\n  eventBuild.timeEnd();\n\n  return { dependencies, results };\n};\n","type Slot = 'body' | 'headers' | 'path' | 'query';\n\nexport type Field =\n  | {\n      in: Exclude<Slot, 'body'>;\n      /**\n       * Field name. This is the name we want the user to see and use.\n       */\n      key: string;\n      /**\n       * Field mapped name. This is the name we want to use in the request.\n       * If omitted, we use the same value as `key`.\n       */\n      map?: string;\n    }\n  | {\n      in: Extract<Slot, 'body'>;\n      /**\n       * Key isn't required for bodies.\n       */\n      key?: string;\n      map?: string;\n    }\n  | {\n      /**\n       * Field name. This is the name we want the user to see and use.\n       */\n      key: string;\n      /**\n       * Field mapped name. This is the name we want to use in the request.\n       * If `in` is omitted, `map` aliases `key` to the transport layer.\n       */\n      map: Slot;\n    };\n\nexport interface Fields {\n  allowExtra?: Partial<Record<Slot, boolean>>;\n  args?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n  $body_: 'body',\n  $headers_: 'headers',\n  $path_: 'path',\n  $query_: 'query',\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n  string,\n  | {\n      in: Slot;\n      map?: string;\n    }\n  | {\n      in?: never;\n      map: Slot;\n    }\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n  if (!map) {\n    map = new Map();\n  }\n\n  for (const config of fields) {\n    if ('in' in config) {\n      if (config.key) {\n        map.set(config.key, {\n          in: config.in,\n          map: config.map,\n        });\n      }\n    } else if ('key' in config) {\n      map.set(config.key, {\n        map: config.map,\n      });\n    } else if (config.args) {\n      buildKeyMap(config.args, map);\n    }\n  }\n\n  return map;\n};\n\ninterface Params {\n  body: unknown;\n  headers: Record<string, unknown>;\n  path: Record<string, unknown>;\n  query: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n  for (const [slot, value] of Object.entries(params)) {\n    if (value && typeof value === 'object' && !Object.keys(value).length) {\n      delete params[slot as Slot];\n    }\n  }\n};\n\nexport const buildClientParams = (\n  args: ReadonlyArray<unknown>,\n  fields: FieldsConfig,\n) => {\n  const params: Params = {\n    body: {},\n    headers: {},\n    path: {},\n    query: {},\n  };\n\n  const map = buildKeyMap(fields);\n\n  let config: FieldsConfig[number] | undefined;\n\n  for (const [index, arg] of args.entries()) {\n    if (fields[index]) {\n      config = fields[index];\n    }\n\n    if (!config) {\n      continue;\n    }\n\n    if ('in' in config) {\n      if (config.key) {\n        const field = map.get(config.key)!;\n        const name = field.map || config.key;\n        if (field.in) {\n          (params[field.in] as Record<string, unknown>)[name] = arg;\n        }\n      } else {\n        params.body = arg;\n      }\n    } else {\n      for (const [key, value] of Object.entries(arg ?? {})) {\n        const field = map.get(key);\n\n        if (field) {\n          if (field.in) {\n            const name = field.map || key;\n            (params[field.in] as Record<string, unknown>)[name] = value;\n          } else {\n            params[field.map] = value;\n          }\n        } else {\n          const extra = extraPrefixes.find(([prefix]) =>\n            key.startsWith(prefix),\n          );\n\n          if (extra) {\n            const [prefix, slot] = extra;\n            (params[slot] as Record<string, unknown>)[\n              key.slice(prefix.length)\n            ] = value;\n          } else if ('allowExtra' in config && config.allowExtra) {\n            for (const [slot, allowed] of Object.entries(config.allowExtra)) {\n              if (allowed) {\n                (params[slot as Slot] as Record<string, unknown>)[key] = value;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  stripEmptySlots(params);\n\n  return params;\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects aren‚Äôt supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import { getAuthToken } from '../../client-core/bundle/auth';\nimport type { QuerySerializerOptions } from '../../client-core/bundle/bodySerializer';\nimport { jsonBodySerializer } from '../../client-core/bundle/bodySerializer';\nimport {\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '../../client-core/bundle/pathSerializer';\nimport { getUrl } from '../../client-core/bundle/utils';\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\nexport const createQuerySerializer = <T = unknown>({\n  parameters = {},\n  ...args\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    const search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        const options = parameters[name] || args;\n\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'form',\n            value,\n            ...options.array,\n          });\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === 'object') {\n          const serializedObject = serializeObjectParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'deepObject',\n            value: value as Record<string, unknown>,\n            ...options.object,\n          });\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved: options.allowReserved,\n            name,\n            value: value as string,\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nconst checkForExistence = (\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  },\n  name?: string,\n): boolean => {\n  if (!name) {\n    return false;\n  }\n  if (\n    options.headers.has(name) ||\n    options.query?.[name] ||\n    options.headers.get('Cookie')?.includes(`${name}=`)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    if (checkForExistence(options, auth.name)) {\n      continue;\n    }\n\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) =>\n  getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\n  const entries: Array<[string, string]> = [];\n  headers.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header) {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers\n        ? headersEntries(header)\n        : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  fns: Array<Interceptor | null> = [];\n\n  clear(): void {\n    this.fns = [];\n  }\n\n  eject(id: number | Interceptor): void {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = null;\n    }\n  }\n\n  exists(id: number | Interceptor): boolean {\n    const index = this.getInterceptorIndex(id);\n    return Boolean(this.fns[index]);\n  }\n\n  getInterceptorIndex(id: number | Interceptor): number {\n    if (typeof id === 'number') {\n      return this.fns[id] ? id : -1;\n    }\n    return this.fns.indexOf(id);\n  }\n\n  update(\n    id: number | Interceptor,\n    fn: Interceptor,\n  ): number | Interceptor | false {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = fn;\n      return id;\n    }\n    return false;\n  }\n\n  use(fn: Interceptor): number {\n    this.fns.push(fn);\n    return this.fns.length - 1;\n  }\n}\n\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\n  request: Interceptors<ReqInterceptor<Req, Options>>;\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\n}\n\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\n  Req,\n  Res,\n  Err,\n  Options\n> => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import { getResolvedInput, sendRequest } from '@hey-api/json-schema-ref-parser';\n\nimport { mergeHeaders } from '~/plugins/@hey-api/client-fetch/bundle';\nimport type { Input } from '~/types/input';\nimport type { WatchValues } from '~/types/types';\n\ntype SpecResponse = {\n  arrayBuffer: ArrayBuffer | undefined;\n  error?: never;\n  resolvedInput: ReturnType<typeof getResolvedInput>;\n  response?: never;\n};\n\ntype SpecError = {\n  arrayBuffer?: never;\n  error: 'not-modified' | 'not-ok';\n  resolvedInput?: never;\n  response: Response;\n};\n\n/**\n * @internal\n */\nexport const getSpec = async ({\n  fetchOptions,\n  inputPath,\n  timeout,\n  watch,\n}: {\n  fetchOptions?: RequestInit;\n  inputPath: Input['path'];\n  timeout: number | undefined;\n  watch: WatchValues;\n}): Promise<SpecResponse | SpecError> => {\n  const resolvedInput = getResolvedInput({ pathOrUrlOrSchema: inputPath });\n\n  let arrayBuffer: ArrayBuffer | undefined;\n  // boolean signals whether the file has **definitely** changed\n  let hasChanged: boolean | undefined;\n  let response: Response | undefined;\n\n  if (resolvedInput.type === 'url') {\n    // do NOT send HEAD request on first run or if unsupported\n    if (watch.lastValue && watch.isHeadMethodSupported !== false) {\n      try {\n        const request = await sendRequest({\n          fetchOptions: {\n            method: 'HEAD',\n            ...fetchOptions,\n            headers: mergeHeaders(fetchOptions?.headers, watch.headers),\n          },\n          timeout,\n          url: resolvedInput.path,\n        });\n\n        if (request.response.status >= 300) {\n          return {\n            error: 'not-ok',\n            response: request.response,\n          };\n        }\n\n        response = request.response;\n      } catch (error) {\n        return {\n          error: 'not-ok',\n          response: new Response(error.message),\n        };\n      }\n\n      if (!response.ok && watch.isHeadMethodSupported) {\n        // assume the server is no longer running\n        // do nothing, it might be restarted later\n        return {\n          error: 'not-ok',\n          response,\n        };\n      }\n\n      if (watch.isHeadMethodSupported === undefined) {\n        watch.isHeadMethodSupported = response.ok;\n      }\n\n      if (response.status === 304) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n\n      if (hasChanged === undefined) {\n        const eTag = response.headers.get('ETag');\n        if (eTag) {\n          hasChanged = eTag !== watch.headers.get('If-None-Match');\n\n          if (hasChanged) {\n            watch.headers.set('If-None-Match', eTag);\n          }\n        }\n      }\n\n      if (hasChanged === undefined) {\n        const lastModified = response.headers.get('Last-Modified');\n        if (lastModified) {\n          hasChanged = lastModified !== watch.headers.get('If-Modified-Since');\n\n          if (hasChanged) {\n            watch.headers.set('If-Modified-Since', lastModified);\n          }\n        }\n      }\n\n      // we definitely know the input has not changed\n      if (hasChanged === false) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n    }\n\n    try {\n      const request = await sendRequest({\n        fetchOptions: {\n          method: 'GET',\n          ...fetchOptions,\n        },\n        timeout,\n        url: resolvedInput.path,\n      });\n\n      if (request.response.status >= 300) {\n        return {\n          error: 'not-ok',\n          response: request.response,\n        };\n      }\n\n      response = request.response;\n    } catch (error) {\n      return {\n        error: 'not-ok',\n        response: new Response(error.message),\n      };\n    }\n\n    if (!response.ok) {\n      // assume the server is no longer running\n      // do nothing, it might be restarted later\n      return {\n        error: 'not-ok',\n        response,\n      };\n    }\n\n    arrayBuffer = response.body\n      ? await response.arrayBuffer()\n      : new ArrayBuffer(0);\n\n    if (hasChanged === undefined) {\n      const content = new TextDecoder().decode(arrayBuffer);\n      hasChanged = content !== watch.lastValue;\n      watch.lastValue = content;\n    }\n  } else {\n    // we do not support watch mode for files or raw spec data\n    if (!watch.lastValue) {\n      watch.lastValue = resolvedInput.type;\n    } else {\n      hasChanged = false;\n    }\n  }\n\n  if (hasChanged === false) {\n    return {\n      error: 'not-modified',\n      response: response!,\n    };\n  }\n\n  return {\n    arrayBuffer,\n    resolvedInput,\n  };\n};\n","import path from 'node:path';\n\nimport type {\n  BiMap,\n  Binding,\n  File,\n  IProject,\n  ProjectRenderMeta,\n  Renderer,\n  Symbol,\n} from '@hey-api/codegen-core';\nimport { createBinding, mergeBindings, renderIds } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';\nimport { $, TsDsl } from '~/ts-dsl';\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n  removeComments: false,\n});\n\nconst createSourceFile = (sourceText: string): ts.SourceFile =>\n  ts.createSourceFile(\n    '',\n    sourceText,\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\nconst blankSourceFile = createSourceFile('');\n\nconst unescapeUnicode = (value: string) =>\n  value.replace(/\\\\u([0-9a-fA-F]{4})/g, (_, hex: string) =>\n    String.fromCharCode(Number.parseInt(hex, 16)),\n  );\n\n/** Print a TypeScript node to a string. */\nfunction nodeToString(node: ts.Node): string {\n  const result = printer.printNode(\n    ts.EmitHint.Unspecified,\n    node,\n    blankSourceFile,\n  );\n\n  try {\n    /**\n     * TypeScript Compiler API escapes unicode characters by default and there\n     * is no way to disable this behavior\n     * {@link https://github.com/microsoft/TypeScript/issues/36174}\n     */\n    return unescapeUnicode(result);\n  } catch {\n    return result;\n  }\n}\n\nconst nodeBuiltins = new Set([\n  'buffer',\n  'child_process',\n  'cluster',\n  'console',\n  'constants',\n  'crypto',\n  'dgram',\n  'dns',\n  'domain',\n  'events',\n  'freelist',\n  'fs',\n  'http',\n  'https',\n  'module',\n  'net',\n  'os',\n  'path',\n  'process',\n  'punycode',\n  'querystring',\n  'readline',\n  'repl',\n  'stream',\n  'string_decoder',\n  'timers',\n  'tls',\n  'tty',\n  'url',\n  'util',\n  'v8',\n  'vm',\n  'worker_threads',\n  'zlib',\n]);\n\nexport class TypeScriptRenderer implements Renderer {\n  renderFile(\n    symbolsAndExports: string,\n    file: File,\n    project: IProject,\n    meta?: ProjectRenderMeta,\n  ): string {\n    const imports: Map<string, Binding> = new Map();\n    symbolsAndExports = renderIds(symbolsAndExports, (symbolId) => {\n      const symbol = project.symbols.get(symbolId);\n      const replaced = this.replacerFn({ file, project, symbol });\n      if (symbol) {\n        this.addBinding({ bindings: imports, file, meta, project, symbol });\n      }\n      return replaced;\n    });\n    if (!symbolsAndExports.length) return '';\n    let output = '';\n    const headerLines = this.getHeaderLines();\n    output += `${headerLines.join('\\n')}${headerLines.length ? '\\n\\n' : ''}`;\n    const importLines = this.getImportLines(imports, file, project);\n    output += `${importLines.join('\\n')}${importLines.length ? '\\n\\n' : ''}`;\n    return `${output}${symbolsAndExports}`;\n  }\n\n  renderSymbols(\n    file: File,\n    project: IProject,\n    meta?: ProjectRenderMeta,\n  ): string {\n    const exports: Map<string, Binding> = new Map();\n    let output = '';\n    const bodyLines = this.getBodyLines(file, project);\n    output += `${bodyLines.join('\\n\\n')}${bodyLines.length ? '\\n' : ''}`;\n    output = renderIds(output, (symbolId) => {\n      if (!file.symbols.body.includes(symbolId)) return;\n      const symbol = project.symbols.get(symbolId);\n      return this.replacerFn({ file, project, symbol });\n    });\n    for (const symbolId of file.symbols.exports) {\n      const symbol = project.symbols.get(symbolId);\n      if (symbol) {\n        this.addBinding({ bindings: exports, file, meta, project, symbol });\n      }\n    }\n    // cast everything into namespace exports for now\n    for (const binding of exports.values()) {\n      binding.namespaceBinding = true;\n      binding.typeNamespaceBinding =\n        binding.names &&\n        binding.typeNames &&\n        binding.names.length === binding.typeNames.length &&\n        binding.names.every((name) => (binding.typeNames ?? []).includes(name));\n    }\n    const exportLines = this.getExportLines(exports, file, project);\n    output += `${exportLines.join('\\n')}${exportLines.length ? '\\n' : ''}`;\n    return output;\n  }\n\n  private addBinding({\n    bindings,\n    file,\n    meta,\n    project,\n    symbol,\n  }: {\n    bindings: Map<string, Binding>;\n    file: File;\n    meta?: ProjectRenderMeta;\n    project: IProject;\n    symbol: Symbol;\n  }): void {\n    if (!symbol.external && !project.symbols.hasValue(symbol.id)) {\n      return;\n    }\n\n    const [symbolFile] = project.symbolIdToFiles(symbol.id);\n    if (!symbolFile || file === symbolFile) return;\n\n    const modulePath = this.getBindingPath(file, symbolFile, meta);\n    const existing = bindings.get(modulePath);\n    const binding = createBinding({\n      file,\n      modulePath,\n      symbol,\n      symbolFile,\n    });\n    if (existing) {\n      mergeBindings(existing, binding);\n      bindings.set(modulePath, existing);\n    } else {\n      bindings.set(modulePath, binding);\n    }\n  }\n\n  private getBindingPath(\n    currentFile: File,\n    symbolFile: File,\n    meta?: ProjectRenderMeta,\n  ): string {\n    if (!currentFile.path || !symbolFile.path) {\n      return '';\n    }\n    if (symbolFile.external && !path.isAbsolute(symbolFile.path)) {\n      return symbolFile.path;\n    }\n    let relativePath = path.posix.relative(\n      path.posix.dirname(\n        currentFile.path.split(path.sep).join(path.posix.sep), // normalize to posix\n      ),\n      symbolFile.path.split(path.sep).join(path.posix.sep), // normalize to posix\n    );\n    if (!relativePath.startsWith('.') && relativePath !== '') {\n      relativePath = `./${relativePath}`;\n    }\n    if (symbolFile.extension === '.ts') {\n      if (relativePath.endsWith(symbolFile.extension)) {\n        relativePath = relativePath.slice(0, -symbolFile.extension.length);\n      }\n      if (meta?.importFileExtension) {\n        relativePath += meta.importFileExtension;\n      } else if (relativePath.endsWith('/index')) {\n        relativePath = relativePath.slice(0, -'/index'.length);\n      }\n    }\n    return relativePath;\n  }\n\n  private getBodyLine(value: unknown, lines: Array<string>): void {\n    if (value instanceof TsDsl) {\n      const node = value.$render();\n      lines.push(nodeToString(node));\n    } else if (typeof value === 'string') {\n      lines.push(value);\n    } else if (value instanceof Array) {\n      for (const node of value) {\n        this.getBodyLine(node, lines);\n      }\n    } else if (value !== undefined && value !== null) {\n      lines.push(nodeToString(value as any));\n    }\n  }\n\n  private getBodyLines(file: File, project: IProject): Array<string> {\n    const lines: Array<string> = [];\n    for (const symbolId of file.symbols.body) {\n      this.getBodyLine(project.symbols.getValue(symbolId), lines);\n    }\n    return lines;\n  }\n\n  private getExportLines(\n    bindings: Map<string, Binding>,\n    file: File,\n    project: IProject,\n  ): Array<string> {\n    const lines: Array<string> = [];\n\n    for (const [from, value] of bindings.entries()) {\n      const specifiers: Array<ts.ExportSpecifier> = [];\n      let namespaceBinding: string | undefined;\n      let isTypeOnly = false;\n\n      if (value.namespaceBinding !== undefined) {\n        if (typeof value.namespaceBinding === 'string') {\n          namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            return this.replacerFn({ file, project, symbol });\n          });\n        }\n        if (value.typeNamespaceBinding) {\n          isTypeOnly = true;\n        }\n      } else if (value.names && value.names.length > 0) {\n        if (\n          value.names.every((name) => (value.typeNames ?? []).includes(name))\n        ) {\n          isTypeOnly = true;\n        }\n\n        for (const name of value.names) {\n          const alias = value.aliases?.[name];\n          let finalName = name;\n          let finalAlias: string | undefined;\n          if (alias && alias !== finalName) {\n            finalAlias = finalName;\n            finalName = alias;\n          }\n          finalName = renderIds(finalName, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            const name = this.replacerFn({ file, project, symbol });\n            const [symbolFile] = project.symbolIdToFiles(symbolId);\n            const sourceName = symbolFile\n              ? symbolFile.resolvedNames.get(symbolId)\n              : undefined;\n            if (sourceName && sourceName !== name) {\n              // handle only simple imports for now\n              if (!finalAlias) {\n                finalAlias = sourceName;\n              }\n            }\n            return name;\n          });\n          if (finalAlias) {\n            finalAlias = renderIds(finalAlias, (symbolId) => {\n              const symbol = project.symbols.get(symbolId);\n              return this.replacerFn({ file, project, symbol });\n            });\n            // remove redundant alias\n            if (finalAlias === finalName) {\n              finalAlias = undefined;\n            }\n          }\n          const specifier = ts.factory.createExportSpecifier(\n            isTypeOnly ? false : (value.typeNames?.includes(name) ?? false),\n            finalAlias ? $.id(finalAlias).$render() : undefined,\n            $.id(finalName).$render(),\n          );\n          specifiers.push(specifier);\n        }\n      }\n\n      const exportClause = namespaceBinding\n        ? ts.factory.createNamespaceExport($.id(namespaceBinding).$render())\n        : specifiers.length\n          ? ts.factory.createNamedExports(specifiers)\n          : undefined;\n\n      const node = ts.factory.createExportDeclaration(\n        undefined,\n        isTypeOnly,\n        exportClause,\n        $.literal(from).$render(),\n      );\n      lines.push(nodeToString(node));\n    }\n\n    return lines;\n  }\n\n  private getHeaderLines(): Array<string> {\n    return ['// This file is auto-generated by @hey-api/openapi-ts'];\n  }\n\n  private getImportLines(\n    bindings: Map<string, Binding>,\n    file: File,\n    project: IProject,\n  ): Array<string> {\n    const lines: Array<string> = [];\n\n    let lastGroup = -1;\n    const importSortKey = (binding: Binding): [number, number, string] => {\n      const path = binding.from;\n      if (!path.startsWith('.')) {\n        // Node.js built-in\n        if (nodeBuiltins.has(path.split('/')[0]!)) {\n          return [0, 0, path];\n        }\n        // external package\n        return [1, 0, path];\n      }\n      // sibling relative\n      if (path.startsWith('./')) {\n        return [2, 0, path];\n      }\n      // parent relative\n      const parentCount = path.match(/\\.\\.\\//g)?.length ?? 0;\n      return [2, parentCount, path];\n    };\n\n    const sortedBindings = Array.from(bindings.values())\n      .map((value) => ({\n        ...value,\n        k: importSortKey(value),\n      }))\n      .sort(\n        (a, b) =>\n          a.k[0] - b.k[0] || a.k[1] - b.k[1] || a.k[2].localeCompare(b.k[2]),\n      );\n\n    for (const value of sortedBindings) {\n      let specifiers: Array<ts.ImportSpecifier> = [];\n      let defaultBinding: ts.Identifier | undefined;\n      let namespaceBinding: string | undefined;\n      let isTypeOnly = false;\n\n      if (value.defaultBinding) {\n        const processedDefaultBinding = renderIds(\n          value.defaultBinding,\n          (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            return this.replacerFn({ file, project, symbol });\n          },\n        );\n        defaultBinding = $.id(processedDefaultBinding).$render();\n        if (value.typeDefaultBinding) {\n          isTypeOnly = true;\n        }\n      } else if (typeof value.namespaceBinding === 'string') {\n        namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {\n          const symbol = project.symbols.get(symbolId);\n          return this.replacerFn({ file, project, symbol });\n        });\n        if (value.typeNamespaceBinding) {\n          isTypeOnly = true;\n        }\n      } else if (value.names && value.names.length > 0) {\n        if (value.names.every((name) => value.typeNames?.includes(name))) {\n          isTypeOnly = true;\n        }\n\n        const namedImports: Array<{\n          isTypeOnly: boolean;\n          name: string;\n          propertyName: ts.ModuleExportName | undefined;\n        }> = [];\n\n        for (const name of value.names) {\n          const alias = value.aliases?.[name];\n          let finalName = name;\n          let finalAlias: string | undefined;\n          if (alias && alias !== finalName) {\n            finalAlias = finalName;\n            finalName = alias;\n          }\n          finalName = renderIds(finalName, (symbolId) => {\n            const symbol = project.symbols.get(symbolId);\n            const name = this.replacerFn({ file, project, symbol });\n            const [symbolFile] = project.symbolIdToFiles(symbolId);\n            const sourceName = symbolFile\n              ? symbolFile.resolvedNames.get(symbolId)\n              : undefined;\n            if (sourceName && sourceName !== name) {\n              // handle only simple imports for now\n              if (!finalAlias) {\n                finalAlias = sourceName;\n              }\n            }\n            return name;\n          });\n          if (finalAlias) {\n            finalAlias = renderIds(finalAlias, (symbolId) => {\n              const symbol = project.symbols.get(symbolId);\n              return this.replacerFn({ file, project, symbol });\n            });\n            // remove redundant alias\n            if (finalAlias === finalName) {\n              finalAlias = undefined;\n            }\n          }\n          namedImports.push({\n            isTypeOnly: isTypeOnly\n              ? false\n              : (value.typeNames?.includes(name) ?? false),\n            name: finalName,\n            propertyName: finalAlias ? $.id(finalAlias).$render() : undefined,\n          });\n        }\n\n        specifiers = namedImports\n          .sort((a, b) => a.name.localeCompare(b.name))\n          .map(({ isTypeOnly, name, propertyName }) =>\n            ts.factory.createImportSpecifier(\n              isTypeOnly,\n              propertyName,\n              $.id(name).$render(),\n            ),\n          );\n      }\n\n      const importClause = ts.factory.createImportClause(\n        isTypeOnly,\n        defaultBinding,\n        namespaceBinding\n          ? ts.factory.createNamespaceImport($.id(namespaceBinding).$render())\n          : specifiers.length\n            ? ts.factory.createNamedImports(specifiers)\n            : undefined,\n      );\n\n      const node = ts.factory.createImportDeclaration(\n        undefined,\n        importClause,\n        $.literal(value.from).$render(),\n      );\n\n      if (lastGroup !== -1 && value.k[0] !== lastGroup) {\n        lines.push(''); // add empty line between groups\n      }\n\n      lines.push(nodeToString(node));\n      lastGroup = value.k[0];\n    }\n\n    return lines;\n  }\n\n  private getUniqueName(base: string, names: BiMap<number, string>): string {\n    let index = 2;\n    let name = base;\n    while (names.hasValue(name)) {\n      name = `${base}${index}`;\n      index += 1;\n    }\n    return name;\n  }\n\n  private replacerFn({\n    file,\n    project,\n    symbol,\n  }: {\n    file: File;\n    project: IProject;\n    symbol: Symbol | undefined;\n  }): string | undefined {\n    if (!symbol) return;\n    const cached = file.resolvedNames.get(symbol.id);\n    if (cached) return cached;\n    if (!symbol.name) return;\n    const [symbolFile] = project.symbolIdToFiles(symbol.id);\n    const symbolFileResolvedName = symbolFile?.resolvedNames.get(symbol.id);\n    let name = ensureValidIdentifier(symbolFileResolvedName ?? symbol.name);\n    const conflictId = file.resolvedNames.getKey(name);\n    if (conflictId !== undefined) {\n      const conflictSymbol = project.symbols.get(conflictId);\n      if (conflictSymbol) {\n        const kinds = [conflictSymbol.kind, symbol.kind];\n        if (\n          kinds.every((kind) => kind === 'type') ||\n          kinds.every((kind) => kind !== 'type') ||\n          // avoid conflicts between class and type of the same name\n          (kinds.includes('class') && kinds.includes('type'))\n        ) {\n          name = this.getUniqueName(name, file.resolvedNames);\n        }\n      }\n    }\n    file.resolvedNames.set(symbol.id, name);\n    return name;\n  }\n}\n","export class MinHeap {\n  private heap: Array<string> = [];\n\n  constructor(public declIndex: Map<string, number>) {}\n\n  isEmpty(): boolean {\n    return !this.heap.length;\n  }\n\n  pop(): string | undefined {\n    const [top] = this.heap;\n    if (!this.heap.length) return;\n    const last = this.heap.pop()!;\n    if (!this.heap.length) return top;\n    this.heap[0] = last;\n    this.sinkDown(0);\n    return top;\n  }\n\n  push(item: string): void {\n    this.heap.push(item);\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  private bubbleUp(index: number): void {\n    const heap = this.heap;\n    while (index > 0) {\n      const parent = Math.floor((index - 1) / 2);\n      const parentVal = heap[parent]!;\n      const curVal = heap[index]!;\n      if (this.declIndex.get(parentVal)! <= this.declIndex.get(curVal)!) break;\n      heap[parent] = curVal;\n      heap[index] = parentVal;\n      index = parent;\n    }\n  }\n\n  private sinkDown(index: number): void {\n    const heap = this.heap;\n    const len = heap.length;\n    while (true) {\n      const left = 2 * index + 1;\n      const right = 2 * index + 2;\n      let smallest = index;\n      if (left < len) {\n        const leftVal = heap[left]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(leftVal)! < this.declIndex.get(smallestVal)!)\n          smallest = left;\n      }\n      if (right < len) {\n        const rightVal = heap[right]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(rightVal)! < this.declIndex.get(smallestVal)!)\n          smallest = right;\n      }\n      if (smallest === index) break;\n      const tmp = heap[smallest]!;\n      heap[smallest] = heap[index]!;\n      heap[index] = tmp;\n      index = smallest;\n    }\n  }\n}\n","import { MinHeap } from '~/utils/minHeap';\n\nimport type { GetPointerPriorityFn, WalkFn } from './types/walk';\n\n/**\n * Walk the nodes of the graph in declaration (insertion) order.\n * This is a cheap alternative to `walkTopological` when dependency ordering\n * is not required and the caller only wants nodes in the order they were\n * added to the graph.\n */\nconst walkDeclarations: WalkFn = (graph, callback, options) => {\n  const pointers = Array.from(graph.nodes.keys());\n\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // emit nodes that match each preferred group in order, preserving insertion order\n    const emitted = new Set<string>();\n    if (options.matchPointerToGroup) {\n      for (const kind of options.preferGroups) {\n        for (const pointer of pointers) {\n          const result = options.matchPointerToGroup(pointer);\n          if (!result.matched) continue;\n          if (result.kind === kind) {\n            emitted.add(pointer);\n            callback(pointer, graph.nodes.get(pointer)!);\n          }\n        }\n      }\n    }\n\n    // emit anything not covered by the preferGroups (in declaration order)\n    for (const pointer of pointers) {\n      if (emitted.has(pointer)) continue;\n      callback(pointer, graph.nodes.get(pointer)!);\n    }\n    return;\n  }\n\n  // fallback: simple declaration order\n  for (const pointer of pointers) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\n/**\n * Walks the nodes of the graph in topological order (dependencies before dependents).\n * Calls the callback for each node pointer in order.\n * Nodes in cycles are grouped together and emitted in arbitrary order within the group.\n *\n * @param graph - The dependency graph\n * @param callback - Function to call for each node pointer\n */\nconst walkTopological: WalkFn = (graph, callback, options) => {\n  // stable Kahn's algorithm that respects declaration order as a tiebreaker.\n  const pointers = Array.from(graph.nodes.keys());\n  // base insertion order\n  const baseIndex = new Map<string, number>();\n  pointers.forEach((pointer, index) => baseIndex.set(pointer, index));\n\n  // composite decl index: group priority then base insertion order\n  const declIndex = new Map<string, number>();\n  for (const pointer of pointers) {\n    const priority = options?.getPointerPriority?.(pointer) ?? 10;\n    const composite = priority * 1_000_000 + (baseIndex.get(pointer) ?? 0);\n    declIndex.set(pointer, composite);\n  }\n\n  // build dependency sets for each pointer\n  const depsOf = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    const raw = graph.subtreeDependencies?.get(pointer) ?? new Set();\n    const filtered = new Set<string>();\n    for (const rawPointer of raw) {\n      if (rawPointer === pointer) continue; // ignore self-dependencies for ordering\n      if (graph.nodes.has(rawPointer)) {\n        filtered.add(rawPointer);\n      }\n    }\n    depsOf.set(pointer, filtered);\n  }\n\n  // build inDegree and dependents adjacency\n  const inDegree = new Map<string, number>();\n  const dependents = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    inDegree.set(pointer, 0);\n  }\n  for (const [pointer, deps] of depsOf) {\n    inDegree.set(pointer, deps.size);\n    for (const d of deps) {\n      if (!dependents.has(d)) {\n        dependents.set(d, new Set());\n      }\n      dependents.get(d)!.add(pointer);\n    }\n  }\n\n  // sort pointers by declaration order\n  const sortByDecl = (arr: Array<string>) =>\n    arr.sort((a, b) => declIndex.get(a)! - declIndex.get(b)!);\n\n  // initialize queue with zero-inDegree nodes in declaration order\n  // use min-heap prioritized by declaration index to avoid repeated full sorts\n  const heap = new MinHeap(declIndex);\n  for (const pointer of pointers) {\n    if ((inDegree.get(pointer) ?? 0) === 0) {\n      heap.push(pointer);\n    }\n  }\n\n  const emitted = new Set<string>();\n  const order: Array<string> = [];\n\n  while (!heap.isEmpty()) {\n    const cur = heap.pop()!;\n    if (emitted.has(cur)) continue;\n    emitted.add(cur);\n    order.push(cur);\n\n    const deps = dependents.get(cur);\n    if (!deps) continue;\n\n    for (const dep of deps) {\n      const v = (inDegree.get(dep) ?? 0) - 1;\n      inDegree.set(dep, v);\n      if (v === 0) {\n        heap.push(dep);\n      }\n    }\n  }\n\n  // emit remaining nodes (cycles) in declaration order\n  const remaining = pointers.filter((pointer) => !emitted.has(pointer));\n  sortByDecl(remaining);\n  for (const pointer of remaining) {\n    emitted.add(pointer);\n    order.push(pointer);\n  }\n\n  // prefer specified groups when safe\n  let finalOrder = order;\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // build group priority map (lower = earlier)\n    const groupPriority = new Map<string, number>();\n    for (let i = 0; i < options.preferGroups.length; i++) {\n      const k = options.preferGroups[i];\n      if (k) {\n        groupPriority.set(k, i);\n      }\n    }\n\n    const getGroup: GetPointerPriorityFn = (pointer) => {\n      if (options.matchPointerToGroup) {\n        const result = options.matchPointerToGroup(pointer);\n        if (result.matched) {\n          return groupPriority.has(result.kind)\n            ? groupPriority.get(result.kind)!\n            : options.preferGroups!.length;\n        }\n      }\n      return options.preferGroups!.length;\n    };\n\n    // proposed order: sort by (groupPriority, originalIndex)\n    const proposed = [...order].sort((a, b) => {\n      const ga = getGroup(a);\n      const gb = getGroup(b);\n      return ga !== gb ? ga - gb : order.indexOf(a) - order.indexOf(b);\n    });\n\n    // build quick lookup of original index and proposed index\n    const proposedIndex = new Map<string, number>();\n    for (let i = 0; i < proposed.length; i++) {\n      proposedIndex.set(proposed[i]!, i);\n    }\n\n    // only validate edges where group(dep) > group(node)\n    const violated = (() => {\n      for (const [node, deps] of depsOf) {\n        for (const dep of deps) {\n          const gDep = getGroup(dep);\n          const gNode = getGroup(node);\n          if (gDep <= gNode) continue; // not a crossing edge, cannot be violated by grouping\n          const pDep = proposedIndex.get(dep)!;\n          const pNode = proposedIndex.get(node)!;\n          if (pDep >= pNode) {\n            return true;\n          }\n        }\n      }\n      return false;\n    })();\n\n    if (!violated) {\n      finalOrder = proposed;\n    }\n  }\n\n  for (const pointer of finalOrder) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\nexport const walk: WalkFn = (graph, callback, options) => {\n  if (options?.order === 'topological') {\n    return walkTopological(graph, callback, options);\n  }\n  return walkDeclarations(graph, callback, options);\n};\n","import type { GetPointerPriorityFn, MatchPointerToGroupFn } from '~/graph';\n\nexport const irTopLevelKinds = [\n  'operation',\n  'parameter',\n  'requestBody',\n  'schema',\n  'server',\n  'webhook',\n] as const;\n\nexport type IrTopLevelKind = (typeof irTopLevelKinds)[number];\n\n/**\n * Checks if a pointer matches a known top-level IR component (schema, parameter, etc) and returns match info.\n *\n * @param pointer - The IR pointer string (e.g. '#/components/schemas/Foo')\n * @param kind - (Optional) The component kind to check\n * @returns { matched: true, kind: IrTopLevelKind } | { matched: false } - Whether it matched, and the matched kind if so\n */\nexport const matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind> = (\n  pointer,\n  kind,\n) => {\n  const patterns: Record<IrTopLevelKind, RegExp> = {\n    operation:\n      /^#\\/paths\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n    parameter: /^#\\/components\\/parameters\\/[^/]+$/,\n    requestBody: /^#\\/components\\/requestBodies\\/[^/]+$/,\n    schema: /^#\\/components\\/schemas\\/[^/]+$/,\n    server: /^#\\/servers\\/(\\d+|[^/]+)$/,\n    webhook:\n      /^#\\/webhooks\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n  };\n  if (kind) {\n    return patterns[kind].test(pointer)\n      ? { kind, matched: true }\n      : { matched: false };\n  }\n  for (const key of Object.keys(patterns)) {\n    const kind = key as IrTopLevelKind;\n    if (patterns[kind].test(pointer)) {\n      return { kind, matched: true };\n    }\n  }\n  return { matched: false };\n};\n\n// default grouping preference (earlier groups emitted first when safe)\nexport const preferGroups = [\n  'server',\n  'schema',\n  'parameter',\n  'requestBody',\n  'operation',\n  'webhook',\n] satisfies ReadonlyArray<IrTopLevelKind>;\n\ntype KindPriority = Record<IrTopLevelKind, number>;\n\n// default group priority (lower = earlier)\n// built from `preferGroups` so the priority order stays in sync with the prefer-groups array.\nconst kindPriority: KindPriority = (() => {\n  const partial: Partial<KindPriority> = {};\n  for (let i = 0; i < preferGroups.length; i++) {\n    const k = preferGroups[i];\n    if (k) partial[k] = i;\n  }\n  // Ensure all known kinds exist in the map (fall back to a high index).\n  for (const k of irTopLevelKinds) {\n    if (partial[k] === undefined) {\n      partial[k] = preferGroups.length;\n    }\n  }\n  return partial as KindPriority;\n})();\n\nconst defaultPriority = 10;\n\nexport const getIrPointerPriority: GetPointerPriorityFn = (pointer) => {\n  const result = matchIrPointerToGroup(pointer);\n  if (result.matched) {\n    return kindPriority[result.kind] ?? defaultPriority;\n  }\n  return defaultPriority;\n};\n","import path from 'node:path';\n\nimport type {\n  IProject,\n  Symbol,\n  SymbolIdentifier,\n  SymbolIn,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\n\nimport { HeyApiError } from '~/error';\nimport type { MatchPointerToGroupFn, WalkOptions } from '~/graph';\nimport { walk } from '~/graph';\nimport type { Context } from '~/ir/context';\nimport type { IrTopLevelKind } from '~/ir/graph';\nimport {\n  getIrPointerPriority,\n  irTopLevelKinds,\n  matchIrPointerToGroup,\n  preferGroups,\n} from '~/ir/graph';\nimport type { IR } from '~/ir/types';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Hooks } from '~/parser/types/hooks';\nimport type { Plugin } from '~/plugins';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { BaseEvent, WalkEvent } from '../types/instance';\n\nconst defaultGetFilePath = (symbol: Symbol): string | undefined => {\n  if (!symbol.meta?.pluginName || typeof symbol.meta.pluginName !== 'string') {\n    return;\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/client-')) {\n    return 'client';\n  }\n  if (symbol.meta.pluginName === '@hey-api/typescript') {\n    return 'types';\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/')) {\n    return symbol.meta.pluginName.split('/')[1];\n  }\n  return symbol.meta.pluginName;\n};\n\nconst defaultGetKind: Required<Required<Hooks>['operations']>['getKind'] = (\n  operation,\n) => {\n  switch (operation.method) {\n    case 'delete':\n    case 'patch':\n    case 'post':\n    case 'put':\n      return ['mutation'];\n    case 'get':\n      return ['query'];\n    default:\n      return;\n  }\n};\n\ntype EventHooks = {\n  [K in keyof Required<NonNullable<Hooks['events']>>]: Array<\n    NonNullable<NonNullable<Hooks['events']>[K]>\n  >;\n};\n\nexport class PluginInstance<T extends Plugin.Types = Plugin.Types> {\n  api: T['api'];\n  config: Omit<T['resolvedConfig'], 'name'>;\n  context: Context;\n  dependencies: Required<Plugin.Config<T>>['dependencies'] = [];\n  private eventHooks: EventHooks;\n  gen: IProject;\n  private handler: Plugin.Config<T>['handler'];\n  name: T['resolvedConfig']['name'];\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: Context['package'];\n\n  constructor(\n    props: Pick<\n      Required<Plugin.Config<T>>,\n      'config' | 'dependencies' | 'handler'\n    > & {\n      api?: T['api'];\n      context: Context<OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X>;\n      gen: IProject;\n      name: string;\n    },\n  ) {\n    this.api = props.api ?? {};\n    this.config = props.config;\n    this.context = props.context;\n    this.dependencies = props.dependencies;\n    this.eventHooks = this.buildEventHooks();\n    this.gen = props.gen;\n    this.handler = props.handler;\n    this.name = props.name;\n    this.package = props.context.package;\n  }\n\n  /**\n   * Iterates over various input elements as specified by the event types, in\n   * a specific order: servers, schemas, parameters, request bodies, then\n   * operations.\n   *\n   * This ensures, for example, that schemas are always processed before\n   * operations, which may reference them.\n   *\n   * @template TKind - The event type(s) to yield. Defaults to all event types.\n   * @param events - The event types to walk over. If none are provided, all event types are included.\n   * @param callback - Function to execute for each event.\n   *\n   * @example\n   * // Iterate over all operations and schemas\n   * plugin.forEach('operation', 'schema', (event) => {\n   *   if (event.type === 'operation') {\n   *     // handle operation\n   *   } else if (event.type === 'schema') {\n   *     // handle schema\n   *   }\n   * });\n   */\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n    ]\n  ): void;\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n      options: WalkOptions<TKind>,\n    ]\n  ): void;\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n      options: any,\n    ]\n  ): void {\n    if (!this.context.graph) {\n      throw new Error('No graph available in context');\n    }\n\n    let callback: (event: WalkEvent<TKind>) => void;\n    let events: ReadonlyArray<TKind>;\n    let options: WalkOptions<TKind> = {\n      getPointerPriority: getIrPointerPriority,\n      // default functions operate on the full union of kinds; cast them\n      // to the WalkOptions generic to keep strict typing for callers.\n      matchPointerToGroup:\n        matchIrPointerToGroup as unknown as MatchPointerToGroupFn<TKind>,\n      order: 'topological',\n      preferGroups: preferGroups as unknown as ReadonlyArray<TKind>,\n    };\n    if (typeof args[args.length - 1] === 'function') {\n      events = args.slice(0, -1);\n      callback = args[args.length - 1];\n    } else {\n      events = args.slice(0, -2);\n      callback = args[args.length - 2];\n      options = {\n        ...options,\n        ...args[args.length - 1],\n      };\n    }\n    const eventSet = new Set(events.length ? events : irTopLevelKinds);\n\n    walk(\n      this.context.graph,\n      (pointer, nodeInfo) => {\n        const result = matchIrPointerToGroup(pointer);\n        if (!result.matched || !eventSet.has(result.kind)) return;\n        let event: WalkEvent | undefined;\n        const baseEvent: BaseEvent = {\n          _path: jsonPointerToPath(pointer),\n          pointer,\n          tags: nodeInfo.tags ? Array.from(nodeInfo.tags) : undefined,\n        };\n        switch (result.kind) {\n          case 'operation':\n            event = {\n              ...baseEvent,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              path: baseEvent._path[1] as string,\n              type: result.kind,\n            } satisfies WalkEvent<'operation'>;\n            break;\n          case 'parameter':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              parameter: nodeInfo.node as IR.ParameterObject,\n              type: result.kind,\n            } satisfies WalkEvent<'parameter'>;\n            break;\n          case 'requestBody':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              requestBody: nodeInfo.node as IR.RequestBodyObject,\n              type: result.kind,\n            } satisfies WalkEvent<'requestBody'>;\n            break;\n          case 'schema':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              schema: nodeInfo.node as IR.SchemaObject,\n              type: result.kind,\n            } satisfies WalkEvent<'schema'>;\n            break;\n          case 'server':\n            event = {\n              ...baseEvent,\n              server: nodeInfo.node as IR.ServerObject,\n              type: result.kind,\n            } satisfies WalkEvent<'server'>;\n            break;\n          case 'webhook':\n            event = {\n              ...baseEvent,\n              key: baseEvent._path[1] as string,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              type: result.kind,\n            } satisfies WalkEvent<'webhook'>;\n            break;\n        }\n        if (event) {\n          try {\n            callback(event as WalkEvent<TKind>);\n          } catch (error) {\n            this.forEachError(error, event);\n          }\n        }\n      },\n      options,\n    );\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, undefined otherwise.\n   */\n  getPlugin<TName extends keyof PluginConfigMap>(\n    name: TName,\n  ): TName extends any\n    ? PluginInstance<PluginConfigMap[TName]> | undefined\n    : never {\n    return this.context.plugins[name] as any;\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, throw otherwise.\n   */\n  getPluginOrThrow<TName extends keyof PluginConfigMap>(\n    name: TName,\n  ): TName extends any ? PluginInstance<PluginConfigMap[TName]> : never {\n    const plugin = this.getPlugin(name);\n    if (!plugin) throw new Error(`plugin not found ${name}`);\n    return plugin as any;\n  }\n\n  getSymbol(identifier: SymbolIdentifier): Symbol | undefined {\n    return this.gen.symbols.get(identifier);\n  }\n\n  hooks = {\n    operation: {\n      isMutation: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'mutation'),\n      isQuery: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'query'),\n    },\n  };\n\n  isSymbolRegistered(identifier: SymbolIdentifier): boolean {\n    return this.gen.symbols.isRegistered(identifier);\n  }\n\n  querySymbol(filter: SymbolMeta): Symbol | undefined {\n    return this.gen.symbols.query(filter)[0];\n  }\n\n  referenceSymbol(meta: SymbolMeta): Symbol {\n    return this.gen.symbols.reference(meta);\n  }\n\n  registerSymbol(symbol: SymbolIn): Symbol {\n    const symbolIn: SymbolIn = {\n      ...symbol,\n      exportFrom:\n        symbol.exportFrom ??\n        (!symbol.external &&\n        this.context.config.output.indexFile &&\n        this.config.exportFromIndex\n          ? ['index']\n          : undefined),\n      getFilePath: symbol.getFilePath ?? this.getSymbolFilePath.bind(this),\n      meta: {\n        pluginName: path.isAbsolute(this.name) ? 'custom' : this.name,\n        ...symbol.meta,\n      },\n    };\n    for (const hook of this.eventHooks['symbol:register:before']) {\n      hook({ plugin: this, symbol: symbolIn });\n    }\n    const symbolOut = this.gen.symbols.register(symbolIn);\n    for (const hook of this.eventHooks['symbol:register:after']) {\n      hook({ plugin: this, symbol: symbolOut });\n    }\n    return symbolOut;\n  }\n\n  /**\n   * Executes plugin's handler function.\n   */\n  async run(): Promise<void> {\n    for (const hook of this.eventHooks['plugin:handler:before']) {\n      hook({ plugin: this });\n    }\n    await this.handler({ plugin: this });\n    for (const hook of this.eventHooks['plugin:handler:after']) {\n      hook({ plugin: this });\n    }\n  }\n\n  setSymbolValue(symbol: Symbol, value: unknown): void {\n    for (const hook of this.eventHooks['symbol:setValue:before']) {\n      hook({ plugin: this, symbol, value });\n    }\n    this.gen.symbols.setValue(symbol.id, value);\n    for (const hook of this.eventHooks['symbol:setValue:after']) {\n      hook({ plugin: this, symbol, value });\n    }\n  }\n\n  private buildEventHooks(): EventHooks {\n    const result: EventHooks = {\n      'plugin:handler:after': [],\n      'plugin:handler:before': [],\n      'symbol:register:after': [],\n      'symbol:register:before': [],\n      'symbol:setValue:after': [],\n      'symbol:setValue:before': [],\n    };\n    const scopes = [\n      this.config['~hooks']?.events,\n      this.context.config.parser.hooks.events,\n    ];\n    for (const scope of scopes) {\n      if (!scope) continue;\n      for (const [key, value] of Object.entries(scope)) {\n        if (value) {\n          result[key as keyof typeof result].push(value.bind(scope) as any);\n        }\n      }\n    }\n    return result;\n  }\n\n  private forEachError(error: unknown, event: WalkEvent) {\n    const originalError =\n      error instanceof Error ? error : new Error(String(error));\n    throw new HeyApiError({\n      args: [event],\n      error: originalError,\n      event: event.type,\n      name: 'Error',\n      pluginName: this.name,\n    });\n  }\n\n  private getSymbolFilePath(symbol: Symbol): string | undefined {\n    const hooks = [\n      this.config['~hooks']?.symbols,\n      this.context.config.parser.hooks.symbols,\n    ];\n    for (const hook of hooks) {\n      const result = hook?.getFilePath?.(symbol);\n      if (result !== undefined) return result;\n    }\n    return defaultGetFilePath(symbol);\n  }\n\n  private isOperationKind(\n    operation: IR.OperationObject,\n    kind: 'mutation' | 'query',\n  ): boolean {\n    const method = kind === 'query' ? 'isQuery' : 'isMutation';\n    const hooks = [\n      this.config['~hooks']?.operations?.[method],\n      this.config['~hooks']?.operations?.getKind,\n      this.context.config.parser.hooks.operations?.[method],\n      this.context.config.parser.hooks.operations?.getKind,\n      defaultGetKind,\n    ];\n    for (const hook of hooks) {\n      if (hook) {\n        const result = hook(operation);\n        if (result !== undefined) {\n          return typeof result === 'boolean' ? result : result.includes(kind);\n        }\n      }\n    }\n    return false;\n  }\n}\n","import { Project } from '@hey-api/codegen-core';\n\nimport type { Package } from '~/config/utils/package';\nimport { packageFactory } from '~/config/utils/package';\nimport { TypeScriptRenderer } from '~/generate/renderer';\nimport type { Graph } from '~/graph';\nimport { buildName } from '~/openApi/shared/utils/name';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport { PluginInstance } from '~/plugins/shared/utils/instance';\nimport type { PluginNames } from '~/plugins/types';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\nimport { resolveRef } from '~/utils/ref';\n\nimport type { IR } from './types';\n\nexport class Context<Spec extends Record<string, any> = any> {\n  /**\n   * Configuration for parsing and generating the output. This\n   * is a mix of user-provided and default values.\n   */\n  config: Config;\n  /**\n   * The code generation project instance used to manage files, symbols,\n   */\n  gen: Project;\n  /**\n   * The dependency graph built from the intermediate representation.\n   */\n  graph: Graph | undefined;\n  /**\n   * Intermediate representation model obtained from `spec`.\n   */\n  ir: IR.Model = {};\n  /**\n   * Logger instance.\n   */\n  logger: Logger;\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: Package;\n  /**\n   * A map of registered plugin instances, keyed by plugin name. Plugins are\n   * registered through the `registerPlugin` method and can be accessed by\n   * their configured name from the config.\n   */\n  plugins: Partial<\n    Record<PluginNames, PluginInstance<PluginConfigMap[keyof PluginConfigMap]>>\n  > = {};\n  /**\n   * Resolved specification from `input`.\n   */\n  spec: Spec;\n\n  constructor({\n    config,\n    dependencies,\n    logger,\n    spec,\n  }: {\n    config: Config;\n    dependencies: Record<string, string>;\n    logger: Logger;\n    spec: Spec;\n  }) {\n    this.config = config;\n    this.gen = new Project({\n      defaultFileName: 'index',\n      fileName: (base) => {\n        const name = buildName({\n          config: config.output.fileName,\n          name: base,\n        });\n        const { suffix } = config.output.fileName;\n        if (!suffix) {\n          return name;\n        }\n        return name === 'index' || name.endsWith(suffix)\n          ? name\n          : `${name}${suffix}`;\n      },\n      renderers: {\n        // TODO: allow overriding via config with custom renderers\n        '.ts': new TypeScriptRenderer(),\n      },\n      root: config.output.path,\n    });\n    this.logger = logger;\n    this.package = packageFactory(dependencies);\n    this.spec = spec;\n  }\n\n  /**\n   * Returns a resolved and dereferenced schema from `spec`.\n   */\n  dereference<T>(schema: { $ref: string }) {\n    const resolved = this.resolveRef<T>(schema.$ref);\n    const dereferenced = {\n      ...schema,\n      ...resolved,\n    } as T;\n    // @ts-expect-error\n    delete dereferenced.$ref;\n    return dereferenced;\n  }\n\n  /**\n   * Registers a new plugin to the global context.\n   *\n   * @param name Plugin name.\n   * @returns Registered plugin instance.\n   */\n  private registerPlugin<T extends PluginNames>(\n    name: T,\n  ): PluginInstance<PluginConfigMap[T]> {\n    const plugin = this.config.plugins[name]!;\n    const instance = new PluginInstance({\n      api: plugin.api,\n      config: plugin.config as any,\n      context: this as any,\n      dependencies: plugin.dependencies ?? [],\n      gen: this.gen,\n      handler: plugin.handler,\n      name: plugin.name,\n    });\n    this.plugins[instance.name] = instance;\n    return instance;\n  }\n\n  /**\n   * Registers all plugins in the order specified by the configuration and returns\n   * an array of the registered PluginInstance objects. Each plugin is instantiated\n   * and added to the context's plugins map.\n   *\n   * @returns {ReadonlyArray<PluginInstance>} An array of registered plugin instances in order.\n   */\n  registerPlugins(): ReadonlyArray<PluginInstance> {\n    return this.config.pluginOrder.map((name) => this.registerPlugin(name));\n  }\n\n  // TODO: parser - works the same as resolveRef, but for IR schemas.\n  // for now, they map 1:1, but if they diverge (like with OpenAPI 2.0),\n  // we will want to rewrite $refs at parse time, so they continue pointing\n  // to the correct IR location\n  resolveIrRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.ir,\n    });\n  }\n\n  /**\n   * Returns a resolved reference from `spec`.\n   */\n  resolveRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.spec,\n    });\n  }\n}\n","import type { Context } from '~/ir/context';\nimport { createOperationKey } from '~/ir/operation';\nimport { sanitizeNamespaceIdentifier } from '~/openApi/common/parser/sanitize';\nimport { stringCase } from '~/utils/stringCase';\n\nimport type { State } from '../types/state';\n\nexport const httpMethods = [\n  'delete',\n  'get',\n  'head',\n  'options',\n  'patch',\n  'post',\n  'put',\n  'trace',\n] as const;\n\n/**\n * Returns an operation ID to use across the application. By default, we try\n * to use the provided ID. If it's not provided or the SDK is configured\n * to exclude it, we generate operation ID from its location.\n */\nexport const operationToId = ({\n  context,\n  count = 1,\n  id,\n  method,\n  path,\n  state,\n}: {\n  context: Context;\n  count?: number;\n  id: string | undefined;\n  method: string;\n  path: string;\n  state: Pick<State, 'ids'>;\n}): string => {\n  let result: string;\n\n  const { output } = context.config;\n  const targetCase =\n    (output !== undefined && typeof output === 'object' && 'case' in output\n      ? output.case\n      : undefined) ?? 'camelCase';\n\n  if (\n    id &&\n    (!context.config.plugins['@hey-api/sdk'] ||\n      context.config.plugins['@hey-api/sdk'].config.operationId)\n  ) {\n    result = stringCase({\n      case: targetCase,\n      value: sanitizeNamespaceIdentifier(id),\n    });\n  } else {\n    const pathWithoutPlaceholders = path\n      .replace(/{(.*?)}/g, 'by-$1')\n      // replace slashes with hyphens for camelcase method at the end\n      .replace(/[/:+]/g, '-');\n\n    result = stringCase({\n      case: targetCase,\n      value: `${method}-${pathWithoutPlaceholders}`,\n    });\n  }\n\n  if (count > 1) {\n    result = `${result}${count}`;\n  }\n\n  if (state.ids.has(result)) {\n    return operationToId({\n      context,\n      count: count + 1,\n      id,\n      method,\n      path,\n      state,\n    });\n  }\n\n  state.ids.set(result, createOperationKey({ method, path }));\n\n  return result;\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { PathItemObject, PathsObject } from '~/openApi/3.1.x/types/spec';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Logger } from '~/utils/logger';\n\nimport type { Config } from '../../../types/config';\nimport type { ResourceMetadata } from '../graph/meta';\nimport { httpMethods } from './operation';\n\ntype FilterNamespace =\n  | 'body'\n  | 'operation'\n  | 'parameter'\n  | 'response'\n  | 'schema'\n  | 'unknown';\n\nconst namespaceNeedle = '/';\n\nexport const addNamespace = (\n  namespace: FilterNamespace,\n  value: string = '',\n): string => `${namespace}${namespaceNeedle}${value}`;\n\nexport const removeNamespace = (\n  key: string,\n): {\n  name: string;\n  namespace: FilterNamespace;\n} => {\n  const index = key.indexOf(namespaceNeedle);\n  const name = key.slice(index + 1);\n  return {\n    name,\n    namespace: key.slice(0, index)! as FilterNamespace,\n  };\n};\n\n/**\n * Converts reference strings from OpenAPI $ref keywords into namespaces.\n *\n * @example '#/components/schemas/Foo' -> 'schema'\n */\nexport const stringToNamespace = (value: string): FilterNamespace => {\n  switch (value) {\n    case 'parameters':\n      return 'parameter';\n    case 'requestBodies':\n      return 'body';\n    case 'responses':\n      return 'response';\n    case 'definitions':\n    case 'schemas':\n      return 'schema';\n    default:\n      return 'unknown';\n  }\n};\n\ntype FiltersConfigToState<T> = {\n  [K in keyof T]-?: NonNullable<T[K]> extends ReadonlyArray<infer U>\n    ? Set<U>\n    : NonNullable<T[K]> extends object\n      ? FiltersConfigToState<NonNullable<T[K]>>\n      : T[K];\n};\n\nexport type Filters = FiltersConfigToState<\n  NonNullable<Config['parser']['filters']>\n>;\n\ninterface SetAndRegExps {\n  regexps: Array<RegExp>;\n  set: Set<string>;\n}\n\nconst createFiltersSetAndRegExps = (\n  type: FilterNamespace,\n  filters: ReadonlyArray<string> | undefined,\n): SetAndRegExps => {\n  const keys: Array<string> = [];\n  const regexps: Array<RegExp> = [];\n  if (filters) {\n    for (const value of filters) {\n      if (value.startsWith('/') && value.endsWith('/')) {\n        regexps.push(new RegExp(value.slice(1, value.length - 1)));\n      } else {\n        keys.push(addNamespace(type, value));\n      }\n    }\n  }\n  return {\n    regexps,\n    set: new Set(keys),\n  };\n};\n\ninterface CollectFiltersSetFromRegExps {\n  excludeOperations: SetAndRegExps;\n  excludeParameters: SetAndRegExps;\n  excludeRequestBodies: SetAndRegExps;\n  excludeResponses: SetAndRegExps;\n  excludeSchemas: SetAndRegExps;\n  includeOperations: SetAndRegExps;\n  includeParameters: SetAndRegExps;\n  includeRequestBodies: SetAndRegExps;\n  includeResponses: SetAndRegExps;\n  includeSchemas: SetAndRegExps;\n}\n\nconst collectFiltersSetFromRegExpsOpenApiV2 = ({\n  excludeOperations,\n  excludeSchemas,\n  includeOperations,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.definitions) {\n    // TODO: add parameters\n\n    if (excludeSchemas.regexps.length || includeSchemas.regexps.length) {\n      for (const key of Object.keys(spec.definitions)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExpsOpenApiV3 = ({\n  excludeOperations,\n  excludeParameters,\n  excludeRequestBodies,\n  excludeResponses,\n  excludeSchemas,\n  includeOperations,\n  includeParameters,\n  includeRequestBodies,\n  includeResponses,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V3_0_X | OpenApi.V3_1_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.components) {\n    if (\n      (excludeParameters.regexps.length || includeParameters.regexps.length) &&\n      spec.components.parameters\n    ) {\n      for (const key of Object.keys(spec.components.parameters)) {\n        if (excludeParameters.regexps.some((regexp) => regexp.test(key))) {\n          excludeParameters.set.add(addNamespace('parameter', key));\n        }\n        if (includeParameters.regexps.some((regexp) => regexp.test(key))) {\n          includeParameters.set.add(addNamespace('parameter', key));\n        }\n      }\n    }\n\n    if (\n      (excludeRequestBodies.regexps.length ||\n        includeRequestBodies.regexps.length) &&\n      spec.components.requestBodies\n    ) {\n      for (const key of Object.keys(spec.components.requestBodies)) {\n        if (excludeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          excludeRequestBodies.set.add(addNamespace('body', key));\n        }\n        if (includeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          includeRequestBodies.set.add(addNamespace('body', key));\n        }\n      }\n    }\n\n    if (\n      (excludeResponses.regexps.length || includeResponses.regexps.length) &&\n      spec.components.responses\n    ) {\n      for (const key of Object.keys(spec.components.responses)) {\n        if (excludeResponses.regexps.some((regexp) => regexp.test(key))) {\n          excludeResponses.set.add(addNamespace('response', key));\n        }\n        if (includeResponses.regexps.some((regexp) => regexp.test(key))) {\n          includeResponses.set.add(addNamespace('response', key));\n        }\n      }\n    }\n\n    if (\n      (excludeSchemas.regexps.length || includeSchemas.regexps.length) &&\n      spec.components.schemas\n    ) {\n      for (const key of Object.keys(spec.components.schemas)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExps = ({\n  spec,\n  ...filters\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X;\n}): void => {\n  if ('swagger' in spec) {\n    collectFiltersSetFromRegExpsOpenApiV2({ ...filters, spec });\n  } else {\n    collectFiltersSetFromRegExpsOpenApiV3({ ...filters, spec });\n  }\n};\n\nexport const createFilters = (\n  config: Config['parser']['filters'],\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  logger: Logger,\n): Filters => {\n  const eventCreateFilters = logger.timeEvent('create-filters');\n  const excludeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.exclude,\n  );\n  const includeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.include,\n  );\n  const excludeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.exclude,\n  );\n  const includeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.include,\n  );\n  const excludeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.exclude,\n  );\n  const includeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.include,\n  );\n  const excludeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.exclude,\n  );\n  const includeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.include,\n  );\n  const excludeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.exclude,\n  );\n  const includeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.include,\n  );\n\n  collectFiltersSetFromRegExps({\n    excludeOperations,\n    excludeParameters,\n    excludeRequestBodies,\n    excludeResponses,\n    excludeSchemas,\n    includeOperations,\n    includeParameters,\n    includeRequestBodies,\n    includeResponses,\n    includeSchemas,\n    spec,\n  });\n\n  const filters: Filters = {\n    deprecated: config?.deprecated ?? true,\n    operations: {\n      exclude: excludeOperations.set,\n      include: includeOperations.set,\n    },\n    orphans: config?.orphans ?? false,\n    parameters: {\n      exclude: excludeParameters.set,\n      include: includeParameters.set,\n    },\n    preserveOrder: config?.preserveOrder ?? false,\n    requestBodies: {\n      exclude: excludeRequestBodies.set,\n      include: includeRequestBodies.set,\n    },\n    responses: {\n      exclude: excludeResponses.set,\n      include: includeResponses.set,\n    },\n    schemas: {\n      exclude: excludeSchemas.set,\n      include: includeSchemas.set,\n    },\n    tags: {\n      exclude: new Set(config?.tags?.exclude),\n      include: new Set(config?.tags?.include),\n    },\n  };\n  eventCreateFilters.timeEnd();\n  return filters;\n};\n\nexport const hasFilters = (config: Config['parser']['filters']): boolean => {\n  if (!config) {\n    return false;\n  }\n\n  // we explicitly want to strip orphans or deprecated\n  if (config.orphans === false || config.deprecated === false) {\n    return true;\n  }\n\n  return Boolean(\n    config.operations?.exclude?.length ||\n      config.operations?.include?.length ||\n      config.parameters?.exclude?.length ||\n      config.parameters?.include?.length ||\n      config.requestBodies?.exclude?.length ||\n      config.requestBodies?.include?.length ||\n      config.responses?.exclude?.length ||\n      config.responses?.include?.length ||\n      config.schemas?.exclude?.length ||\n      config.schemas?.include?.length ||\n      config.tags?.exclude?.length ||\n      config.tags?.include?.length,\n  );\n};\n\n/**\n * Collect operations that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectOperations = ({\n  filters,\n  parameters,\n  requestBodies,\n  resourceMetadata,\n  responses,\n  schemas,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n  schemas: Set<string>;\n}): {\n  operations: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.operations.include.size\n    ? filters.operations.include\n    : new Set(resourceMetadata.operations.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.operations.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.operations.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    if (\n      filters.tags.exclude.size &&\n      node.tags.size &&\n      [...filters.tags.exclude].some((tag) => node.tags.has(tag))\n    ) {\n      continue;\n    }\n\n    if (\n      filters.tags.include.size &&\n      !new Set([...filters.tags.include].filter((tag) => node.tags.has(tag)))\n        .size\n    ) {\n      continue;\n    }\n\n    // skip operation if it references any component not included\n    if (\n      [...node.dependencies].some((dependency) => {\n        const { namespace } = removeNamespace(dependency);\n        switch (namespace) {\n          case 'body':\n            return !requestBodies.has(dependency);\n          case 'parameter':\n            return !parameters.has(dependency);\n          case 'response':\n            return !responses.has(dependency);\n          case 'schema':\n            return !schemas.has(dependency);\n          default:\n            return false;\n        }\n      })\n    ) {\n      continue;\n    }\n\n    finalSet.add(key);\n  }\n  return { operations: finalSet };\n};\n\n/**\n * Collect parameters that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectParameters = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  parameters: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.parameters.include.size\n    ? filters.parameters.include\n    : new Set(resourceMetadata.parameters.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.parameters.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { parameters: finalSet };\n};\n\n/**\n * Collect request bodies that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectRequestBodies = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  requestBodies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.requestBodies.include.size\n    ? filters.requestBodies.include\n    : new Set(resourceMetadata.requestBodies.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.requestBodies.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { requestBodies: finalSet };\n};\n\n/**\n * Collect responses that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectResponses = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  responses: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.responses.include.size\n    ? filters.responses.include\n    : new Set(resourceMetadata.responses.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.responses.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { responses: finalSet };\n};\n\n/**\n * Collect schemas that satisfy the include/exclude filters.\n */\nconst collectSchemas = ({\n  filters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n}): {\n  schemas: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.schemas.include.size\n    ? filters.schemas.include\n    : new Set(resourceMetadata.schemas.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.schemas.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'schema': {\n          if (\n            !finalSet.has(dependency) &&\n            !filters.schemas.exclude.has(dependency)\n          ) {\n            stack.push(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { schemas: finalSet };\n};\n\n/**\n * Drop parameters that depend on already excluded parameters.\n */\nconst dropExcludedParameters = ({\n  filters,\n  parameters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.parameters.exclude.size) {\n    return;\n  }\n\n  for (const key of parameters) {\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.parameters.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        parameters.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop request bodies that depend on already excluded request bodies.\n */\nconst dropExcludedRequestBodies = ({\n  filters,\n  requestBodies,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.requestBodies.exclude.size) {\n    return;\n  }\n\n  for (const key of requestBodies) {\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.requestBodies.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        requestBodies.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop responses that depend on already excluded responses.\n */\nconst dropExcludedResponses = ({\n  filters,\n  resourceMetadata,\n  responses,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n}): void => {\n  if (!filters.responses.exclude.size) {\n    return;\n  }\n\n  for (const key of responses) {\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.responses.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        responses.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop schemas that depend on already excluded schemas.\n */\nconst dropExcludedSchemas = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): void => {\n  if (!filters.schemas.exclude.size) {\n    return;\n  }\n\n  for (const key of schemas) {\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.schemas.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        schemas.delete(key);\n        break;\n      }\n    }\n  }\n};\n\nconst dropOrphans = ({\n  operationDependencies,\n  parameters,\n  requestBodies,\n  responses,\n  schemas,\n}: {\n  operationDependencies: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n}) => {\n  for (const key of schemas) {\n    if (!operationDependencies.has(key)) {\n      schemas.delete(key);\n    }\n  }\n  for (const key of parameters) {\n    if (!operationDependencies.has(key)) {\n      parameters.delete(key);\n    }\n  }\n  for (const key of requestBodies) {\n    if (!operationDependencies.has(key)) {\n      requestBodies.delete(key);\n    }\n  }\n  for (const key of responses) {\n    if (!operationDependencies.has(key)) {\n      responses.delete(key);\n    }\n  }\n};\n\nconst collectOperationDependencies = ({\n  operations,\n  resourceMetadata,\n}: {\n  operations: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operationDependencies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = new Set(\n    [...operations].flatMap((key) => [\n      ...(resourceMetadata.operations.get(key)?.dependencies ?? []),\n    ]),\n  );\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (finalSet.has(key)) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    const { namespace } = removeNamespace(key);\n    let dependencies: Set<string> | undefined;\n    if (namespace === 'body') {\n      dependencies = resourceMetadata.requestBodies.get(key)?.dependencies;\n    } else if (namespace === 'operation') {\n      dependencies = resourceMetadata.operations.get(key)?.dependencies;\n    } else if (namespace === 'parameter') {\n      dependencies = resourceMetadata.parameters.get(key)?.dependencies;\n    } else if (namespace === 'response') {\n      dependencies = resourceMetadata.responses.get(key)?.dependencies;\n    } else if (namespace === 'schema') {\n      dependencies = resourceMetadata.schemas.get(key)?.dependencies;\n    }\n\n    if (!dependencies?.size) {\n      continue;\n    }\n\n    for (const dependency of dependencies) {\n      if (!finalSet.has(dependency)) {\n        stack.push(dependency);\n      }\n    }\n  }\n  return { operationDependencies: finalSet };\n};\n\nexport const createFilteredDependencies = ({\n  filters,\n  logger,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  logger: Logger;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operations: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n} => {\n  const eventCreateFilteredDependencies = logger.timeEvent(\n    'create-filtered-dependencies',\n  );\n  const { schemas } = collectSchemas({ filters, resourceMetadata });\n  const { parameters } = collectParameters({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { requestBodies } = collectRequestBodies({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { responses } = collectResponses({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n\n  dropExcludedSchemas({ filters, resourceMetadata, schemas });\n  dropExcludedParameters({ filters, parameters, resourceMetadata });\n  dropExcludedRequestBodies({ filters, requestBodies, resourceMetadata });\n  dropExcludedResponses({ filters, resourceMetadata, responses });\n\n  // collect operations after dropping components\n  const { operations } = collectOperations({\n    filters,\n    parameters,\n    requestBodies,\n    resourceMetadata,\n    responses,\n    schemas,\n  });\n\n  if (!filters.orphans && operations.size) {\n    const { operationDependencies } = collectOperationDependencies({\n      operations,\n      resourceMetadata,\n    });\n    dropOrphans({\n      operationDependencies,\n      parameters,\n      requestBodies,\n      responses,\n      schemas,\n    });\n  }\n\n  eventCreateFilteredDependencies.timeEnd();\n  return {\n    operations,\n    parameters,\n    requestBodies,\n    responses,\n    schemas,\n  };\n};\n","import type { Graph } from '~/graph';\nimport { createOperationKey } from '~/ir/operation';\nimport type { Logger } from '~/utils/logger';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport { addNamespace, stringToNamespace } from '../utils/filter';\nimport { httpMethods } from '../utils/operation';\n\nexport type ResourceMetadata = {\n  operations: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n      tags: Set<string>;\n    }\n  >;\n  parameters: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  requestBodies: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  responses: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  schemas: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n};\n\n/**\n * Builds a resource metadata map from a Graph, matching the old Graph interface\n * for compatibility with filtering code.\n */\nexport const buildResourceMetadata = (\n  graph: Graph,\n  logger: Logger,\n): {\n  resourceMetadata: ResourceMetadata;\n} => {\n  const eventBuildResourceMetadata = logger.timeEvent(\n    'build-resource-metadata',\n  );\n  const resourceMetadata: ResourceMetadata = {\n    operations: new Map(),\n    parameters: new Map(),\n    requestBodies: new Map(),\n    responses: new Map(),\n    schemas: new Map(),\n  };\n\n  const getDependencies = (pointer: string): Set<string> => {\n    const dependencies = new Set<string>();\n    const nodeDependencies = graph.transitiveDependencies.get(pointer);\n    if (nodeDependencies?.size) {\n      for (const dependency of nodeDependencies) {\n        const path = jsonPointerToPath(dependency);\n        const type = path[path.length - 2];\n        const name = path[path.length - 1];\n        if (type && name) {\n          const namespace = stringToNamespace(type);\n          if (namespace === 'unknown') {\n            console.warn(`unsupported type: ${type}`);\n          }\n          dependencies.add(addNamespace(namespace, name));\n        }\n      }\n    }\n    return dependencies;\n  };\n\n  // Process each node to find top-level resources\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    // const node = nodeInfo.node as Record<string, unknown>;\n    const path = jsonPointerToPath(pointer);\n\n    // OpenAPI 3.x\n    if (path[0] === 'components') {\n      if (path.length === 3) {\n        if (path[1] === 'schemas') {\n          // Schema: #/components/schemas/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.schemas.set(addNamespace('schema', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'parameters') {\n          // Parameter: #/components/parameters/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.parameters.set(addNamespace('parameter', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'requestBodies') {\n          // RequestBody: #/components/requestBodies/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.requestBodies.set(addNamespace('body', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'responses') {\n          // Response: #/components/responses/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.responses.set(addNamespace('response', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        }\n      }\n      continue;\n    }\n\n    if (path[0] === 'paths') {\n      if (\n        path.length === 3 &&\n        httpMethods.includes(path[2] as (typeof httpMethods)[number])\n      ) {\n        // Operation: #/paths/{path}/{method}\n        const method = path[path.length - 1]!;\n        const operationPath = path.slice(1, -1).join('/');\n        const operationKey = createOperationKey({\n          method,\n          path: operationPath,\n        });\n        resourceMetadata.operations.set(\n          addNamespace('operation', operationKey),\n          {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n            tags: nodeInfo.tags ?? new Set(),\n          },\n        );\n      }\n      continue;\n    }\n\n    // OpenAPI 2.0\n    if (path[0] === 'definitions') {\n      if (path.length === 2) {\n        // Schema: #/definitions/{name}\n        const name = path[path.length - 1]!;\n        resourceMetadata.schemas.set(addNamespace('schema', name), {\n          dependencies: getDependencies(pointer),\n          deprecated: nodeInfo.deprecated ?? false,\n        });\n      }\n      continue;\n    }\n  }\n\n  eventBuildResourceMetadata.timeEnd();\n  return { resourceMetadata };\n};\n","export const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));\n","export const childSchemaRelationships = [\n  ['additionalProperties', 'single'],\n  ['allOf', 'array'],\n  ['anyOf', 'array'],\n  ['contains', 'single'],\n  ['dependentSchemas', 'objectMap'],\n  ['else', 'single'],\n  ['if', 'single'],\n  ['items', 'singleOrArray'],\n  ['oneOf', 'array'],\n  ['patternProperties', 'objectMap'],\n  ['properties', 'objectMap'],\n  ['propertyNames', 'single'],\n  ['then', 'single'],\n] as const;\n","export const getSchemasObject = (\n  spec: unknown,\n): Record<string, unknown> | undefined => {\n  if (hasComponentsSchemasObject(spec)) {\n    return (spec as any).components.schemas;\n  }\n  if (hasDefinitionsObject(spec)) {\n    return (spec as any).definitions;\n  }\n  return;\n};\n\n/**\n * Checks if the given spec has a valid OpenAPI 3.x components.schemas object.\n * Returns true if present, false otherwise.\n */\nexport const hasComponentsSchemasObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'components' in spec &&\n  typeof (spec as any).components === 'object' &&\n  (spec as any).components !== null &&\n  'schemas' in (spec as any).components &&\n  typeof (spec as any).components.schemas === 'object' &&\n  (spec as any).components.schemas !== null;\n\n/**\n * Checks if the given spec has a valid OpenAPI 2.0 definitions object.\n * Returns true if present, false otherwise.\n */\nexport const hasDefinitionsObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'definitions' in spec &&\n  typeof (spec as any).definitions === 'object' &&\n  (spec as any).definitions !== null;\n","type Obj =\n  | Record<string, unknown>\n  | Set<string>\n  | ReadonlyArray<string | undefined>;\n\nconst hasName = (obj: Obj, value: string): boolean => {\n  if (obj instanceof Set) {\n    return obj.has(value);\n  }\n  if (obj instanceof Array) {\n    return obj.includes(value);\n  }\n  return value in obj;\n};\n\nexport const getUniqueComponentName = ({\n  base,\n  components,\n  extraComponents,\n}: {\n  base: string;\n  /**\n   * Input components.\n   */\n  components: Obj;\n  /**\n   * Temporary input components, waiting to be inserted for example.\n   */\n  extraComponents?: Obj;\n}): string => {\n  let index = 2;\n  let name = base;\n  while (\n    hasName(components, name) ||\n    (extraComponents && hasName(extraComponents, name))\n  ) {\n    name = `${base}${index}`;\n    index += 1;\n  }\n  return name;\n};\n\nexport const isPathRootSchema = (path: ReadonlyArray<string | number>) =>\n  (path.length === 3 && path[0] === 'components' && path[1] === 'schemas') ||\n  (path.length === 2 && path[0] === 'definitions');\n\nexport const specToSchemasPointerNamespace = (spec: unknown): string => {\n  if (spec && typeof spec === 'object') {\n    if ('swagger' in spec) {\n      // #/definitions/SchemaName\n      return '#/definitions/';\n    }\n\n    if ('openapi' in spec) {\n      // #/components/schemas/SchemaName\n      return '#/components/schemas/';\n    }\n  }\n\n  return '';\n};\n","import { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport { buildName } from '../utils/name';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport { getSchemasObject } from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype EnumsConfig = Config['parser']['transforms']['enums'];\n\n/**\n * Generate a unique, structural signature for an enum schema for deduplication.\n * Only considers 'type' and sorted 'enum' values, ignoring other fields.\n *\n * @param schema - The schema object to analyze\n * @returns A string signature if the schema is an enum, otherwise undefined\n */\nconst getEnumSignature = (schema: unknown): string | undefined => {\n  if (\n    !schema ||\n    typeof schema !== 'object' ||\n    !('enum' in schema) ||\n    !(schema.enum instanceof Array)\n  ) {\n    return;\n  }\n  // Use type + sorted enum values for signature\n  const type = ('type' in schema ? schema.type : undefined) || '';\n  const values = [...schema.enum].sort();\n  return JSON.stringify({ type, values });\n};\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object/array\n * that could contain an enum. Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    'enum' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Inlines all root/top-level enums by replacing $refs to them with the actual enum schema,\n * and then removes the now-unreferenced root enums from the schemas object.\n *\n * @param spec - The OpenAPI spec object to transform\n */\nconst inlineMode = ({ spec }: { spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  // Collect all root enums\n  const rootEnums: Record<string, unknown> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnums[`${schemasPointerNamespace}${name}`] = schema;\n    }\n  }\n\n  // Walk the spec and replace $refs to root enums with inline enum schemas\n  const replaceEnumRefs = (node: unknown) => {\n    if (node instanceof Array) {\n      node.forEach(replaceEnumRefs);\n    } else if (node && typeof node === 'object') {\n      for (const [k, v] of Object.entries(node)) {\n        if (k === '$ref' && typeof v === 'string' && v in rootEnums) {\n          // Replace $ref with a deep clone of the enum schema\n          Object.assign(node, deepClone(rootEnums[v]));\n          delete (node as Record<string, unknown>)['$ref'];\n        } else {\n          replaceEnumRefs(v);\n        }\n      }\n    }\n  };\n  replaceEnumRefs(spec);\n\n  // Remove unreferenced root enums\n  for (const pointer of Object.keys(rootEnums)) {\n    const path = jsonPointerToPath(pointer);\n    const name = path[path.length - 1]!;\n    if (name) {\n      delete schemasObj[name];\n    }\n  }\n};\n\n/**\n * Promotes all inline enums to reusable root components (if mode is 'root'),\n * deduplicates by signature, and replaces inline enums with $refs.\n *\n * Naming, casing, and deduplication are controlled by the enums transform config.\n * Existing root enums are reused if structurally identical.\n *\n * @param spec - The OpenAPI spec object to transform\n * @param config - The enums transform config\n */\nconst rootMode = ({ config, spec }: { config: EnumsConfig; spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  // Build a map of existing root enum signatures to their names for deduplication\n  const rootEnumSignatures: Record<string, string> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnumSignatures[signature] = name;\n    }\n  }\n\n  // Collect all inline enums (not at root schemas)\n  const inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }> = [];\n\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (!isPathRootSchema(nodeInfo.path)) {\n        const signature = getEnumSignature(nodeInfo.node);\n        if (signature) {\n          inlineEnums.push({ ...nodeInfo, signature });\n        }\n      }\n    },\n  });\n\n  // Deduplicate and assign unique names for promoted enums\n  const signatureToName: Record<string, string | undefined> = {};\n  const signatureToSchema: Record<string, unknown> = {};\n\n  for (const { key, node, signature } of inlineEnums) {\n    if (signature in signatureToName) {\n      // Already handled\n      continue;\n    }\n\n    // Use existing root enum if available\n    if (signature in rootEnumSignatures) {\n      signatureToName[signature] = rootEnumSignatures[signature];\n      continue;\n    }\n\n    // Generate a unique name for the new root enum using config\n    const base = buildName({\n      config,\n      name:\n        typeof node === 'object' &&\n        node &&\n        'title' in node &&\n        typeof node.title === 'string'\n          ? node.title\n          : String(key),\n    });\n    const name = getUniqueComponentName({\n      base,\n      components: schemasObj,\n      extraComponents: Object.values(signatureToName),\n    });\n    signatureToName[signature] = name;\n    signatureToSchema[signature] = node;\n  }\n\n  // Add new root enums to the schemas object\n  for (const [signature, name] of Object.entries(signatureToName)) {\n    // Only add if not already present\n    const schema = signatureToSchema[signature];\n    if (name && !(name in schemasObj) && schema && typeof schema === 'object') {\n      schemasObj[name] = schema;\n    }\n  }\n\n  // Replace inline enums with $ref to the new root enum\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  for (const { key, parent, signature } of inlineEnums) {\n    const name = signatureToName[signature];\n    if (name && key != null && parent && typeof parent === 'object') {\n      (parent as Record<string, unknown>)[key] = {\n        $ref: `${schemasPointerNamespace}${name}`,\n      };\n    }\n  }\n};\n\n/**\n * Applies the enums transform according to the configured mode ('inline' or 'root').\n *\n * - In 'inline' mode, all root enums are inlined and removed.\n * - In 'root' mode, all inline enums are promoted to root components and deduplicated.\n *\n * @param config - The enums transform config\n * @param spec - The OpenAPI spec object to transform\n */\nexport const enumsTransform = ({\n  config,\n  spec,\n}: {\n  config: EnumsConfig;\n  spec: unknown;\n}) => {\n  if (config.mode === 'inline') {\n    inlineMode({ spec });\n    return;\n  }\n\n  if (config.mode === 'root') {\n    rootMode({ config, spec });\n    return;\n  }\n};\n","import { childSchemaRelationships } from '../utils/schemaChildRelationships';\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object.\n * Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Applies the properties required by default transform\n *\n * @param spec - The OpenAPI spec object to transform\n */\nexport const propertiesRequiredByDefaultTransform = ({\n  spec,\n}: {\n  spec: unknown;\n}) => {\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (\n        nodeInfo.node &&\n        typeof nodeInfo.node === 'object' &&\n        'type' in nodeInfo.node &&\n        nodeInfo.node.type === 'object' &&\n        'properties' in nodeInfo.node &&\n        nodeInfo.node.properties &&\n        typeof nodeInfo.node.properties === 'object' &&\n        !('required' in nodeInfo.node)\n      ) {\n        const propKeys = Object.keys(\n          nodeInfo.node.properties as Record<string, unknown>,\n        );\n        if (propKeys.length > 0) {\n          (nodeInfo.node as Record<string, unknown>).required = propKeys;\n        }\n      }\n    },\n  });\n};\n","/**\n * Deep equality for JSON-compatible values (objects, arrays, primitives).\n * Used to determine whether read/write pruned variants actually differ.\n */\nconst deepEqual = (a: unknown, b: unknown): boolean => {\n  if (a === b) return true;\n  if (a === null || b === null) return a === b;\n  const typeA = typeof a;\n  const typeB = typeof b;\n  if (typeA !== typeB) return false;\n  if (typeA !== 'object') return false;\n\n  // Arrays\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  // Plain objects\n  const objA = a as Record<string, unknown>;\n  const objB = b as Record<string, unknown>;\n  const keysA = Object.keys(objA).sort();\n  const keysB = Object.keys(objB).sort();\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (keysA[i] !== keysB[i]) return false;\n  }\n  for (const key of keysA) {\n    if (!deepEqual(objA[key], objB[key])) return false;\n  }\n  return true;\n};\n\nexport default deepEqual;\n","import type { Graph, NodeInfo } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { normalizeJsonPointer, pathToJsonPointer } from '~/utils/ref';\n\nimport { childSchemaRelationships } from './schemaChildRelationships';\n\n/**\n * Represents the possible access scopes for OpenAPI nodes.\n * - 'normal': Default scope for regular nodes.\n * - 'read': Node is read-only (e.g., readOnly: true).\n * - 'write': Node is write-only (e.g., writeOnly: true).\n */\nexport type Scope = 'normal' | 'read' | 'write';\n\n/**\n * Ensures every relevant child node (e.g., properties, items) in the graph has a `scopes` property.\n * If a node does not have its own scopes, it inherits from its parent if available.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const annotateChildScopes = (nodes: Graph['nodes']): void => {\n  for (const [, nodeInfo] of nodes) {\n    if (nodeInfo.scopes) continue;\n\n    if (nodeInfo.parentPointer) {\n      const parentInfo = nodes.get(nodeInfo.parentPointer);\n      if (parentInfo?.scopes) {\n        nodeInfo.scopes = new Set(parentInfo.scopes);\n      }\n    }\n  }\n};\n\ninterface Cache {\n  parentToChildren: Map<string, Array<string>>;\n  subtreeDependencies: Map<string, Set<string>>;\n  transitiveDependencies: Map<string, Set<string>>;\n}\n\ntype PointerDependenciesResult = {\n  subtreeDependencies: Set<string>;\n  transitiveDependencies: Set<string>;\n};\n\n/**\n * Recursively collects all $ref dependencies in the subtree rooted at `pointer`.\n */\nconst collectPointerDependencies = ({\n  cache,\n  graph,\n  pointer,\n  visited,\n}: {\n  cache: Cache;\n  graph: Graph;\n  pointer: string;\n  visited: Set<string>;\n}): PointerDependenciesResult => {\n  const cached = cache.transitiveDependencies.get(pointer);\n  if (cached) {\n    return {\n      subtreeDependencies: cache.subtreeDependencies.get(pointer)!,\n      transitiveDependencies: cached,\n    };\n  }\n\n  if (visited.has(pointer)) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n  visited.add(pointer);\n\n  const nodeInfo = graph.nodes.get(pointer);\n  if (!nodeInfo) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n\n  const transitiveDependencies = new Set<string>();\n  const subtreeDependencies = new Set<string>();\n\n  // Add direct $ref dependencies for this node\n  // (from the dependencies map, or by checking nodeInfo.node directly)\n  // We'll use the dependencies map for consistency:\n  const nodeDependencies = graph.nodeDependencies.get(pointer);\n  if (nodeDependencies) {\n    for (const depPointer of nodeDependencies) {\n      transitiveDependencies.add(depPointer);\n      subtreeDependencies.add(depPointer);\n      // Recursively collect dependencies of the referenced node\n      const depResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: depPointer,\n        visited,\n      });\n      for (const dependency of depResult.transitiveDependencies) {\n        transitiveDependencies.add(dependency);\n      }\n    }\n  }\n\n  const children = cache.parentToChildren.get(pointer) ?? [];\n  for (const childPointer of children) {\n    let childResult: Partial<PointerDependenciesResult> = {\n      subtreeDependencies: cache.subtreeDependencies.get(childPointer),\n      transitiveDependencies: cache.transitiveDependencies.get(childPointer),\n    };\n    if (\n      !childResult.subtreeDependencies ||\n      !childResult.transitiveDependencies\n    ) {\n      childResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: childPointer,\n        visited,\n      });\n      cache.transitiveDependencies.set(\n        childPointer,\n        childResult.transitiveDependencies!,\n      );\n      cache.subtreeDependencies.set(\n        childPointer,\n        childResult.subtreeDependencies!,\n      );\n    }\n    for (const dependency of childResult.transitiveDependencies!) {\n      transitiveDependencies.add(dependency);\n    }\n    for (const dependency of childResult.subtreeDependencies!) {\n      subtreeDependencies.add(dependency);\n    }\n  }\n\n  cache.transitiveDependencies.set(pointer, transitiveDependencies);\n  cache.subtreeDependencies.set(pointer, subtreeDependencies);\n  return {\n    subtreeDependencies,\n    transitiveDependencies,\n  };\n};\n\n/**\n * Propagates scopes through the graph using a worklist algorithm.\n * Each node's scopes will be updated to include any scopes inherited via $ref dependencies, combinator/child relationships, and parent relationships.\n * Handles cycles and deep chains efficiently.\n *\n * Whenever a node's scopes change, all dependents are notified:\n *   - Its parent (if any)\n *   - All nodes that reference it via $ref (reverse dependencies)\n *   - Combinator parents (allOf/anyOf/oneOf) if applicable\n *\n * @param graph - The Graph structure containing nodes, dependencies, and reverseNodeDependencies.\n */\nexport const propagateScopes = (graph: Graph): void => {\n  const worklist: Set<string> = new Set(\n    Array.from(graph.nodes.entries())\n      .filter(([, nodeInfo]) => nodeInfo.scopes && nodeInfo.scopes.size > 0)\n      .map(([pointer]) => pointer),\n  );\n\n  /**\n   * Notifies all dependents of a node that its scopes may have changed.\n   * Dependents include:\n   *   - The parent node (if any)\n   *   - All nodes that reference this node via $ref (reverse dependencies)\n   *   - Combinator parents (allOf/anyOf/oneOf) if this node is a combinator child\n   *\n   * @param pointer - The JSON pointer of the node whose dependents to notify\n   * @param nodeInfo - The NodeInfo of the node\n   * @param childPointer - (Optional) The pointer of the child, used to detect combinator parents\n   */\n  const notifyAllDependents = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer?: string,\n  ) => {\n    if (nodeInfo.parentPointer) {\n      worklist.add(nodeInfo.parentPointer);\n    }\n    const reverseNodeDependencies = graph.reverseNodeDependencies.get(pointer);\n    if (reverseNodeDependencies) {\n      for (const dependentPointer of reverseNodeDependencies) {\n        worklist.add(dependentPointer);\n      }\n    }\n    if (childPointer) {\n      // If this is a combinator child, notify the combinator parent\n      const combinatorChildMatch = childPointer.match(\n        /(.*)\\/(allOf|anyOf|oneOf)\\/\\d+$/,\n      );\n      if (combinatorChildMatch) {\n        const combinatorParentPointer = combinatorChildMatch[1];\n        if (combinatorParentPointer) {\n          worklist.add(combinatorParentPointer);\n        }\n      }\n    }\n  };\n\n  /**\n   * Propagates scopes from a child node to its parent node.\n   * If the parent's scopes change, notifies all dependents.\n   *\n   * @param pointer - The parent node's pointer\n   * @param nodeInfo - The parent node's NodeInfo\n   * @param childPointer - The child node's pointer\n   */\n  const propagateChildScopes = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer: string,\n  ): void => {\n    if (!nodeInfo?.scopes) return;\n    const childInfo = graph.nodes.get(childPointer);\n    if (!childInfo?.scopes) return;\n    const changed = propagateScopesToNode(childInfo, nodeInfo);\n    if (changed) {\n      notifyAllDependents(pointer, nodeInfo, childPointer);\n    }\n  };\n\n  while (worklist.size > 0) {\n    const pointer = worklist.values().next().value!;\n    worklist.delete(pointer);\n\n    const nodeInfo = graph.nodes.get(pointer);\n    if (!nodeInfo) continue;\n\n    if (!nodeInfo.scopes) {\n      nodeInfo.scopes = new Set();\n    }\n\n    const node = nodeInfo.node as Record<string, unknown>;\n\n    // Propagate scopes from all child schema relationships (combinators, properties, etc.)\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!node || typeof node !== 'object' || !(keyword in node)) continue;\n      const value = node[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = 0; index < value.length; index++) {\n          const childPointer = `${pointer}/${keyword}/${index}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        for (const key of Object.keys(value)) {\n          const childPointer = `${pointer}/${keyword}/${key}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        const childPointer = `${pointer}/${keyword}`;\n        propagateChildScopes(pointer, nodeInfo, childPointer);\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = 0; index < value.length; index++) {\n            const childPointer = `${pointer}/${keyword}/${index}`;\n            propagateChildScopes(pointer, nodeInfo, childPointer);\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          const childPointer = `${pointer}/${keyword}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      }\n    }\n\n    // Propagate scopes from $ref dependencies\n    const nodeDependencies = graph.nodeDependencies.get(pointer);\n    if (nodeDependencies) {\n      for (const depPointer of nodeDependencies) {\n        const depNode = graph.nodes.get(depPointer);\n        if (depNode?.scopes) {\n          const changed = propagateScopesToNode(depNode, nodeInfo);\n          if (changed) {\n            notifyAllDependents(pointer, nodeInfo);\n          }\n        }\n      }\n    }\n\n    // Propagate scopes up the parent chain\n    if (nodeInfo.parentPointer) {\n      const parentInfo = graph.nodes.get(nodeInfo.parentPointer);\n      if (parentInfo) {\n        const changed = propagateScopesToNode(nodeInfo, parentInfo);\n        if (changed) {\n          notifyAllDependents(nodeInfo.parentPointer, parentInfo);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Propagates scopes from one node to another.\n * Adds any scopes from fromNodeInfo to toNodeInfo that are not already present.\n * Returns true if any scopes were added, false otherwise.\n *\n * @param fromNodeInfo - The node to propagate scopes from\n * @param toNodeInfo - The node to propagate scopes to\n * @returns boolean - Whether any scopes were added\n */\nconst propagateScopesToNode = (\n  fromNodeInfo: NodeInfo,\n  toNodeInfo: NodeInfo,\n): boolean => {\n  if (!fromNodeInfo.scopes) {\n    return false;\n  }\n\n  if (!toNodeInfo.scopes) {\n    toNodeInfo.scopes = new Set();\n  }\n\n  let changed = false;\n\n  for (const scope of fromNodeInfo.scopes) {\n    if (!toNodeInfo.scopes.has(scope)) {\n      toNodeInfo.scopes.add(scope);\n      changed = true;\n    }\n  }\n\n  return changed;\n};\n\n/**\n * Seeds each node in the graph with its local access scope(s) based on its own properties.\n * - 'read' if readOnly: true\n * - 'write' if writeOnly: true\n * - 'normal' if node is an object property\n *\n * Only non-array objects are considered for scope seeding.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const seedLocalScopes = (nodes: Graph['nodes']): void => {\n  for (const [pointer, nodeInfo] of nodes) {\n    const { node } = nodeInfo;\n\n    if (typeof node !== 'object' || node === null || node instanceof Array) {\n      continue;\n    }\n\n    if ('readOnly' in node && node.readOnly === true) {\n      nodeInfo.scopes = new Set(['read']);\n    } else if ('writeOnly' in node && node.writeOnly === true) {\n      nodeInfo.scopes = new Set(['write']);\n    } else if (pointer.match(/\\/properties\\/[^/]+$/)) {\n      nodeInfo.scopes = new Set(['normal']);\n    }\n  }\n};\n\n/**\n * Builds a graph of all nodes in an OpenAPI spec, indexed by normalized JSON Pointer,\n * and tracks all $ref dependencies and reverse dependencies between nodes.\n *\n * - All keys in the returned maps are normalized JSON Pointers (RFC 6901, always starting with '#').\n * - The `nodes` map allows fast lookup of any node and its parent/key context.\n * - The `dependencies` map records, for each node, the set of normalized pointers it references via $ref.\n * - The `reverseNodeDependencies` map records, for each node, the set of nodes that reference it via $ref.\n * - After construction, all nodes will have their local and propagated scopes annotated.\n *\n * @param root The root object (e.g., the OpenAPI spec)\n * @returns An object with:\n *   - nodes: Map from normalized JSON Pointer string to NodeInfo\n *   - dependencies: Map from normalized JSON Pointer string to Set of referenced normalized JSON Pointers\n *   - reverseNodeDependencies: Map from normalized JSON Pointer string to Set of referencing normalized JSON Pointers\n */\nexport const buildGraph = (\n  root: unknown,\n  logger: Logger,\n): {\n  graph: Graph;\n} => {\n  const eventBuildGraph = logger.timeEvent('build-graph');\n  const graph: Graph = {\n    nodeDependencies: new Map(),\n    nodes: new Map(),\n    reverseNodeDependencies: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  const walk = ({\n    key,\n    node,\n    parentPointer,\n    path,\n  }: NodeInfo & {\n    path: ReadonlyArray<string | number>;\n  }) => {\n    if (typeof node !== 'object' || node === null) {\n      return;\n    }\n\n    const pointer = pathToJsonPointer(path);\n\n    let deprecated: boolean | undefined;\n    let tags: Set<string> | undefined;\n\n    if (typeof node === 'object' && node !== null) {\n      // Check for deprecated property\n      if ('deprecated' in node && typeof node.deprecated === 'boolean') {\n        deprecated = Boolean(node.deprecated);\n      }\n      // If this node has a $ref, record the dependency\n      if ('$ref' in node && typeof node.$ref === 'string') {\n        const refPointer = normalizeJsonPointer(node.$ref);\n        if (!graph.nodeDependencies.has(pointer)) {\n          graph.nodeDependencies.set(pointer, new Set());\n        }\n        graph.nodeDependencies.get(pointer)!.add(refPointer);\n      }\n      // Check for tags property (should be an array of strings)\n      if ('tags' in node && node.tags instanceof Array) {\n        tags = new Set(node.tags.filter((tag) => typeof tag === 'string'));\n      }\n    }\n\n    graph.nodes.set(pointer, { deprecated, key, node, parentPointer, tags });\n\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          key: index,\n          node: item,\n          parentPointer: pointer,\n          path: [...path, index],\n        }),\n      );\n    } else {\n      for (const [childKey, value] of Object.entries(node)) {\n        walk({\n          key: childKey,\n          node: value,\n          parentPointer: pointer,\n          path: [...path, childKey],\n        });\n      }\n    }\n  };\n\n  walk({\n    key: null,\n    node: root,\n    parentPointer: null,\n    path: [],\n  });\n\n  const cache: Cache = {\n    parentToChildren: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const parent = nodeInfo.parentPointer;\n    if (!parent) continue;\n    if (!cache.parentToChildren.has(parent)) {\n      cache.parentToChildren.set(parent, []);\n    }\n    cache.parentToChildren.get(parent)!.push(pointer);\n  }\n\n  for (const [pointerFrom, pointers] of graph.nodeDependencies) {\n    for (const pointerTo of pointers) {\n      if (!graph.reverseNodeDependencies.has(pointerTo)) {\n        graph.reverseNodeDependencies.set(pointerTo, new Set());\n      }\n      graph.reverseNodeDependencies.get(pointerTo)!.add(pointerFrom);\n    }\n  }\n\n  seedLocalScopes(graph.nodes);\n  propagateScopes(graph);\n  annotateChildScopes(graph.nodes);\n\n  for (const pointer of graph.nodes.keys()) {\n    const result = collectPointerDependencies({\n      cache,\n      graph,\n      pointer,\n      visited: new Set(),\n    });\n    graph.transitiveDependencies.set(pointer, result.transitiveDependencies);\n    graph.subtreeDependencies.set(pointer, result.subtreeDependencies);\n  }\n\n  eventBuildGraph.timeEnd();\n\n  // functions creating data for debug scripts located in `dev/`\n  // const { maxChildren, maxDepth, totalNodes } = debugTools.graph.analyzeStructure(graph);\n  // const nodesForViz = debugTools.graph.exportForVisualization(graph);\n  // fs.writeFileSync('dev/graph.json', JSON.stringify(nodesForViz, null, 2));\n\n  return { graph };\n};\n","import type { Graph } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport deepEqual from '../utils/deepEqual';\nimport { buildGraph, type Scope } from '../utils/graph';\nimport { buildName } from '../utils/name';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport {\n  getSchemasObject,\n  hasComponentsSchemasObject,\n  hasDefinitionsObject,\n} from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype OriginalSchemas = Record<string, unknown>;\n\ntype SplitSchemas = {\n  /** Key is the original schema pointer. */\n  mapping: Record<\n    string,\n    {\n      read?: string;\n      write?: string;\n    }\n  >;\n  /** splitPointer -> originalPointer */\n  reverseMapping: Record<string, string>;\n  /** name -> schema object */\n  schemas: Record<string, unknown>;\n};\n\ntype ReadWriteConfig = Config['parser']['transforms']['readWrite'];\n\nconst schemaKeys = new Set([\n  'additionalProperties',\n  'allOf',\n  'anyOf',\n  'items',\n  'not',\n  'oneOf',\n  'patternProperties',\n  'properties',\n  'schema',\n]);\n\nconst getComponentContext = (\n  path: ReadonlyArray<string | number>,\n): Scope | undefined => {\n  // OpenAPI 3.x: #/components/{type}/{name}\n  if (path.length === 3 && path[0] === 'components') {\n    const type = path[1];\n    if (type === 'parameters') return 'write';\n    if (type === 'requestBodies') return 'write';\n    if (type === 'responses') return 'read';\n    if (type === 'headers') return 'read';\n  }\n  // OpenAPI 2.x: #/parameters/{name}, #/responses/{name}\n  if (path.length === 2) {\n    const type = path[0];\n    if (type === 'parameters') return 'write';\n    if (type === 'responses') return 'read';\n  }\n  return;\n};\n\n/**\n * Capture the original schema objects by pointer before splitting.\n * This is used to safely remove only the true originals after splitting,\n * even if names are swapped or overwritten by split variants.\n */\nconst captureOriginalSchemas = (\n  spec: unknown,\n  logger: Logger,\n): OriginalSchemas => {\n  const event = logger.timeEvent('capture-original-schemas');\n  const originals: OriginalSchemas = {};\n  if (hasComponentsSchemasObject(spec)) {\n    for (const [name, obj] of Object.entries(\n      (spec as any).components.schemas,\n    )) {\n      originals[`#/components/schemas/${name}`] = obj;\n    }\n  } else if (hasDefinitionsObject(spec)) {\n    for (const [name, obj] of Object.entries((spec as any).definitions)) {\n      originals[`#/definitions/${name}`] = obj;\n    }\n  }\n  event.timeEnd();\n  return originals;\n};\n\n/**\n * Inserts split schemas into the spec at the correct location (OpenAPI 3.x or 2.0).\n * This function is robust to spec version and will assign all split schemas\n * to either components.schemas (OAS3) or definitions (OAS2).\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split schemas (from splitSchemas)\n */\nconst insertSplitSchemasIntoSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'schemas'>;\n}) => {\n  const event = logger.timeEvent('insert-split-schemas-into-spec');\n  if (hasComponentsSchemasObject(spec)) {\n    Object.assign((spec as any).components.schemas, split.schemas);\n  } else if (hasDefinitionsObject(spec)) {\n    Object.assign((spec as any).definitions, split.schemas);\n  }\n  event.timeEnd();\n};\n\n/**\n * Prunes a schema by removing all child schemas (in any structural keyword)\n * that are marked with the given scope (readOnly/writeOnly), or that are $ref to a schema\n * that is exclusively the excluded scope (according to the graph).\n *\n * Uses childSchemaRelationships for parity with graph traversal.\n * Returns true if the schema itself should be removed from its parent.\n *\n * @param graph - The Graph containing all nodes and their scopes\n * @param schema - The schema object to prune\n * @param scope - The scope to exclude ('readOnly' or 'writeOnly')\n * @returns boolean - Whether the schema should be removed from its parent\n */\nconst pruneSchemaByScope = (\n  graph: Graph,\n  schema: unknown,\n  scope: 'readOnly' | 'writeOnly',\n): boolean => {\n  if (schema && typeof schema === 'object') {\n    // Handle $ref schemas\n    if ('$ref' in schema && typeof schema.$ref === 'string') {\n      const nodeInfo = graph.nodes.get(schema.$ref);\n      if (nodeInfo?.scopes) {\n        // Only remove $ref if the referenced schema is *exclusively* the excluded scope.\n        // This ensures 'normal' or multi-scope schemas are always kept.\n        if (\n          (scope === 'writeOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('write')) ||\n          (scope === 'readOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('read'))\n        ) {\n          delete (schema as Record<string, unknown>)['$ref'];\n          // If the schema is now empty, remove it\n          if (\n            !childSchemaRelationships.some(([keyword]) => keyword in schema)\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    // Recursively prune all child schemas according to childSchemaRelationships\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!(keyword in schema)) {\n        continue;\n      }\n      const value = (schema as Record<string, unknown>)[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = value.length - 1; index >= 0; index--) {\n          const item = value[index];\n          if (\n            item &&\n            typeof item === 'object' &&\n            (item as Record<string, unknown>)[scope] === true\n          ) {\n            value.splice(index, 1);\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, item, scope);\n            if (shouldRemove) value.splice(index, 1);\n          }\n        }\n        if (!value.length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        const objMap = value as Record<string, unknown>;\n        // Track removed properties for object schemas to update required array\n        const removedProperties = new Set<string>();\n\n        for (const key of Object.keys(objMap)) {\n          const prop = objMap[key];\n          if (\n            prop &&\n            typeof prop === 'object' &&\n            (prop as Record<string, unknown>)[scope] === true\n          ) {\n            delete objMap[key];\n            // Track removed properties for object schemas\n            if (keyword === 'properties') {\n              removedProperties.add(key);\n            }\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, prop, scope);\n            if (shouldRemove) {\n              delete objMap[key];\n              // Track removed properties for object schemas\n              if (keyword === 'properties') {\n                removedProperties.add(key);\n              }\n            }\n          }\n        }\n\n        // Update required array if properties were removed\n        if (\n          removedProperties.size > 0 &&\n          keyword === 'properties' &&\n          'required' in schema &&\n          Array.isArray((schema as Record<string, unknown>).required)\n        ) {\n          const required = (schema as Record<string, unknown>)\n            .required as string[];\n          const filteredRequired = required.filter(\n            (prop) => !removedProperties.has(prop),\n          );\n\n          if (!filteredRequired.length) {\n            delete (schema as Record<string, unknown>).required;\n          } else {\n            (schema as Record<string, unknown>).required = filteredRequired;\n          }\n        }\n\n        if (!Object.keys(objMap).length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        if ((value as Record<string, unknown>)[scope] === true) {\n          delete (schema as Record<string, unknown>)[keyword];\n        } else {\n          const shouldRemove = pruneSchemaByScope(graph, value, scope);\n          if (shouldRemove) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        }\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = value.length - 1; index >= 0; index--) {\n            const item = value[index];\n            if (\n              item &&\n              typeof item === 'object' &&\n              (item as Record<string, unknown>)[scope] === true\n            ) {\n              value.splice(index, 1);\n            } else {\n              const shouldRemove = pruneSchemaByScope(graph, item, scope);\n              if (shouldRemove) value.splice(index, 1);\n            }\n          }\n          if (!value.length) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          if ((value as Record<string, unknown>)[scope] === true) {\n            delete (schema as Record<string, unknown>)[keyword];\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, value, scope);\n            if (shouldRemove) {\n              delete (schema as Record<string, unknown>)[keyword];\n            }\n          }\n        }\n      }\n    }\n    // After all removals, if this is type: object and has no structural fields, remove it\n    if (\n      (schema as Record<string, unknown>).type === 'object' &&\n      !childSchemaRelationships.some(([keyword]) => keyword in schema)\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Remove only the true original schemas that were split, by object identity.\n * This is robust to swaps, overwrites, and name collisions.\n *\n * @param originalSchemas - Map of original pointers to their schema objects (captured before splitting)\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nconst removeOriginalSplitSchemas = ({\n  logger,\n  originalSchemas,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  originalSchemas: OriginalSchemas;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'mapping'>;\n}) => {\n  const event = logger.timeEvent('remove-original-split-schemas');\n  const schemasObj = getSchemasObject(spec);\n\n  for (const originalPointer of Object.keys(split.mapping)) {\n    const path = jsonPointerToPath(originalPointer);\n    const name = path[path.length - 1]!;\n    if (\n      typeof name === 'string' &&\n      schemasObj &&\n      Object.prototype.hasOwnProperty.call(schemasObj, name) &&\n      schemasObj[name] === originalSchemas[originalPointer]\n    ) {\n      delete schemasObj[name];\n    }\n  }\n  event.timeEnd();\n};\n\n/**\n * Splits schemas with both 'read' and 'write' scopes into read/write variants.\n * Returns the new schemas and a mapping from original pointer to new variant pointers.\n *\n * @param config - The readWrite transform config\n * @param graph - The Graph containing all nodes and their scopes\n * @param spec - The OpenAPI spec object\n * @returns SplitSchemas - The split schemas and pointer mappings\n */\nexport const splitSchemas = ({\n  config,\n  graph,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  graph: Graph;\n  logger: Logger;\n  spec: unknown;\n}): SplitSchemas => {\n  const event = logger.timeEvent('split-schemas');\n  const existingNames = new Set<string>();\n  const split: SplitSchemas = {\n    mapping: {},\n    reverseMapping: {},\n    schemas: {},\n  };\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  const schemasNamespaceSegments =\n    schemasPointerNamespace.split('/').length - 1;\n\n  /**\n   * Extracts the schema name from pointer, but only if it's a top-level schema\n   * pointer. Returns an empty string if it's a nested pointer.\n   * @param pointer\n   * @returns Schema's base name.\n   */\n  const pointerToSchema = (pointer: string): string => {\n    if (pointer.startsWith(schemasPointerNamespace)) {\n      const path = jsonPointerToPath(pointer);\n      if (path.length === schemasNamespaceSegments) {\n        return path[schemasNamespaceSegments - 1] || '';\n      }\n    }\n    return '';\n  };\n\n  // Collect all existing schema names\n  for (const pointer of graph.nodes.keys()) {\n    const name = pointerToSchema(pointer);\n    if (name) existingNames.add(name);\n  }\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const name = pointerToSchema(pointer);\n    // Only split top-level schemas, with either read-only or write-only scopes (or both).\n    if (\n      !name ||\n      !(nodeInfo.scopes?.has('read') || nodeInfo.scopes?.has('write')) ||\n      !nodeInfo.scopes?.has('normal')\n    ) {\n      continue;\n    }\n\n    // read variant\n    const readSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, readSchema, 'writeOnly');\n    const readBase = buildName({\n      config: config.responses,\n      name,\n    });\n    const readName =\n      readBase === name\n        ? readBase\n        : getUniqueComponentName({\n            base: readBase,\n            components: existingNames,\n          });\n    existingNames.add(readName);\n    split.schemas[readName] = readSchema;\n    const readPointer = `${schemasPointerNamespace}${readName}`;\n\n    // write variant\n    const writeSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, writeSchema, 'readOnly');\n\n    // Check if this schema (or any of its descendants) references any schema that\n    // will need read/write variants. This is determined by checking transitive\n    // dependencies for schemas with both 'normal' and ('read' or 'write') scopes.\n    const transitiveDeps =\n      graph.transitiveDependencies.get(pointer) || new Set();\n    const referencesReadWriteSchemas = Array.from(transitiveDeps).some(\n      (depPointer) => {\n        const depNodeInfo = graph.nodes.get(depPointer);\n        return (\n          depNodeInfo?.scopes?.has('normal') &&\n          (depNodeInfo.scopes.has('read') || depNodeInfo.scopes.has('write'))\n        );\n      },\n    );\n\n    // If pruning did not change anything (both variants equal and equal to original),\n    // and the schema doesn't reference any schemas that will have read/write variants,\n    // skip splitting and keep the original single schema.\n    if (\n      !referencesReadWriteSchemas &&\n      deepEqual(readSchema, writeSchema) &&\n      deepEqual(readSchema, nodeInfo.node)\n    ) {\n      continue;\n    }\n    const writeBase = buildName({\n      config: config.requests,\n      name,\n    });\n    const writeName =\n      writeBase === name && writeBase !== readName\n        ? writeBase\n        : getUniqueComponentName({\n            base: writeBase,\n            components: existingNames,\n          });\n    existingNames.add(writeName);\n    split.schemas[writeName] = writeSchema;\n    const writePointer = `${schemasPointerNamespace}${writeName}`;\n\n    split.mapping[pointer] = {\n      read: readPointer,\n      write: writePointer,\n    };\n    split.reverseMapping[readPointer] = pointer;\n    split.reverseMapping[writePointer] = pointer;\n  }\n\n  event.timeEnd();\n  return split;\n};\n\ntype WalkArgs = {\n  context: Scope | null;\n  currentPointer: string | null;\n  inSchema: boolean;\n  node: unknown;\n  path: ReadonlyArray<string | number>;\n  visited?: Set<string>;\n};\n\n/**\n * Recursively updates $ref fields in the spec to point to the correct read/write variant\n * according to the current context (read/write), using the split mapping.\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nexport const updateRefsInSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Omit<SplitSchemas, 'schemas'>;\n}): void => {\n  const event = logger.timeEvent('update-refs-in-spec');\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  const walk = ({\n    context,\n    currentPointer,\n    inSchema,\n    node,\n    path,\n    visited = new Set(),\n  }: WalkArgs): void => {\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          context,\n          currentPointer,\n          inSchema,\n          node: item,\n          path: [...path, index],\n          visited,\n        }),\n      );\n    } else if (node && typeof node === 'object') {\n      // Detect if we're entering a split schema variant\n      let nextPointer = currentPointer;\n      let nextContext = context;\n      if (isPathRootSchema(path)) {\n        // Use the last path segment instead of a fixed index (path[2]) because\n        // path depth varies across OAS2/OAS3 and contexts; fixed indexing is brittle.\n        const nameSegment = path[path.length - 1] as string;\n        nextPointer = `${schemasPointerNamespace}${nameSegment}`;\n        const originalPointer = split.reverseMapping[nextPointer];\n        if (originalPointer) {\n          const mapping = split.mapping[originalPointer];\n          if (mapping?.read === nextPointer) {\n            nextContext = 'read';\n          } else if (mapping?.write === nextPointer) {\n            nextContext = 'write';\n          }\n        }\n        // For schemas that are not split variants, keep the inherited context.\n        // This ensures that $refs inside these schemas are resolved based on\n        // where the schema is actually used (requestBody vs responses), not\n        // based on the schema's own scopes which track readOnly/writeOnly fields.\n      }\n\n      const compContext = getComponentContext(path);\n      if (compContext !== undefined) {\n        // For each component, walk with the correct context\n        for (const key in node) {\n          if (!Object.prototype.hasOwnProperty.call(node, key)) {\n            continue;\n          }\n          walk({\n            context: compContext,\n            currentPointer: nextPointer,\n            inSchema: false,\n            node: (node as Record<string, unknown>)[key],\n            path: [...path, key],\n            visited,\n          });\n        }\n        return;\n      }\n\n      for (const key in node) {\n        if (!Object.prototype.hasOwnProperty.call(node, key)) {\n          continue;\n        }\n        const value = (node as Record<string, unknown>)[key];\n\n        // Only treat context switches at the OpenAPI structure level (not inside schemas)\n        if (!inSchema) {\n          if (key === 'requestBody') {\n            walk({\n              context: 'write',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'responses') {\n            walk({\n              context: 'read',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'parameters' && Array.isArray(value)) {\n            value.forEach((param, index) => {\n              if (param && typeof param === 'object' && 'schema' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: true,\n                  node: param.schema,\n                  path: [...path, key, index, 'schema'],\n                  visited,\n                });\n              }\n              // Also handle content (OpenAPI 3.x)\n              if (param && typeof param === 'object' && 'content' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: false,\n                  node: param.content,\n                  path: [...path, key, index, 'content'],\n                  visited,\n                });\n              }\n            });\n            continue;\n          }\n          // OpenAPI 3.x: headers in responses\n          if (\n            key === 'headers' &&\n            typeof value === 'object' &&\n            value !== null\n          ) {\n            for (const headerKey in value) {\n              if (!Object.prototype.hasOwnProperty.call(value, headerKey)) {\n                continue;\n              }\n              walk({\n                context: 'read',\n                currentPointer: nextPointer,\n                inSchema: false,\n                node: (value as Record<string, unknown>)[headerKey],\n                path: [...path, key, headerKey],\n                visited,\n              });\n            }\n            continue;\n          }\n        }\n\n        // Entering a schema context\n        if (schemaKeys.has(key)) {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema: true,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        } else if (key === '$ref' && typeof value === 'string') {\n          // Prefer exact match first\n          const map = split.mapping[value];\n          if (map) {\n            if (nextContext === 'read' && map.read) {\n              (node as Record<string, unknown>)[key] = map.read;\n            } else if (nextContext === 'write' && map.write) {\n              (node as Record<string, unknown>)[key] = map.write;\n            } else if (!nextContext && map.read) {\n              // For schemas with no context (unused in operations), default to read variant\n              // This ensures $refs in unused schemas don't point to removed originals\n              (node as Record<string, unknown>)[key] = map.read;\n            }\n          }\n        } else {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        }\n      }\n    }\n  };\n  walk({\n    context: null,\n    currentPointer: null,\n    inSchema: false,\n    node: spec,\n    path: [],\n  });\n  event.timeEnd();\n};\n\n/**\n * Orchestrates the full read/write transform:\n * - Captures original schemas\n * - Splits schemas into read/write variants\n * - Inserts split schemas into the spec\n * - Updates $refs throughout the spec\n * - Removes original schemas that were split\n *\n * @param config - The readWrite transform config\n * @param spec - The OpenAPI spec object\n */\nexport const readWriteTransform = ({\n  config,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  logger: Logger;\n  spec: unknown;\n}) => {\n  const { graph } = buildGraph(spec, logger);\n  const originalSchemas = captureOriginalSchemas(spec, logger);\n  const split = splitSchemas({ config, graph, logger, spec });\n  insertSplitSchemasIntoSpec({ logger, spec, split });\n  updateRefsInSpec({ logger, spec, split });\n  removeOriginalSplitSchemas({ logger, originalSchemas, spec, split });\n};\n","import type { Context } from '~/ir/context';\n\nimport { enumsTransform } from './enums';\nimport { propertiesRequiredByDefaultTransform } from './propertiesRequiredByDefault';\nimport { readWriteTransform } from './readWrite';\n\nexport const transformOpenApiSpec = ({ context }: { context: Context }) => {\n  const { logger } = context;\n  const eventTransformOpenApiSpec = logger.timeEvent('transform-openapi-spec');\n  if (context.config.parser.transforms.enums.enabled) {\n    enumsTransform({\n      config: context.config.parser.transforms.enums,\n      spec: context.spec,\n    });\n  }\n\n  if (context.config.parser.transforms.propertiesRequiredByDefault) {\n    propertiesRequiredByDefaultTransform({ spec: context.spec });\n  }\n\n  if (context.config.parser.transforms.readWrite.enabled) {\n    readWriteTransform({\n      config: context.config.parser.transforms.readWrite,\n      logger,\n      spec: context.spec,\n    });\n  }\n  eventTransformOpenApiSpec.timeEnd();\n};\n","import type { IR } from '~/ir/types';\n\nexport const mergeParametersObjects = ({\n  source,\n  target,\n}: {\n  source: IR.ParametersObject | undefined;\n  target: IR.ParametersObject | undefined;\n}): IR.ParametersObject | undefined => {\n  const result = { ...target };\n\n  if (source) {\n    if (source.cookie) {\n      if (result.cookie) {\n        result.cookie = {\n          ...result.cookie,\n          ...source.cookie,\n        };\n      } else {\n        result.cookie = source.cookie;\n      }\n    }\n\n    if (source.header) {\n      if (result.header) {\n        result.header = {\n          ...result.header,\n          ...source.header,\n        };\n      } else {\n        result.header = source.header;\n      }\n    }\n\n    if (source.path) {\n      if (result.path) {\n        result.path = {\n          ...result.path,\n          ...source.path,\n        };\n      } else {\n        result.path = source.path;\n      }\n    }\n\n    if (source.query) {\n      if (result.query) {\n        result.query = {\n          ...result.query,\n          ...source.query,\n        };\n      } else {\n        result.query = source.query;\n      }\n    }\n  }\n\n  if (!Object.keys(result).length) {\n    return;\n  }\n\n  return result;\n};\n","import colors from 'ansi-colors';\n\nimport type { Context } from '~/ir/context';\n\nexport interface ValidatorIssue {\n  /**\n   * Machine-readable issue code\n   *\n   * @example\n   * 'invalid_type'\n   */\n  code: 'duplicate_key' | 'invalid_type' | 'missing_required_field';\n  /**\n   * Optional additional data.\n   *\n   * @example\n   * 'expectedType'\n   */\n  context?: Record<string, any>;\n  /**\n   * Human-readable issue summary.\n   */\n  message: string;\n  /**\n   * JSONPath-like array to issue location.\n   */\n  path: ReadonlyArray<string | number>;\n  /**\n   * Error severity.\n   */\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidatorResult {\n  issues: ReadonlyArray<ValidatorIssue>;\n  valid: boolean;\n}\n\nconst isSimpleKey = (key: string) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(key);\n\nconst formatPath = (path: ReadonlyArray<string | number>): string =>\n  path\n    .map((segment, i) => {\n      if (typeof segment === 'number') {\n        return `[${segment}]`;\n      }\n\n      if (i === 0) {\n        // first segment no dot or brackets\n        return segment;\n      }\n\n      return isSimpleKey(segment)\n        ? `.${segment}`\n        : `['${segment.replace(/\"/g, \"\\\\'\")}']`;\n    })\n    .join('');\n\nconst formatValidatorIssue = (issue: ValidatorIssue): string => {\n  const pathStr = formatPath(issue.path);\n  const level =\n    issue.severity === 'error' ? colors.bold.red : colors.bold.yellow;\n\n  const highlightedMessage = issue.message.replace(/`([^`]+)`/g, (_, code) =>\n    colors.yellow(`\\`${code}\\``),\n  );\n\n  return `${level(`[${issue.severity.toUpperCase()}]`)} ${colors.cyan(pathStr)}: ${highlightedMessage}`;\n};\n\nconst shouldPrint = ({\n  context,\n  issue,\n}: {\n  context: Context;\n  issue: ValidatorIssue;\n}) => {\n  if (context.config.logs.level === 'silent') {\n    return false;\n  }\n\n  if (issue.severity === 'error') {\n    return context.config.logs.level !== 'warn';\n  }\n\n  return true;\n};\n\nexport const handleValidatorResult = ({\n  context,\n  result,\n}: {\n  context: Context;\n  result: ValidatorResult;\n}) => {\n  for (const issue of result.issues) {\n    if (shouldPrint({ context, issue })) {\n      console.log(formatValidatorIssue(issue));\n    }\n  }\n\n  if (!result.valid) {\n    process.exit(1);\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n} from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  preserveOrder,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV2_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.definitions) {\n    const filtered: typeof spec.definitions = {};\n\n    if (preserveOrder) {\n      for (const [name, source] of Object.entries(spec.definitions)) {\n        if (schemas.has(addNamespace('schema', name))) {\n          filtered[name] = source;\n        }\n      }\n    } else {\n      for (const key of schemas) {\n        const { name } = removeNamespace(key);\n        const source = spec.definitions[name];\n        if (source) {\n          filtered[name] = source;\n        }\n      }\n    }\n\n    spec.definitions = filtered;\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        // @ts-expect-error\n        const operation = pathItem[method] as OperationObject;\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          // @ts-expect-error\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","const fileLikeRegExp =\n  /^(application\\/(pdf|rtf|msword|vnd\\.(ms-|openxmlformats-officedocument\\.)|zip|x-(7z|tar|rar|zip|iso)|octet-stream|gzip|x-msdownload|json\\+download|xml|x-yaml|x-7z-compressed|x-tar)|text\\/(yaml|css|javascript)|audio\\/(mpeg|wav)|video\\/(mp4|x-matroska)|image\\/(vnd\\.adobe\\.photoshop|svg\\+xml))(; ?charset=[^;]+)?$/i;\nconst jsonMimeRegExp = /^application\\/(.*\\+)?json(;.*)?$/i;\nconst multipartFormDataMimeRegExp = /^multipart\\/form-data(;.*)?$/i;\nconst textMimeRegExp = /^text\\/[a-z0-9.+-]+(;.*)?$/i;\nconst xWwwFormUrlEncodedMimeRegExp =\n  /^application\\/x-www-form-urlencoded(;.*)?$/i;\nconst octetStreamMimeRegExp = /^application\\/octet-stream(;.*)?$/i;\n\nexport type IRMediaType =\n  | 'form-data'\n  | 'json'\n  | 'text'\n  | 'url-search-params'\n  | 'octet-stream';\n\nexport const isMediaTypeFileLike = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): boolean => {\n  fileLikeRegExp.lastIndex = 0;\n  return fileLikeRegExp.test(mediaType);\n};\n\nexport const mediaTypeToIrMediaType = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): IRMediaType | undefined => {\n  jsonMimeRegExp.lastIndex = 0;\n  if (jsonMimeRegExp.test(mediaType)) {\n    return 'json';\n  }\n\n  multipartFormDataMimeRegExp.lastIndex = 0;\n  if (multipartFormDataMimeRegExp.test(mediaType)) {\n    return 'form-data';\n  }\n\n  textMimeRegExp.lastIndex = 0;\n  if (textMimeRegExp.test(mediaType)) {\n    return 'text';\n  }\n\n  xWwwFormUrlEncodedMimeRegExp.lastIndex = 0;\n  if (xWwwFormUrlEncodedMimeRegExp.test(mediaType)) {\n    return 'url-search-params';\n  }\n\n  octetStreamMimeRegExp.lastIndex = 0;\n  if (octetStreamMimeRegExp.test(mediaType)) {\n    return 'octet-stream';\n  }\n\n  return;\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  ReferenceObject,\n  ResponseObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  mimeTypes,\n  response,\n}: {\n  mimeTypes: ReadonlyArray<string> | undefined;\n  response: Pick<ResponseObject, 'schema'>;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType of mimeTypes ?? []) {\n    objects.push({\n      mediaType,\n      schema: response.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Config } from '~/types/config';\n\nimport type { IR } from './types';\n\nexport function getPaginationKeywordsRegExp(\n  pagination: Config['parser']['pagination'],\n): RegExp {\n  const pattern = `^(${pagination.keywords.join('|')})$`;\n  return new RegExp(pattern);\n}\n\nexport interface Pagination {\n  in: 'body' | 'cookie' | 'header' | 'path' | 'query';\n  name: string;\n  schema: IR.SchemaObject;\n}\n","import { refToName } from '~/utils/ref';\n\nexport const discriminatorValues = (\n  $ref: string,\n  mapping?: Record<string, string>,\n  shouldUseRefAsValue?: () => boolean,\n): ReadonlyArray<string> => {\n  const values: Array<string> = [];\n\n  for (const name in mapping) {\n    if (mapping[name] === $ref) {\n      values.push(name);\n    }\n  }\n\n  if (!values.length && (!shouldUseRefAsValue || shouldUseRefAsValue())) {\n    return [refToName($ref)];\n  }\n\n  return values;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray = schema.items.allOf;\n        if (ofArray && ofArray.length > 1 && !schema.items['x-nullable']) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(state.$ref);\n        const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n          (value) => ({\n            const: value,\n            type: 'string',\n          }),\n        );\n        const irDiscriminatorSchema: IR.SchemaObject = {\n          properties: {\n            [ref.discriminator]:\n              valueSchemas.length > 1\n                ? {\n                    items: valueSchemas,\n                    logicalOperator: 'or',\n                  }\n                : valueSchemas[0]!,\n          },\n          type: 'object',\n        };\n        if (ref.required?.includes(ref.discriminator)) {\n          irDiscriminatorSchema.required = [ref.discriminator];\n        }\n        schemaItems.push(irDiscriminatorSchema);\n      }\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema['x-nullable']) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema['x-nullable']) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/definitions/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  // rewrite definitions refs as the internal schema follows OpenAPI 3.x syntax\n  // and stores all definitions as reusable schemas\n  irSchema.$ref = irSchema.$ref.replace(\n    /#\\/definitions\\/([^/]+)/g,\n    '#/components/schemas/$1',\n  );\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (schema['x-nullable']) {\n    return parseNullableType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseOneType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, ReferenceObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema:\n    | ParameterObject\n    | SchemaObject\n    | ReferenceObject\n    | {\n        in: undefined;\n      };\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<ParameterObject | SchemaObject>(\n      schema.$ref ?? '',\n    );\n\n    if ('in' in ref && ref.in) {\n      const refSchema =\n        'schema' in ref\n          ? ref.schema\n          : {\n              ...ref,\n              in: undefined,\n            };\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  if ('in' in schema) {\n    if (!schema.in) {\n      return false;\n    }\n\n    const finalSchema =\n      'schema' in schema\n        ? schema.schema\n        : {\n            ...schema,\n            in: undefined,\n          };\n\n    return paginationField({\n      context,\n      name,\n      schema: finalSchema,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR, IRBodyObject } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ResponseObject,\n  SchemaObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {\n  requestBody?: OperationObject['parameters'];\n}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  let isRequestBodyRequired = false;\n  const requestBodyObject: IRBodyObject = {\n    mediaType: '',\n    schema: {\n      properties: {},\n      required: [],\n      type: 'object',\n    },\n  };\n  const requestBodyObjectRequired: Array<string> = [];\n\n  // Check if there are any body parameters (not formData) to determine default media type\n  const hasBodyParameter = operation.requestBody?.some((param) => {\n    const resolvedParam =\n      '$ref' in param ? context.resolveRef<ParameterObject>(param.$ref) : param;\n    return resolvedParam.in === 'body';\n  });\n\n  for (const requestBodyParameter of operation.requestBody ?? []) {\n    const requestBody =\n      '$ref' in requestBodyParameter\n        ? context.resolveRef<ParameterObject>(requestBodyParameter.$ref)\n        : requestBodyParameter;\n    const schema: SchemaObject =\n      requestBody.in === 'body'\n        ? requestBody.schema\n        : {\n            ...requestBody,\n            format: requestBody.type === 'file' ? 'binary' : requestBody.format,\n            required: undefined,\n            type: requestBody.type === 'file' ? 'string' : requestBody.type,\n          };\n\n    // Only default to JSON if we have body parameters and no consumes specified\n    // FormData parameters without consumes should not get a default media type\n    let mimeTypes = operation.consumes;\n    if (!mimeTypes && hasBodyParameter && requestBody.in === 'body') {\n      mimeTypes = ['application/json'];\n    }\n\n    const contents = mediaTypeObjects({\n      mimeTypes,\n      response: { schema },\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      const irSchema = schemaToIrSchema({\n        context,\n        schema:\n          '$ref' in requestBody\n            ? {\n                allOf: [\n                  {\n                    ...requestBody,\n                    $ref: requestBody.$ref as string,\n                    required: [],\n                    type: 'string',\n                  },\n                ],\n                description: requestBody.description,\n              }\n            : content.schema && '$ref' in content.schema\n              ? {\n                  allOf: [{ ...content.schema }],\n                  description: requestBody.description,\n                }\n              : {\n                  description: requestBody.description,\n                  ...content.schema,\n                },\n        state: undefined,\n      });\n\n      requestBodyObject.mediaType = content.mediaType;\n\n      if (requestBody.in === 'body') {\n        requestBodyObject.schema = irSchema;\n      } else {\n        requestBodyObject.schema.properties![requestBody.name] = irSchema;\n\n        if (requestBody.required) {\n          requestBodyObjectRequired.push(requestBody.name);\n        }\n      }\n\n      if (pagination) {\n        requestBodyObject.pagination = pagination;\n      }\n\n      if (content.type) {\n        requestBodyObject.type = content.type;\n      }\n    }\n\n    if (requestBody.required) {\n      isRequestBodyRequired = true;\n    }\n  }\n\n  if (requestBodyObject.mediaType) {\n    if (requestBodyObjectRequired.length) {\n      requestBodyObject.schema.required = requestBodyObjectRequired;\n    }\n\n    irOperation.body = requestBodyObject;\n\n    if (isRequestBodyRequired) {\n      irOperation.body.required = isRequestBodyRequired;\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({\n      // assume JSON by default\n      mimeTypes: operation.produces ? operation.produces : ['application/json'],\n      response: responseObject,\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        let irSecuritySchemeObject: IR.SecurityObject | undefined;\n\n        if (securitySchemeObject.type === 'apiKey') {\n          irSecuritySchemeObject = securitySchemeObject;\n        }\n\n        if (securitySchemeObject.type === 'basic') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            scheme: 'basic',\n            type: 'http',\n          };\n        }\n\n        if (securitySchemeObject.type === 'oauth2') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            flows: {},\n            type: 'oauth2',\n          };\n\n          switch (securitySchemeObject.flow) {\n            case 'accessCode':\n              irSecuritySchemeObject.flows.authorizationCode = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'application':\n              irSecuritySchemeObject.flows.clientCredentials = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'implicit':\n              irSecuritySchemeObject.flows.implicit = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n              };\n              break;\n            case 'password':\n              irSecuritySchemeObject.flows.password = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n          }\n        }\n\n        if (!irSecuritySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, irSecuritySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ntype Parameter = Exclude<ParameterObject, { in: 'body' }>;\n\n/**\n * Returns default parameter `explode` based on value of `collectionFormat`.\n */\nconst defaultExplode = (\n  collectionFormat: Parameter['collectionFormat'],\n): boolean => {\n  switch (collectionFormat) {\n    case 'multi':\n      return true;\n    case 'csv':\n    case 'pipes':\n    case 'ssv':\n    case 'tsv':\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: Parameter['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'query':\n    default:\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  operation,\n  parameters,\n}: {\n  context: Context;\n  operation: OperationObject;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    // push request body parameters into a separate field\n    if (parameter.in === 'body' || parameter.in === 'formData') {\n      // @ts-expect-error\n      if (!operation.requestBody) {\n        // @ts-expect-error\n        operation.requestBody = [];\n      }\n\n      // @ts-expect-error\n      operation.requestBody.push(parameter);\n      continue;\n    }\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: Parameter;\n}): IR.ParameterObject => {\n  const schema = parameter;\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [\n            {\n              ...schema,\n              $ref: schema.$ref as string,\n              required: Array.isArray(schema.required) ? schema.required : [],\n              type: schema.type as SchemaObject['type'],\n            },\n          ],\n          description: parameter.description,\n        }\n      : {\n          description: parameter.description,\n          ...schema,\n          required: Array.isArray(schema.required) ? schema.required : [],\n          type: schema.type as SchemaObject['type'],\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = defaultStyle(parameter.in);\n  const explode = defaultExplode(parameter.collectionFormat);\n  const allowReserved = false;\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in as IR.ParameterObject['location'],\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  let schemes: ReadonlyArray<string> = context.spec.schemes ?? [];\n  let host = context.spec.host ?? '';\n  const path = context.spec.basePath ?? '';\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n\n      if (!schemes.length) {\n        if (url.protocol) {\n          schemes = [url.protocol] as typeof schemes;\n        }\n      }\n\n      if (!host) {\n        host = `${url.host}${url.port ? `:${url.port}` : ''}`;\n      }\n    }\n  }\n\n  if (!schemes.length) {\n    schemes = [''];\n  }\n\n  const servers = schemes\n    .map((scheme) => `${scheme ? `${scheme}://` : ''}${host}${path}`)\n    .filter(Boolean);\n\n  if (servers.length) {\n    context.ir.servers = servers.map((url) => ({\n      url,\n    }));\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV2_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV2_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        if (method === 'trace') {\n          continue;\n        }\n\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\ntype PathKeys<T extends keyof PathsObject = keyof PathsObject> =\n  keyof T extends infer K ? (K extends `/${string}` ? K : never) : never;\n\nexport const parseV2_0_X = (context: Context<OpenApiV2_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  for (const name in context.spec.securityDefinitions) {\n    const securitySchemeObject = context.spec.securityDefinitions[name]!;\n    securitySchemesMap.set(name, securitySchemeObject);\n  }\n\n  if (context.spec.definitions) {\n    for (const name in context.spec.definitions) {\n      const $ref = `#/definitions/${name}`;\n      const schema = context.spec.definitions[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    if (path.startsWith('x-')) {\n      continue;\n    }\n\n    const pathItem = context.spec.paths[path as PathKeys]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const commonOperation: OperationObject = {\n      consumes: context.spec.consumes,\n      produces: context.spec.produces,\n      responses: {},\n      security: context.spec.security,\n    };\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        ...commonOperation,\n        parameters: parametersArrayToObject({\n          context,\n          operation: commonOperation,\n          parameters: finalPathItem.parameters,\n        }),\n      },\n      path: path as PathKeys,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.delete,\n          parameters: finalPathItem.delete.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.get,\n          parameters: finalPathItem.get.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.head,\n          parameters: finalPathItem.head.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.options,\n          parameters: finalPathItem.options.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.patch,\n          parameters: finalPathItem.patch.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.post,\n          parameters: finalPathItem.post.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.put,\n          parameters: finalPathItem.put.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters,\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  MediaTypeObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { ReferenceObject, SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray =\n          schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n        if (ofArray && ofArray.length > 1 && !schema.items.nullable) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      schemaProperties[name] = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if ('$ref' in compositionSchema) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(\n          state.$ref,\n          ref.discriminator.mapping,\n          // If the ref has oneOf, we only use the schema name as the value\n          // only if current schema is part of the oneOf. Else it is extending\n          // the ref schema\n          ref.oneOf\n            ? () => ref.oneOf!.some((o) => '$ref' in o && o.$ref === state.$ref)\n            : undefined,\n        );\n\n        if (values.length > 0) {\n          const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n            (value) => ({\n              const: value,\n              type: 'string',\n            }),\n          );\n          const irDiscriminatorSchema: IR.SchemaObject = {\n            properties: {\n              [ref.discriminator.propertyName]:\n                valueSchemas.length > 1\n                  ? {\n                      items: valueSchemas,\n                      logicalOperator: 'or',\n                    }\n                  : valueSchemas[0]!,\n            },\n            type: 'object',\n          };\n          if (ref.required?.includes(ref.discriminator.propertyName)) {\n            irDiscriminatorSchema.required = [ref.discriminator.propertyName];\n          }\n          schemaItems.push(irDiscriminatorSchema);\n        }\n      }\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema =\n              '$ref' in compositionSchema\n                ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n                : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema.nullable) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema.nullable) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: ReferenceObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  const irSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (!schema.nullable) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseNullableType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject | ReferenceObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if ('$ref' in schema) {\n    return parseRef({\n      context,\n      schema,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject | ReferenceObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  RequestBodyObject,\n} from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema: SchemaObject | ReferenceObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | ReferenceObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  PathItemObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema:\n            '$ref' in operation.requestBody\n              ? {\n                  allOf: [{ ...operation.requestBody }],\n                  description: requestBody.description,\n                }\n              : content.schema && '$ref' in content.schema\n                ? {\n                    allOf: [{ ...content.schema }],\n                    description: requestBody.description,\n                  }\n                : {\n                    description: requestBody.description,\n                    ...content.schema,\n                  },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [{ ...schema }],\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n        }\n      : {\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n          ...schema,\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_0_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\nexport const parseV3_0_X = (context: Context<OpenApiV3_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    const pathItem = context.spec.paths[path as keyof PathsObject]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    } = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as keyof PathsObject,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_1_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type { MediaTypeObject, SchemaObject } from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaTypes = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): ReadonlyArray<SchemaType<SchemaObject>> => {\n  if (typeof schema.type === 'string') {\n    return [schema.type];\n  }\n\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return ['object'];\n  }\n\n  return [];\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.const !== undefined) {\n    irSchema.const = schema.const;\n\n    // try to infer schema type\n    if (!schema.type) {\n      if (schema.const === null) {\n        irSchema.type = 'null';\n      } else {\n        switch (typeof schema.const) {\n          case 'bigint':\n          case 'number':\n            irSchema.type = 'number';\n            break;\n          case 'boolean':\n            irSchema.type = 'boolean';\n            break;\n          case 'string':\n            irSchema.type = 'string';\n            break;\n        }\n      }\n    }\n  }\n\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    irSchema.exclusiveMaximum = schema.exclusiveMaximum;\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    irSchema.exclusiveMinimum = schema.exclusiveMinimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (\n    (schema.prefixItems && schema.prefixItems.length) ||\n    (schema.maxItems && schema.maxItems === schema.minItems) ||\n    schema.const !== undefined\n  ) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const item of schema.prefixItems ?? []) {\n    const irItemSchema = schemaToIrSchema({\n      context,\n      schema: item,\n      state,\n    });\n    schemaItems.push(irItemSchema);\n  }\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      const ofArray =\n        schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n      if (\n        ofArray &&\n        ofArray.length > 1 &&\n        !getSchemaTypes({ schema: schema.items }).includes('null')\n      ) {\n        // bring composition up to avoid incorrectly nested arrays\n        irSchema = {\n          ...irSchema,\n          ...irItemsSchema,\n        };\n      } else {\n        schemaItems.push(irItemsSchema);\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNull = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  irSchema.type = 'null';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length) &&\n      (!schema.patternProperties ||\n        !Object.keys(schema.patternProperties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.patternProperties) {\n    const patternProperties: Record<string, IR.SchemaObject> = {};\n\n    for (const pattern in schema.patternProperties) {\n      const patternSchema = schema.patternProperties[pattern]!;\n      const irPatternSchema = schemaToIrSchema({\n        context,\n        schema: patternSchema,\n        state,\n      });\n      patternProperties[pattern] = irPatternSchema;\n    }\n\n    if (Object.keys(patternProperties).length) {\n      irSchema.patternProperties = patternProperties;\n    }\n  }\n\n  if (schema.propertyNames) {\n    irSchema.propertyNames = schemaToIrSchema({\n      context,\n      schema: schema.propertyNames,\n      state,\n    });\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(\n          state.$ref,\n          ref.discriminator.mapping,\n          // If the ref has oneOf, we only use the schema name as the value\n          // only if current schema is part of the oneOf. Else it is extending\n          // the ref schema\n          ref.oneOf\n            ? () => ref.oneOf!.some((o) => '$ref' in o && o.$ref === state.$ref)\n            : undefined,\n        );\n        if (values.length > 0) {\n          const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n            (value) => ({\n              const: value,\n              type: 'string',\n            }),\n          );\n          const irDiscriminatorSchema: IR.SchemaObject = {\n            properties: {\n              [ref.discriminator.propertyName]:\n                valueSchemas.length > 1\n                  ? {\n                      items: valueSchemas,\n                      logicalOperator: 'or',\n                    }\n                  : valueSchemas[0]!,\n            },\n            type: 'object',\n          };\n          if (ref.required?.includes(ref.discriminator.propertyName)) {\n            irDiscriminatorSchema.required = [ref.discriminator.propertyName];\n          }\n          schemaItems.push(irDiscriminatorSchema);\n        }\n      }\n    }\n  }\n\n  if (schemaTypes.includes('object')) {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaTypes({ schema: finalCompositionSchema }).includes(\n                'object',\n              )\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('null')) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // type must contain null\n      if (schemaTypes.includes('null')) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        const: enumValue,\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        type: enumType,\n      },\n      state,\n    });\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const irRefSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irRefSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  schemaItems.push(irRefSchema);\n\n  if (schema.type && typeof schema.type !== 'string') {\n    if (schema.type.includes('null')) {\n      schemaItems.push({ type: 'null' });\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'null':\n      return parseNull({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({ context, irSchema, schema });\n  }\n};\n\nconst parseManyTypes = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: ReadonlyArray<SchemaType<SchemaObject>>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (schema.type.includes('null') && typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const type of schema.type) {\n    if (type === 'null') {\n      schemaItems.push({ type: 'null' });\n    } else {\n      const irTypeSchema = parseOneType({\n        context,\n        irSchema: { ...typeIrSchema },\n        schema: {\n          ...schema,\n          type,\n        },\n        state,\n      });\n\n      schemaItems.push(irTypeSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaTypes = getSchemaTypes({ schema });\n\n  if (schemaTypes.length === 1) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type: schemaTypes[0]!,\n      },\n      state,\n    });\n  }\n\n  return parseManyTypes({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type: schemaTypes,\n    },\n    state,\n  });\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, RequestBodyObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaTypes } from './schema';\n\nconst isPaginationType = (\n  schemaTypes: ReadonlyArray<SchemaType<SchemaObject>>,\n): boolean =>\n  schemaTypes.includes('boolean') ||\n  schemaTypes.includes('integer') ||\n  schemaTypes.includes('number') ||\n  schemaTypes.includes('string');\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema: SchemaObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if (schema.$ref) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        // TODO: resolve deeper references\n        const schemaTypes = getSchemaTypes({ schema: property });\n\n        if (!schemaTypes.length) {\n          const compositionSchemas = property.anyOf ?? property.oneOf;\n          const nonNullCompositionSchemas = (compositionSchemas ?? []).filter(\n            (schema) => schema.type !== 'null',\n          );\n          if (nonNullCompositionSchemas.length === 1) {\n            const schemaTypes = getSchemaTypes({\n              schema: nonNullCompositionSchemas[0]!,\n            });\n            if (isPaginationType(schemaTypes)) {\n              return name;\n            }\n          }\n        }\n\n        if (isPaginationType(schemaTypes)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport type { httpMethods } from '~/openApi/shared/utils/operation';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema: {\n          description: requestBody.description,\n          ...content.schema,\n        },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: requestBody.description,\n            ...('$ref' in operation.requestBody\n              ? operation.requestBody\n              : content.schema),\n          },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nconst parseOperationObject = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  const parsed = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n\n  return { parsed };\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  path,\n  ...options\n}: {\n  context: Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path,\n    ...options,\n  });\n\n  context.ir.paths[path][method] = parsed;\n};\n\nexport const parseWebhookOperation = ({\n  context,\n  key,\n  method,\n  ...options\n}: {\n  context: Context;\n  key: string;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.webhooks) {\n    context.ir.webhooks = {};\n  }\n\n  if (!context.ir.webhooks[key]) {\n    context.ir.webhooks[key] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path: key as `/${string}`,\n    ...options,\n  });\n\n  context.ir.webhooks[key][method] = parsed;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject = {\n    deprecated: parameter.deprecated,\n    description: parameter.description,\n    ...schema,\n  };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_1_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\n\nimport type { OpenApiV3_1_X, PathItemObject } from '../types/spec';\nimport { parseWebhookOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\n\nexport const parseWebhooks = ({\n  context,\n  securitySchemesMap,\n}: Pick<Parameters<typeof parseWebhookOperation>[0], 'securitySchemesMap'> & {\n  context: Context<OpenApiV3_1_X>;\n}) => {\n  const state: Parameters<typeof parseWebhookOperation>[0]['state'] = {\n    ids: new Map(),\n  };\n\n  for (const key in context.spec.webhooks) {\n    const webhook = context.spec.webhooks[key]!;\n\n    const finalWebhook =\n      '$ref' in webhook\n        ? {\n            ...context.resolveRef<PathItemObject>(webhook.$ref!),\n            ...webhook,\n          }\n        : webhook;\n\n    const operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    > = {\n      context,\n      key,\n      operation: {\n        description: finalWebhook.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalWebhook.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalWebhook.servers,\n        summary: finalWebhook.summary,\n      },\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalWebhook.delete) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.get) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.head) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.options) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.patch) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.post) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.put) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.trace) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_1_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\nimport { parseWebhooks } from './webhook';\n\nexport const parseV3_1_X = (context: Context<OpenApiV3_1_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    const pathItem = context.spec.paths[path as keyof PathsObject]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as keyof PathsObject,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n\n  parseWebhooks({ context, securitySchemesMap });\n};\n","import { satisfies } from '~/config/utils/package';\nimport { Context } from '~/ir/context';\nimport { parseV2_0_X } from '~/openApi/2.0.x';\nimport { parseV3_0_X } from '~/openApi/3.0.x';\nimport { parseV3_1_X } from '~/openApi/3.1.x';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\n\n/**\n * @internal\n * Parse the resolved OpenAPI specification. This will populate and return\n * `context` with intermediate representation obtained from the parsed spec.\n */\nexport const parseOpenApiSpec = ({\n  config,\n  dependencies,\n  logger,\n  spec,\n}: {\n  config: Config;\n  dependencies: Record<string, string>;\n  logger: Logger;\n  spec: unknown;\n}): Context => {\n  const context = new Context({\n    config,\n    dependencies,\n    logger,\n    spec: spec as OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  });\n\n  if ('swagger' in context.spec) {\n    parseV2_0_X(context as Context<OpenApi.V2_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    parseV3_0_X(context as Context<OpenApi.V3_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.1.0')) {\n    parseV3_1_X(context as Context<OpenApi.V3_1_X>);\n    return context;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n"],"mappings":"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"}