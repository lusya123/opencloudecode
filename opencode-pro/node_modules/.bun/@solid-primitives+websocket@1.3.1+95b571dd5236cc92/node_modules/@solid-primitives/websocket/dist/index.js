import { onCleanup, createSignal } from "solid-js";
/**
 * opens a web socket connection with a queued send
 * ```ts
 * const ws = makeWS("ws://localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * onCleanup(() => ws.close());
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 *
 * It will not close the connection on cleanup. To do that, use `createWS`.
 */
export const makeWS = (url, protocols, sendQueue = []) => {
    const ws = new WebSocket(url, protocols);
    const _send = ws.send.bind(ws);
    ws.send = (msg) => (ws.readyState == 1 ? _send(msg) : sendQueue.push(msg));
    ws.addEventListener("open", () => {
        while (sendQueue.length)
            _send(sendQueue.shift());
    });
    return ws;
};
/**
 * opens a web socket connection with a queued send that closes on cleanup
 * ```ts
 * const ws = makeWS("ws://localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 */
export const createWS = (url, protocols) => {
    const ws = makeWS(url, protocols);
    onCleanup(() => ws.close());
    return ws;
};
/**
 * Returns a reactive state signal for the web socket's readyState:
 *
 * WebSocket.CONNECTING = 0
 * WebSocket.OPEN = 1
 * WebSocket.CLOSING = 2
 * WebSocket.CLOSED = 3
 *
 * ```ts
 * const ws = createWS('ws://localhost:5000');
 * const state = createWSState(ws);
 * const states = ["Connecting", "Open", "Closing", "Closed"] as const;
 * return <div>{states[state()]}</div>
 * ```
 */
export const createWSState = (ws) => {
    const [state, setState] = createSignal(ws.readyState);
    const _close = ws.close.bind(ws);
    ws.addEventListener("open", () => setState(1));
    ws.close = (...args) => {
        _close(...args);
        setState(2);
    };
    ws.addEventListener("close", () => setState(3));
    return state;
};
/**
 * Returns a WebSocket-like object that under the hood opens new connections on disconnect:
 * ```ts
 * const ws = makeReconnectingWS("ws:localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * onCleanup(() => ws.close());
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 *
 * It will not close the connection on cleanup. To do that, use `createReconnectingWS`.
 */
export const makeReconnectingWS = (url, protocols, options = {}) => {
    let retries = options.retries || Infinity;
    let ws;
    const queue = [];
    let events = [
        [
            "close",
            () => {
                retries-- > 0 && setTimeout(getWS, options.delay || 3000);
            },
        ],
    ];
    const getWS = () => {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (ws && ws.readyState < 2)
            ws.close();
        ws = Object.assign(makeWS(url, protocols, queue), {
            reconnect: getWS,
        });
        events.forEach(args => ws.addEventListener(...args));
    };
    getWS();
    const wws = {
        close: (...args) => {
            retries = 0;
            return ws.close(...args);
        },
        addEventListener: (...args) => {
            events.push(args);
            return ws.addEventListener(...args);
        },
        removeEventListener: (...args) => {
            events = events.filter(ev => args[0] !== ev[0] || args[1] !== ev[1]);
            return ws.removeEventListener(...args);
        },
        send: (msg) => {
            wws.send.before?.();
            return ws.send(msg);
        },
    };
    for (const name in ws)
        wws[name] == null &&
            Object.defineProperty(wws, name, {
                enumerable: true,
                get: () => typeof ws[name] === "function"
                    ? ws[name].bind(ws)
                    : ws[name],
            });
    return wws;
};
/**
 * Returns a WebSocket-like object that under the hood opens new connections on disconnect and closes on cleanup:
 * ```ts
 * const ws = makeReconnectingWS("ws:localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 */
export const createReconnectingWS = (url, protocols, options) => {
    const ws = makeReconnectingWS(url, protocols, options);
    onCleanup(() => ws.close());
    return ws;
};
/**
 * Wraps a reconnecting WebSocket to send a heartbeat to check the connection
 * ```ts
 * const ws = makeHeartbeatWS(createReconnectingWS('ws://localhost:5000'))
 * ```
 * Dispatches a close event to initiate the reconnection of the defunct web socket.
 */
export const makeHeartbeatWS = (ws, options = {}) => {
    let pingtimer;
    let pongtimer;
    const clearTimers = () => (clearTimeout(pingtimer), clearTimeout(pongtimer));
    ws.send.before = () => {
        clearTimers();
        pongtimer = setTimeout(ws.reconnect, options.wait || 1500);
    };
    const receiveMessage = () => {
        clearTimers();
        pingtimer = setTimeout(() => ws.send(options.message || "ping"), options.interval || 1000);
    };
    ws.addEventListener("close", clearTimers);
    ws.addEventListener("message", receiveMessage);
    ws.addEventListener("open", () => setTimeout(receiveMessage, options.interval || 1000));
    return ws;
};
