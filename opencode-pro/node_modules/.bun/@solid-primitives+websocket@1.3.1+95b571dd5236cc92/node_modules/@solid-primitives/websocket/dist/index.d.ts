import { type Accessor } from "solid-js";
export type WSMessage = string | ArrayBufferLike | ArrayBufferView | Blob;
/**
 * opens a web socket connection with a queued send
 * ```ts
 * const ws = makeWS("ws://localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * onCleanup(() => ws.close());
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 *
 * It will not close the connection on cleanup. To do that, use `createWS`.
 */
export declare const makeWS: (url: string, protocols?: string | string[], sendQueue?: WSMessage[]) => WebSocket;
/**
 * opens a web socket connection with a queued send that closes on cleanup
 * ```ts
 * const ws = makeWS("ws://localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 */
export declare const createWS: (url: string, protocols?: string | string[]) => WebSocket;
/**
 * Returns a reactive state signal for the web socket's readyState:
 *
 * WebSocket.CONNECTING = 0
 * WebSocket.OPEN = 1
 * WebSocket.CLOSING = 2
 * WebSocket.CLOSED = 3
 *
 * ```ts
 * const ws = createWS('ws://localhost:5000');
 * const state = createWSState(ws);
 * const states = ["Connecting", "Open", "Closing", "Closed"] as const;
 * return <div>{states[state()]}</div>
 * ```
 */
export declare const createWSState: (ws: WebSocket) => Accessor<0 | 1 | 2 | 3>;
export type WSReconnectOptions = {
    delay?: number;
    retries?: number;
};
export type ReconnectingWebSocket = WebSocket & {
    reconnect: () => void;
    /** required for the heartbeat implementation; do not overwrite if you want to use this with heartbeat */
    send: WebSocket["send"] & {
        before?: () => void;
    };
};
/**
 * Returns a WebSocket-like object that under the hood opens new connections on disconnect:
 * ```ts
 * const ws = makeReconnectingWS("ws:localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * onCleanup(() => ws.close());
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 *
 * It will not close the connection on cleanup. To do that, use `createReconnectingWS`.
 */
export declare const makeReconnectingWS: (url: string, protocols?: string | string[], options?: WSReconnectOptions) => ReconnectingWebSocket;
/**
 * Returns a WebSocket-like object that under the hood opens new connections on disconnect and closes on cleanup:
 * ```ts
 * const ws = makeReconnectingWS("ws:localhost:5000");
 * createEffect(() => ws.send(serverMessage()));
 * ```
 * Will not throw if you attempt to send messages before the connection opened; instead, it will enqueue the message to be sent when the connection opens.
 */
export declare const createReconnectingWS: typeof makeReconnectingWS;
export type WSHeartbeatOptions = {
    /**
     * Heartbeat message being sent to the server in order to validate the connection
     * @default "ping"
     */
    message?: WSMessage;
    /**
     * The time between messages being sent in milliseconds
     * @default 1000
     */
    interval?: number;
    /**
     * The time after the heartbeat message being sent to wait for the next message in milliseconds
     * @default 1500
     */
    wait?: number;
};
/**
 * Wraps a reconnecting WebSocket to send a heartbeat to check the connection
 * ```ts
 * const ws = makeHeartbeatWS(createReconnectingWS('ws://localhost:5000'))
 * ```
 * Dispatches a close event to initiate the reconnection of the defunct web socket.
 */
export declare const makeHeartbeatWS: (ws: ReconnectingWebSocket, options?: WSHeartbeatOptions) => WebSocket & {
    reconnect: () => void;
};
