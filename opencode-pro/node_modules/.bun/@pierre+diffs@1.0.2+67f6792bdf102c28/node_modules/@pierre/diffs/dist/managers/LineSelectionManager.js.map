{"version":3,"file":"LineSelectionManager.js","names":["options: LineSelectionOptions","lineNumber: number | undefined","lineIndex: number | undefined","eventSide: AnnotationSide | undefined"],"sources":["../../src/managers/LineSelectionManager.ts"],"sourcesContent":["import type { AnnotationSide } from '../types';\nimport { areSelectionsEqual } from '../utils/areSelectionsEqual';\n\nexport type SelectionSide = AnnotationSide;\n\nexport interface SelectedLineRange {\n  start: number;\n  side?: SelectionSide;\n  end: number;\n  endSide?: SelectionSide;\n}\n\nexport interface LineSelectionOptions {\n  enableLineSelection?: boolean;\n  onLineSelected?: (range: SelectedLineRange | null) => void;\n  onLineSelectionStart?: (range: SelectedLineRange | null) => void;\n  onLineSelectionEnd?: (range: SelectedLineRange | null) => void;\n}\n\ninterface MouseInfo {\n  lineNumber: number;\n  eventSide: AnnotationSide;\n  lineIndex: number;\n}\n\n/**\n * Manages line selection state and interactions for code/diff viewers.\n * Handles:\n * - Click and drag selection\n * - Shift-click to extend selection\n * - DOM attribute updates (data-selected-line)\n */\nexport class LineSelectionManager {\n  private pre: HTMLPreElement | undefined;\n  private selectedRange: SelectedLineRange | null = null;\n  private renderedSelectionRange: SelectedLineRange | null | undefined;\n  private anchor: { line: number; side: SelectionSide } | undefined;\n  private _queuedRender: number | undefined;\n\n  constructor(private options: LineSelectionOptions = {}) {}\n\n  setOptions(options: LineSelectionOptions): void {\n    this.options = { ...this.options, ...options };\n    this.removeEventListeners();\n    if (this.options.enableLineSelection === true) {\n      this.attachEventListeners();\n    }\n  }\n\n  cleanUp(): void {\n    this.removeEventListeners();\n    if (this._queuedRender != null) {\n      cancelAnimationFrame(this._queuedRender);\n      this._queuedRender = undefined;\n    }\n    if (this.pre != null) {\n      delete this.pre.dataset.interactiveLineNumbers;\n    }\n    this.pre = undefined;\n  }\n\n  setup(pre: HTMLPreElement): void {\n    // Assume we are always dirty after a setup...\n    this.setDirty();\n    if (this.pre !== pre) {\n      this.cleanUp();\n    }\n    this.pre = pre;\n    const { enableLineSelection = false } = this.options;\n    if (enableLineSelection) {\n      this.pre.dataset.interactiveLineNumbers = '';\n      this.attachEventListeners();\n    } else {\n      this.removeEventListeners();\n      delete this.pre.dataset.interactiveLineNumbers;\n    }\n\n    this.setSelection(this.selectedRange);\n  }\n\n  setDirty(): void {\n    this.renderedSelectionRange = undefined;\n  }\n\n  isDirty(): boolean {\n    return this.renderedSelectionRange === undefined;\n  }\n\n  setSelection(range: SelectedLineRange | null): void {\n    const isRangeChange = !(\n      range === this.selectedRange ||\n      areSelectionsEqual(range ?? undefined, this.selectedRange ?? undefined)\n    );\n    if (!this.isDirty() && !isRangeChange) return;\n    this.selectedRange = range;\n    this.renderSelection();\n    if (isRangeChange) {\n      this.notifySelectionChange();\n    }\n  }\n\n  getSelection(): SelectedLineRange | null {\n    return this.selectedRange;\n  }\n\n  private attachEventListeners(): void {\n    if (this.pre == null) return;\n    // Lets run a cleanup, just in case\n    this.removeEventListeners();\n    this.pre.addEventListener('mousedown', this.handleMouseDown);\n  }\n\n  private removeEventListeners(): void {\n    if (this.pre == null) return;\n    this.pre.removeEventListener('mousedown', this.handleMouseDown);\n    document.removeEventListener('mousemove', this.handleMouseMove);\n    document.removeEventListener('mouseup', this.handleMouseUp);\n  }\n\n  private handleMouseDown = (event: MouseEvent): void => {\n    // Only handle left mouse button\n    const mouseEventData =\n      event.button === 0\n        ? this.getMouseEventDataForPath(event.composedPath(), 'click')\n        : undefined;\n    if (mouseEventData == null) {\n      return;\n    }\n    event.preventDefault();\n    const { lineNumber, eventSide, lineIndex } = mouseEventData;\n    if (event.shiftKey && this.selectedRange != null) {\n      const range = this.deriveRowRangeFromDOM(\n        this.selectedRange,\n        this.pre?.dataset.type === 'split'\n      );\n      if (range == null) return;\n      const useStart =\n        range.start <= range.end\n          ? lineIndex >= range.start\n          : lineIndex <= range.end;\n      this.anchor = {\n        line: useStart ? this.selectedRange.start : this.selectedRange.end,\n        side:\n          (useStart\n            ? this.selectedRange.side\n            : (this.selectedRange.endSide ?? this.selectedRange.side)) ??\n          'additions',\n      };\n      this.updateSelection(lineNumber, eventSide);\n      this.notifySelectionStart(this.selectedRange);\n    } else {\n      // Check if clicking on already selected single line to unselect\n      if (\n        this.selectedRange?.start === lineNumber &&\n        this.selectedRange?.end === lineNumber\n      ) {\n        this.updateSelection(null);\n        this.notifySelectionEnd(null);\n        this.notifySelectionChange();\n        return;\n      }\n      this.selectedRange = null;\n      this.anchor = { line: lineNumber, side: eventSide };\n      this.updateSelection(lineNumber, eventSide);\n      this.notifySelectionStart(this.selectedRange);\n    }\n\n    document.addEventListener('mousemove', this.handleMouseMove);\n    document.addEventListener('mouseup', this.handleMouseUp);\n  };\n\n  private handleMouseMove = (event: MouseEvent): void => {\n    const mouseEventData = this.getMouseEventDataForPath(\n      event.composedPath(),\n      'move'\n    );\n    if (mouseEventData == null || this.anchor == null) return;\n    const { lineNumber, eventSide } = mouseEventData;\n    this.updateSelection(lineNumber, eventSide);\n  };\n\n  private handleMouseUp = (): void => {\n    this.anchor = undefined;\n    document.removeEventListener('mousemove', this.handleMouseMove);\n    document.removeEventListener('mouseup', this.handleMouseUp);\n    this.notifySelectionEnd(this.selectedRange);\n    this.notifySelectionChange();\n  };\n\n  private updateSelection(currentLine: null): void;\n  private updateSelection(currentLine: number, side: AnnotationSide): void;\n  private updateSelection(\n    currentLine: number | null,\n    side?: AnnotationSide\n  ): void {\n    if (currentLine == null) {\n      this.selectedRange = null;\n    } else {\n      const anchorSide = this.anchor?.side ?? side;\n      const anchorLine = this.anchor?.line ?? currentLine;\n      this.selectedRange = {\n        start: anchorLine,\n        end: currentLine,\n        side: anchorSide,\n        endSide: anchorSide !== side ? side : undefined,\n      };\n    }\n    this._queuedRender ??= requestAnimationFrame(this.renderSelection);\n  }\n\n  private renderSelection = (): void => {\n    if (this._queuedRender != null) {\n      cancelAnimationFrame(this._queuedRender);\n      this._queuedRender = undefined;\n    }\n    if (\n      this.pre == null ||\n      this.renderedSelectionRange === this.selectedRange\n    ) {\n      return;\n    }\n\n    // First clear existing selections, maybe we\n    // can cache this to better avoid this query?\n    const allSelected = this.pre.querySelectorAll('[data-selected-line]');\n    for (const element of allSelected) {\n      element.removeAttribute('data-selected-line');\n    }\n\n    this.renderedSelectionRange = this.selectedRange;\n    if (this.selectedRange == null) {\n      return;\n    }\n\n    const codeElements = this.pre.querySelectorAll('[data-code]');\n    if (codeElements.length === 0) return;\n    if (codeElements.length > 2) {\n      console.error(codeElements);\n      throw new Error(\n        'LineSelectionManager.applySelectionToDOM: Somehow there are more than 2 code elements...'\n      );\n    }\n    const split = this.pre.dataset.type === 'split';\n    const rowRange = this.deriveRowRangeFromDOM(this.selectedRange, split);\n    if (rowRange == null) {\n      console.error({ rowRange, selectedRange: this.selectedRange });\n      throw new Error(\n        'LineSelectionManager.renderSelection: No valid rowRange'\n      );\n    }\n    const isSingle = rowRange.start === rowRange.end;\n    const first = Math.min(rowRange.start, rowRange.end);\n    const last = Math.max(rowRange.start, rowRange.end);\n    for (const code of codeElements) {\n      for (const element of code.children) {\n        if (!(element instanceof HTMLElement)) continue;\n        const lineIndex = this.getLineIndex(element, split);\n        if ((lineIndex ?? 0) > last) break;\n        if (lineIndex == null || lineIndex < first) continue;\n        let attributeValue = isSingle\n          ? 'single'\n          : lineIndex === first\n            ? 'first'\n            : lineIndex === last\n              ? 'last'\n              : '';\n        element.setAttribute('data-selected-line', attributeValue);\n        // If we have a line annotation following our selected line, we should\n        // mark it as selected as well\n        if (\n          element.nextSibling instanceof HTMLElement &&\n          element.nextSibling.hasAttribute('data-line-annotation')\n        ) {\n          // Depending on the line's attribute value, lets go ahead and correct\n          // it when adding in the annotation row\n          if (isSingle) {\n            // Single technically becomes 2 selected lines\n            attributeValue = 'last';\n            element.setAttribute('data-selected-line', 'first');\n          } else if (lineIndex === first) {\n            // We don't want apply 'first' to the line annotation\n            attributeValue = '';\n          } else if (lineIndex === last) {\n            // the annotation will become the last selected line and therefore\n            // our existing line should no longer be last\n            element.setAttribute('data-selected-line', '');\n          }\n          element.nextSibling.setAttribute(\n            'data-selected-line',\n            attributeValue\n          );\n        }\n      }\n    }\n  };\n\n  private deriveRowRangeFromDOM(\n    range: SelectedLineRange,\n    split: boolean\n  ): { start: number; end: number } | undefined {\n    if (range == null) return undefined;\n    const start = this.findRowIndexForLineNumber(\n      range.start,\n      range.side,\n      split\n    );\n    const end =\n      range.end === range.start &&\n      (range.endSide == null || range.endSide === range.side)\n        ? start\n        : this.findRowIndexForLineNumber(\n            range.end,\n            range.endSide ?? range.side,\n            split\n          );\n    return start != null && end != null ? { start, end } : undefined;\n  }\n\n  private findRowIndexForLineNumber(\n    lineNumber: number,\n    targetSide: SelectionSide = 'additions',\n    split: boolean\n  ): number | undefined {\n    if (this.pre == null) return undefined;\n    const elements = Array.from(\n      this.pre.querySelectorAll(`[data-line=\"${lineNumber}\"]`)\n    );\n    // Given how unified diffs can order things, we need to always process\n    // `[data-line]` elements before `[data-alt-line]`\n    elements.push(\n      ...Array.from(\n        this.pre.querySelectorAll(`[data-alt-line=\"${lineNumber}\"]`)\n      )\n    );\n    if (elements.length === 0) return undefined;\n\n    for (const element of elements) {\n      if (!(element instanceof HTMLElement)) {\n        continue;\n      }\n      const side = this.getLineSideFromElement(element);\n      if (side === targetSide) {\n        return this.getLineIndex(element, split);\n      } else if (parseInt(element.dataset.altLine ?? '') === lineNumber) {\n        return this.getLineIndex(element, split);\n      }\n    }\n    console.error(\n      'LineSelectionManager.findRowIndexForLineNumber: Invalid selection',\n      lineNumber,\n      targetSide\n    );\n    return undefined;\n  }\n\n  private notifySelectionChange(): void {\n    const { onLineSelected } = this.options;\n    if (onLineSelected == null) return;\n\n    onLineSelected(this.selectedRange ?? null);\n  }\n\n  private notifySelectionStart(range: SelectedLineRange | null): void {\n    const { onLineSelectionStart } = this.options;\n    if (onLineSelectionStart == null) return;\n    onLineSelectionStart(range);\n  }\n\n  private notifySelectionEnd(range: SelectedLineRange | null): void {\n    const { onLineSelectionEnd } = this.options;\n    if (onLineSelectionEnd == null) return;\n    onLineSelectionEnd(range);\n  }\n\n  private getMouseEventDataForPath(\n    path: (EventTarget | undefined)[],\n    eventType: 'click' | 'move'\n  ): MouseInfo | undefined {\n    let lineNumber: number | undefined;\n    let lineIndex: number | undefined;\n    let isNumberColumn = false;\n    let eventSide: AnnotationSide | undefined;\n    for (const element of path) {\n      if (!(element instanceof HTMLElement)) {\n        continue;\n      }\n      if (element.hasAttribute('data-column-number')) {\n        isNumberColumn = true;\n        continue;\n      }\n      if (element.hasAttribute('data-line')) {\n        lineNumber = this.getLineNumber(element);\n        lineIndex = this.getLineIndex(\n          element,\n          this.pre?.dataset.type === 'split'\n        );\n        if (element.dataset.lineType === 'change-deletion') {\n          eventSide = 'deletions';\n        } else if (element.dataset.lineType === 'change-additions') {\n          eventSide = 'additions';\n        }\n        // if we can't pull out an index or line number, we can't do anything.\n        if (lineIndex == null || lineNumber == null) {\n          lineIndex = undefined;\n          lineNumber = undefined;\n          break;\n        }\n        // If we already have an eventSide, we done computin\n        if (eventSide != null) {\n          break;\n        } else {\n          // context type lines will need to be discovered higher up\n          // at the data-code level\n        }\n        continue;\n      }\n      if (element.hasAttribute('data-code')) {\n        eventSide ??= element.hasAttribute('data-deletions')\n          ? 'deletions'\n          : // context in unified style are assumed to be additions based on\n            // their line numbers\n            'additions';\n        // If we got to the code element, we def done, son\n        break;\n      }\n    }\n    if (\n      (eventType === 'click' && !isNumberColumn) ||\n      lineIndex == null ||\n      lineNumber == null\n    ) {\n      return undefined;\n    }\n    return {\n      lineIndex,\n      lineNumber,\n      // Normally this shouldn't hit unless we broke early for whatever reason,\n      // but for types lets ensure it's additions if undefined\n      eventSide: eventSide ?? 'additions',\n    };\n  }\n\n  private getLineNumber(element: HTMLElement): number | undefined {\n    const lineNumber = parseInt(element.dataset.line ?? '', 10);\n    return !Number.isNaN(lineNumber) ? lineNumber : undefined;\n  }\n\n  private getLineIndex(\n    element: HTMLElement,\n    split: boolean\n  ): number | undefined {\n    const lineIndexes = (element.dataset.lineIndex ?? '')\n      .split(',')\n      .map((value) => parseInt(value))\n      .filter((value) => !Number.isNaN(value));\n\n    if (split && lineIndexes.length === 2) {\n      return lineIndexes[1];\n    } else if (!split) {\n      return lineIndexes[0];\n    }\n    return undefined;\n  }\n\n  private getLineSideFromElement(element: HTMLElement): SelectionSide {\n    if (element.dataset.lineType === 'change-deletion') {\n      return 'deletions';\n    }\n    if (element.dataset.lineType === 'change-addition') {\n      return 'additions';\n    }\n    const parent = element.closest('[data-code]');\n    if (!(parent instanceof HTMLElement)) {\n      return 'additions';\n    }\n    return parent.hasAttribute('data-deletions') ? 'deletions' : 'additions';\n  }\n}\n\nexport function pluckLineSelectionOptions({\n  enableLineSelection,\n  onLineSelected,\n  onLineSelectionStart,\n  onLineSelectionEnd,\n}: LineSelectionOptions): LineSelectionOptions {\n  return {\n    enableLineSelection,\n    onLineSelected,\n    onLineSelectionStart,\n    onLineSelectionEnd,\n  };\n}\n"],"mappings":"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"}