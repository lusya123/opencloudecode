{"version":3,"file":"parsePatchFiles.js","names":["patchMetadata: string | undefined","files: FileDiffMetadata[]","currentFile: FileDiffMetadata | undefined","hunkContent: (ContextContent | ChangeContent)[]","currentContent: ContextContent | ChangeContent | undefined","lastLineType: 'context' | 'addition' | 'deletion' | undefined","hunkData: Hunk","patches: ParsedPatch[]"],"sources":["../../src/utils/parsePatchFiles.ts"],"sourcesContent":["import {\n  ALTERNATE_FILE_NAMES_GIT,\n  COMMIT_METADATA_SPLIT,\n  FILENAME_HEADER_REGEX,\n  FILENAME_HEADER_REGEX_GIT,\n  FILE_CONTEXT_BLOB,\n  FILE_MODE_FROM_INDEX,\n  GIT_DIFF_FILE_BREAK_REGEX,\n  HUNK_HEADER,\n  SPLIT_WITH_NEWLINES,\n  UNIFIED_DIFF_FILE_BREAK_REGEX,\n} from '../constants';\nimport type {\n  ChangeContent,\n  ContextContent,\n  FileDiffMetadata,\n  Hunk,\n  ParsedPatch,\n} from '../types';\nimport { cleanLastNewline } from './cleanLastNewline';\nimport { parseLineType } from './parseLineType';\n\nfunction processPatch(data: string, cacheKeyPrefix?: string): ParsedPatch {\n  const isGitDiff = GIT_DIFF_FILE_BREAK_REGEX.test(data);\n  const rawFiles = data.split(\n    isGitDiff ? GIT_DIFF_FILE_BREAK_REGEX : UNIFIED_DIFF_FILE_BREAK_REGEX\n  );\n  let patchMetadata: string | undefined;\n  const files: FileDiffMetadata[] = [];\n  let currentFile: FileDiffMetadata | undefined;\n  for (const file of rawFiles) {\n    if (isGitDiff && !GIT_DIFF_FILE_BREAK_REGEX.test(file)) {\n      if (patchMetadata == null) {\n        patchMetadata = file;\n      } else {\n        console.error('parsePatchContent: unknown file blob:', file);\n      }\n      // If we get in here, it's most likely the introductory metadata from the\n      // patch, or something is fucked with the diff format\n      continue;\n    } else if (!isGitDiff && !UNIFIED_DIFF_FILE_BREAK_REGEX.test(file)) {\n      if (patchMetadata == null) {\n        patchMetadata = file;\n      } else {\n        console.error('parsePatchContent: unknown file blob:', file);\n      }\n      continue;\n    }\n    let lastHunkEnd = 0;\n    const hunks = file.split(FILE_CONTEXT_BLOB);\n    currentFile = undefined;\n    for (const hunk of hunks) {\n      const lines = hunk.split(SPLIT_WITH_NEWLINES);\n      const firstLine = lines.shift();\n      if (firstLine == null) {\n        console.error('parsePatchContent: invalid hunk', hunk);\n        continue;\n      }\n      const match = firstLine.match(HUNK_HEADER);\n      const hunkContent: (ContextContent | ChangeContent)[] = [];\n      let additionLines = 0;\n      let deletionLines = 0;\n      if (match == null || currentFile == null) {\n        if (currentFile != null) {\n          console.error('parsePatchContent: Invalid hunk', hunk);\n          continue;\n        }\n        currentFile = {\n          name: '',\n          prevName: undefined,\n          type: 'change',\n          hunks: [],\n          splitLineCount: 0,\n          unifiedLineCount: 0,\n          cacheKey:\n            cacheKeyPrefix != null\n              ? `${cacheKeyPrefix}-${files.length}`\n              : undefined,\n        };\n        // Push that first line back into the group of lines so we can properly\n        // parse it out\n        lines.unshift(firstLine);\n        for (const line of lines) {\n          const filenameMatch = line.match(\n            isGitDiff ? FILENAME_HEADER_REGEX_GIT : FILENAME_HEADER_REGEX\n          );\n          if (line.startsWith('diff --git')) {\n            const [, , prevName, , name] =\n              line.trim().match(ALTERNATE_FILE_NAMES_GIT) ?? [];\n            currentFile.name = name.trim();\n            if (prevName !== name) {\n              currentFile.prevName = prevName.trim();\n            }\n          } else if (filenameMatch != null) {\n            const [, type, fileName] = filenameMatch;\n            if (type === '---' && fileName !== '/dev/null') {\n              currentFile.prevName = fileName.trim();\n              currentFile.name = fileName.trim();\n            } else if (type === '+++' && fileName !== '/dev/null') {\n              currentFile.name = fileName.trim();\n            }\n          }\n          // Git diffs have a bunch of additional metadata we can pull from\n          else if (isGitDiff) {\n            if (line.startsWith('new mode ')) {\n              currentFile.mode = line.replace('new mode', '').trim();\n            }\n            if (line.startsWith('old mode ')) {\n              currentFile.oldMode = line.replace('old mode', '').trim();\n            }\n            if (line.startsWith('new file mode')) {\n              currentFile.type = 'new';\n              currentFile.mode = line.replace('new file mode', '').trim();\n            }\n            if (line.startsWith('deleted file mode')) {\n              currentFile.type = 'deleted';\n              currentFile.mode = line.replace('deleted file mode', '').trim();\n            }\n            if (line.startsWith('similarity index')) {\n              if (line.startsWith('similarity index 100%')) {\n                currentFile.type = 'rename-pure';\n              } else {\n                currentFile.type = 'rename-changed';\n              }\n            }\n            if (line.startsWith('index ')) {\n              const [, mode] = line.trim().match(FILE_MODE_FROM_INDEX) ?? [];\n              if (mode != null) {\n                currentFile.mode = mode;\n              }\n            }\n            // We have to handle these for pure renames because there won't be\n            // --- and +++ lines\n            if (line.startsWith('rename from ')) {\n              currentFile.prevName = line.replace('rename from ', '');\n            }\n            if (line.startsWith('rename to ')) {\n              currentFile.name = line.replace('rename to ', '').trim();\n            }\n          }\n        }\n        continue;\n      } else {\n        let currentContent: ContextContent | ChangeContent | undefined;\n        let lastLineType: 'context' | 'addition' | 'deletion' | undefined;\n        // Strip trailing bare newlines (format-patch separators between commits)\n        while (\n          lines.length > 0 &&\n          (lines[lines.length - 1] === '\\n' || lines[lines.length - 1] === '')\n        ) {\n          lines.pop();\n        }\n        for (const rawLine of lines) {\n          const parsedLine = parseLineType(rawLine);\n          if (parsedLine == null) {\n            continue;\n          }\n          const { type, line } = parsedLine;\n          if (type === 'addition') {\n            if (currentContent == null || currentContent.type !== 'change') {\n              currentContent = createContentGroup('change');\n              hunkContent.push(currentContent);\n            }\n            currentContent.additions.push(line);\n            additionLines++;\n            lastLineType = 'addition';\n          } else if (type === 'deletion') {\n            if (currentContent == null || currentContent.type !== 'change') {\n              currentContent = createContentGroup('change');\n              hunkContent.push(currentContent);\n            }\n            currentContent.deletions.push(line);\n            deletionLines++;\n            lastLineType = 'deletion';\n          } else if (type === 'context') {\n            if (currentContent == null || currentContent.type !== 'context') {\n              currentContent = createContentGroup('context');\n              hunkContent.push(currentContent);\n            }\n            currentContent.lines.push(line);\n            lastLineType = 'context';\n          } else if (type === 'metadata' && currentContent != null) {\n            if (currentContent.type === 'context') {\n              currentContent.noEOFCR = true;\n            } else if (lastLineType === 'deletion') {\n              currentContent.noEOFCRDeletions = true;\n              const lastIndex = currentContent.deletions.length - 1;\n              if (lastIndex >= 0) {\n                currentContent.deletions[lastIndex] = cleanLastNewline(\n                  currentContent.deletions[lastIndex]\n                );\n              }\n            } else if (lastLineType === 'addition') {\n              currentContent.noEOFCRAdditions = true;\n              const lastIndex = currentContent.additions.length - 1;\n              if (lastIndex >= 0) {\n                currentContent.additions[lastIndex] = cleanLastNewline(\n                  currentContent.additions[lastIndex]\n                );\n              }\n            }\n          }\n        }\n      }\n      const hunkData: Hunk = {\n        collapsedBefore: 0,\n        splitLineCount: 0,\n        splitLineStart: 0,\n        unifiedLineCount: 0,\n        unifiedLineStart: 0,\n        additionCount: parseInt(match[4] ?? '1'),\n        additionStart: parseInt(match[3]),\n        additionLines,\n        deletionCount: parseInt(match[2] ?? '1'),\n        deletionStart: parseInt(match[1]),\n        deletionLines,\n        hunkContent,\n        hunkContext: match[5],\n        hunkSpecs: firstLine,\n      };\n      if (\n        isNaN(hunkData.additionCount) ||\n        isNaN(hunkData.deletionCount) ||\n        isNaN(hunkData.additionStart) ||\n        isNaN(hunkData.deletionStart)\n      ) {\n        console.error('parsePatchContent: invalid hunk metadata', hunkData);\n        continue;\n      }\n      hunkData.collapsedBefore = Math.max(\n        hunkData.additionStart - 1 - lastHunkEnd,\n        0\n      );\n      currentFile.hunks.push(hunkData);\n      lastHunkEnd = hunkData.additionStart + hunkData.additionCount - 1;\n      for (const content of hunkContent) {\n        if (content.type === 'context') {\n          hunkData.splitLineCount += content.lines.length;\n          hunkData.unifiedLineCount += content.lines.length;\n        } else {\n          hunkData.splitLineCount += Math.max(\n            content.additions.length,\n            content.deletions.length\n          );\n          hunkData.unifiedLineCount +=\n            content.deletions.length + content.additions.length;\n        }\n      }\n      hunkData.splitLineStart = currentFile.splitLineCount;\n      hunkData.unifiedLineStart = currentFile.unifiedLineCount;\n\n      currentFile.splitLineCount += hunkData.splitLineCount;\n      currentFile.unifiedLineCount += hunkData.unifiedLineCount;\n    }\n    if (currentFile != null) {\n      if (\n        !isGitDiff &&\n        currentFile.prevName != null &&\n        currentFile.name !== currentFile.prevName\n      ) {\n        if (currentFile.hunks.length > 0) {\n          currentFile.type = 'rename-changed';\n        } else {\n          currentFile.type = 'rename-pure';\n        }\n      }\n      if (\n        currentFile.type !== 'rename-pure' &&\n        currentFile.type !== 'rename-changed'\n      ) {\n        currentFile.prevName = undefined;\n      }\n      files.push(currentFile);\n    }\n  }\n  return { patchMetadata, files };\n}\n\n/**\n * Parses a patch file string into an array of parsed patches.\n *\n * @param data - The raw patch file content (supports multi-commit patches)\n * @param cacheKeyPrefix - Optional prefix for generating cache keys. When provided,\n *   each file in the patch will get a cache key in the format `prefix-patchIndex-fileIndex`.\n *   This enables caching of rendered diff results in the worker pool.\n */\nexport function parsePatchFiles(\n  data: string,\n  cacheKeyPrefix?: string\n): ParsedPatch[] {\n  // NOTE(amadeus): This function is pretty forgiving in that it can accept a\n  // patch file that includes commit metdata, multiple commits, or not\n  const patches: ParsedPatch[] = [];\n  for (const patch of data.split(COMMIT_METADATA_SPLIT)) {\n    try {\n      patches.push(\n        processPatch(\n          patch,\n          cacheKeyPrefix != null\n            ? `${cacheKeyPrefix}-${patches.length}`\n            : undefined\n        )\n      );\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return patches;\n}\n\nfunction createContentGroup(type: 'change'): ChangeContent;\nfunction createContentGroup(type: 'context'): ContextContent;\nfunction createContentGroup(\n  type: 'change' | 'context'\n): ChangeContent | ContextContent {\n  if (type === 'change') {\n    return {\n      type: 'change',\n      additions: [],\n      deletions: [],\n      noEOFCRAdditions: false,\n      noEOFCRDeletions: false,\n    };\n  }\n  return { type: 'context', lines: [], noEOFCR: false };\n}\n"],"mappings":"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"}