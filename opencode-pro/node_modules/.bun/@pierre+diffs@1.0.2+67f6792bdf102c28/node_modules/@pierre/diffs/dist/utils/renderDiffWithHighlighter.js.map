{"version":3,"file":"renderDiffWithHighlighter.js","names":["hunks: RenderDiffFilesResult[]","deletionSpans: [0 | 1, string][]","additionSpans: [0 | 1, string][]","oldInfo: Record<number, LineInfo | undefined>","newInfo: Record<number, LineInfo | undefined>","oldDecorations: DecorationItem[]","newDecorations: DecorationItem[]","hastConfig: CodeToHastOptions<DiffsThemeNames>"],"sources":["../../src/utils/renderDiffWithHighlighter.ts"],"sourcesContent":["import { diffChars, diffWordsWithSpace } from 'diff';\n\nimport { DEFAULT_THEMES } from '../constants';\nimport type {\n  CodeToHastOptions,\n  DecorationItem,\n  DiffsHighlighter,\n  DiffsThemeNames,\n  FileContents,\n  FileDiffMetadata,\n  Hunk,\n  LineDiffTypes,\n  LineInfo,\n  RenderDiffFilesResult,\n  RenderDiffOptions,\n  SupportedLanguages,\n  ThemedDiffResult,\n} from '../types';\nimport { cleanLastNewline } from './cleanLastNewline';\nimport { createTransformerWithState } from './createTransformerWithState';\nimport { formatCSSVariablePrefix } from './formatCSSVariablePrefix';\nimport { getFiletypeFromFileName } from './getFiletypeFromFileName';\nimport { getHighlighterThemeStyles } from './getHighlighterThemeStyles';\nimport { getLineNodes } from './getLineNodes';\nimport {\n  createDiffSpanDecoration,\n  pushOrJoinSpan,\n} from './parseDiffDecorations';\n\nexport function renderDiffWithHighlighter(\n  diff: FileDiffMetadata,\n  highlighter: DiffsHighlighter,\n  options: RenderDiffOptions,\n  forcePlainText = false\n): ThemedDiffResult {\n  const baseThemeType = (() => {\n    const theme = options.theme ?? DEFAULT_THEMES;\n    if (typeof theme === 'string') {\n      return highlighter.getTheme(theme).type;\n    }\n    return undefined;\n  })();\n  const themeStyles = getHighlighterThemeStyles({\n    theme: options.theme,\n    highlighter,\n  });\n  // If we've received a diff with both files\n  if (diff.newLines != null && diff.oldLines != null) {\n    const {\n      oldContent,\n      newContent,\n      oldInfo,\n      newInfo,\n      oldDecorations,\n      newDecorations,\n    } = processLines({\n      hunks: diff.hunks,\n      oldLines: diff.oldLines,\n      newLines: diff.newLines,\n      lineDiffType: options.lineDiffType,\n    });\n    const oldFile = {\n      name: diff.prevName ?? diff.name,\n      contents: oldContent,\n    };\n    const newFile = {\n      name: diff.name,\n      contents: newContent,\n    };\n    const code = renderTwoFiles({\n      oldFile,\n      oldInfo,\n      oldDecorations,\n\n      newFile,\n      newInfo,\n      newDecorations,\n\n      highlighter,\n      options,\n      languageOverride: forcePlainText ? 'text' : diff.lang,\n    });\n    return { code, themeStyles, baseThemeType };\n  }\n  const hunks: RenderDiffFilesResult[] = [];\n  let splitLineIndex = 0;\n  let unifiedLineIndex = 0;\n  for (const hunk of diff.hunks) {\n    const {\n      oldContent,\n      newContent,\n      oldInfo,\n      newInfo,\n      oldDecorations,\n      newDecorations,\n      splitLineIndex: newSplitLineIndex,\n      unifiedLineIndex: newUnifiedLineIndex,\n    } = processLines({\n      hunks: [hunk],\n      splitLineIndex,\n      unifiedLineIndex,\n      lineDiffType: options.lineDiffType,\n    });\n    const oldFile = {\n      name: diff.prevName ?? diff.name,\n      contents: oldContent,\n    };\n    const newFile = {\n      name: diff.name,\n      contents: newContent,\n    };\n    hunks.push(\n      renderTwoFiles({\n        oldFile,\n        oldInfo,\n        oldDecorations,\n\n        newFile,\n        newInfo,\n        newDecorations,\n\n        highlighter,\n        options,\n        languageOverride: forcePlainText ? 'text' : diff.lang,\n      })\n    );\n    splitLineIndex = newSplitLineIndex;\n    unifiedLineIndex = newUnifiedLineIndex;\n  }\n\n  const code = (() => {\n    if (hunks.length <= 1) {\n      const hunk = hunks[0] ?? { oldLines: [], newLines: [] };\n      if (hunk.newLines.length === 0 || hunk.oldLines.length === 0) {\n        return hunk;\n      }\n    }\n    return { hunks };\n  })();\n\n  return { code, themeStyles, baseThemeType };\n}\n\ninterface ProcessLineDiffProps {\n  oldLine: string | undefined;\n  newLine: string | undefined;\n  oldLineIndex: number;\n  newLineIndex: number;\n  oldDecorations: DecorationItem[];\n  newDecorations: DecorationItem[];\n  lineDiffType: LineDiffTypes;\n}\n\nfunction computeLineDiffDecorations({\n  oldLine,\n  newLine,\n  oldLineIndex,\n  newLineIndex,\n  oldDecorations,\n  newDecorations,\n  lineDiffType,\n}: ProcessLineDiffProps) {\n  if (oldLine == null || newLine == null || lineDiffType === 'none') {\n    return;\n  }\n  oldLine = cleanLastNewline(oldLine);\n  newLine = cleanLastNewline(newLine);\n  // NOTE(amadeus): Because we visually trim trailing newlines when rendering,\n  // we also gotta make sure the diff parsing doesn't include the newline\n  // character that could be there...\n  const lineDiff =\n    lineDiffType === 'char'\n      ? diffChars(oldLine, newLine)\n      : diffWordsWithSpace(oldLine, newLine);\n  const deletionSpans: [0 | 1, string][] = [];\n  const additionSpans: [0 | 1, string][] = [];\n  const enableJoin = lineDiffType === 'word-alt';\n  for (const item of lineDiff) {\n    const isLastItem = item === lineDiff[lineDiff.length - 1];\n    if (!item.added && !item.removed) {\n      pushOrJoinSpan({\n        item,\n        arr: deletionSpans,\n        enableJoin,\n        isNeutral: true,\n        isLastItem,\n      });\n      pushOrJoinSpan({\n        item,\n        arr: additionSpans,\n        enableJoin,\n        isNeutral: true,\n        isLastItem,\n      });\n    } else if (item.removed) {\n      pushOrJoinSpan({ item, arr: deletionSpans, enableJoin, isLastItem });\n    } else {\n      pushOrJoinSpan({ item, arr: additionSpans, enableJoin, isLastItem });\n    }\n  }\n  let spanIndex = 0;\n  for (const span of deletionSpans) {\n    if (span[0] === 1) {\n      oldDecorations.push(\n        createDiffSpanDecoration({\n          // Decoration indexes start at 0\n          line: oldLineIndex - 1,\n          spanStart: spanIndex,\n          spanLength: span[1].length,\n        })\n      );\n    }\n    spanIndex += span[1].length;\n  }\n  spanIndex = 0;\n  for (const span of additionSpans) {\n    if (span[0] === 1) {\n      newDecorations.push(\n        createDiffSpanDecoration({\n          // Decoration indexes start at 0\n          line: newLineIndex - 1,\n          spanStart: spanIndex,\n          spanLength: span[1].length,\n        })\n      );\n    }\n    spanIndex += span[1].length;\n  }\n}\n\ninterface ProcessLinesProps {\n  hunks: Hunk[];\n  oldLines?: string[];\n  newLines?: string[];\n  splitLineIndex?: number;\n  unifiedLineIndex?: number;\n  newLineIndex?: number;\n  oldLineIndex?: number;\n  lineDiffType: LineDiffTypes;\n}\n\nfunction processLines({\n  hunks,\n  oldLines,\n  newLines,\n  splitLineIndex = 0,\n  unifiedLineIndex = 0,\n  lineDiffType,\n}: ProcessLinesProps) {\n  const oldInfo: Record<number, LineInfo | undefined> = {};\n  const newInfo: Record<number, LineInfo | undefined> = {};\n  const oldDecorations: DecorationItem[] = [];\n  const newDecorations: DecorationItem[] = [];\n  let newLineIndex = 1;\n  let oldLineIndex = 1;\n  let newLineNumber = 1;\n  let oldLineNumber = 1;\n  let oldContent = '';\n  let newContent = '';\n  for (const hunk of hunks) {\n    // If there's content prior to the hunk, lets fill it up\n    while (\n      oldLines != null &&\n      newLines != null &&\n      newLineIndex < hunk.additionStart &&\n      oldLineIndex < hunk.deletionStart\n    ) {\n      oldInfo[oldLineIndex] = {\n        type: 'context-expanded',\n        lineNumber: oldLineNumber,\n        altLineNumber: newLineNumber,\n        lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n      };\n      newInfo[newLineIndex] = {\n        type: 'context-expanded',\n        lineNumber: newLineNumber,\n        altLineNumber: oldLineNumber,\n        lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n      };\n      oldContent += oldLines[oldLineIndex - 1];\n      newContent += newLines[newLineIndex - 1];\n      oldLineIndex++;\n      newLineIndex++;\n      oldLineNumber++;\n      newLineNumber++;\n      splitLineIndex++;\n      unifiedLineIndex++;\n    }\n    oldLineNumber = hunk.deletionStart;\n    newLineNumber = hunk.additionStart;\n\n    // Lets process the actual hunk content\n    for (const hunkContent of hunk.hunkContent) {\n      if (hunkContent.type === 'context') {\n        for (const line of hunkContent.lines) {\n          oldInfo[oldLineIndex] = {\n            type: 'context',\n            lineNumber: oldLineNumber,\n            altLineNumber: newLineNumber,\n            lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n          };\n          newInfo[newLineIndex] = {\n            type: 'context',\n            lineNumber: newLineNumber,\n            altLineNumber: oldLineNumber,\n            lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n          };\n          oldContent += line;\n          newContent += line;\n          oldLineIndex++;\n          newLineIndex++;\n          newLineNumber++;\n          oldLineNumber++;\n          splitLineIndex++;\n          unifiedLineIndex++;\n        }\n      } else {\n        const len = Math.max(\n          hunkContent.additions.length,\n          hunkContent.deletions.length\n        );\n        let i = 0;\n        // NOTE(amadeus): Since we iterate through deletions and additions\n        // simultaneously, we have to create a secondary iterator for\n        // unifiedLineIndex, and then when we're done, add the combined lengths\n        // of additions/deletions to the main variable\n        let _unifiedLineIndex = unifiedLineIndex;\n        while (i < len) {\n          const oldLine = hunkContent.deletions[i];\n          const newLine = hunkContent.additions[i];\n          computeLineDiffDecorations({\n            newLine,\n            oldLine,\n            oldLineIndex,\n            newLineIndex,\n            oldDecorations,\n            newDecorations,\n            lineDiffType,\n          });\n          if (oldLine != null) {\n            oldInfo[oldLineIndex] = {\n              type: 'change-deletion',\n              lineNumber: oldLineNumber,\n              lineIndex: `${_unifiedLineIndex},${splitLineIndex}`,\n            };\n            oldContent += oldLine;\n            oldLineIndex++;\n            oldLineNumber++;\n          }\n          if (newLine != null) {\n            newInfo[newLineIndex] = {\n              type: 'change-addition',\n              lineNumber: newLineNumber,\n              lineIndex: `${_unifiedLineIndex + hunkContent.deletions.length},${splitLineIndex}`,\n            };\n            newContent += newLine;\n            newLineIndex++;\n            newLineNumber++;\n          }\n          splitLineIndex++;\n          _unifiedLineIndex++;\n          i++;\n        }\n        unifiedLineIndex +=\n          hunkContent.additions.length + hunkContent.deletions.length;\n      }\n    }\n\n    if (\n      oldLines == null ||\n      newLines == null ||\n      hunk !== hunks[hunks.length - 1]\n    )\n      continue;\n    // If we are on the last hunk, we should fully iterate through the rest\n    // of the lines\n    while (oldLineIndex <= oldLines.length || newLineIndex <= oldLines.length) {\n      const oldLine = oldLines[oldLineIndex - 1];\n      const newLine = newLines[newLineIndex - 1];\n      if (oldLine == null && newLine == null) {\n        break;\n      }\n      if (oldLine != null) {\n        oldInfo[oldLineIndex] = {\n          type: 'context-expanded',\n          lineNumber: oldLineNumber,\n          altLineNumber: newLineNumber,\n          lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n        };\n        oldContent += oldLine;\n        oldLineIndex++;\n        oldLineNumber++;\n      }\n      if (newLine != null) {\n        newInfo[newLineIndex] = {\n          type: 'context-expanded',\n          lineNumber: newLineNumber,\n          altLineNumber: oldLineNumber,\n          lineIndex: `${unifiedLineIndex},${splitLineIndex}`,\n        };\n        newContent += newLine;\n        newLineIndex++;\n        newLineNumber++;\n      }\n      splitLineIndex++;\n      unifiedLineIndex++;\n    }\n  }\n  return {\n    oldContent: cleanLastNewline(oldContent),\n    newContent: cleanLastNewline(newContent),\n    oldInfo,\n    newInfo,\n    oldDecorations,\n    newDecorations,\n    splitLineIndex,\n    unifiedLineIndex,\n  };\n}\n\ninterface RenderTwoFilesProps {\n  oldFile: FileContents;\n  newFile: FileContents;\n  oldInfo: Record<number, LineInfo | undefined>;\n  newInfo: Record<number, LineInfo | undefined>;\n  oldDecorations: DecorationItem[];\n  newDecorations: DecorationItem[];\n  options: RenderDiffOptions;\n  highlighter: DiffsHighlighter;\n  languageOverride: SupportedLanguages | undefined;\n}\n\nfunction renderTwoFiles({\n  oldFile,\n  newFile,\n  oldInfo,\n  newInfo,\n  highlighter,\n  oldDecorations,\n  newDecorations,\n  languageOverride,\n  options: { theme: themeOrThemes = DEFAULT_THEMES, ...options },\n}: RenderTwoFilesProps) {\n  const oldLang = languageOverride ?? getFiletypeFromFileName(oldFile.name);\n  const newLang = languageOverride ?? getFiletypeFromFileName(newFile.name);\n  const { state, transformers } = createTransformerWithState();\n  const hastConfig: CodeToHastOptions<DiffsThemeNames> = (() => {\n    return typeof themeOrThemes === 'string'\n      ? {\n          ...options,\n          // language will be overwritten for each highlight\n          lang: 'text',\n          theme: themeOrThemes,\n          transformers,\n          decorations: undefined,\n          defaultColor: false,\n          cssVariablePrefix: formatCSSVariablePrefix(),\n        }\n      : {\n          ...options,\n          // language will be overwritten for each highlight\n          lang: 'text',\n          themes: themeOrThemes,\n          transformers,\n          decorations: undefined,\n          defaultColor: false,\n          cssVariablePrefix: formatCSSVariablePrefix(),\n        };\n  })();\n\n  const oldLines = (() => {\n    if (oldFile.contents === '') {\n      return [];\n    }\n    hastConfig.lang = oldLang;\n    state.lineInfo = oldInfo;\n    hastConfig.decorations = oldDecorations;\n    return getLineNodes(highlighter.codeToHast(oldFile.contents, hastConfig));\n  })();\n  const newLines = (() => {\n    if (newFile.contents === '') {\n      return [];\n    }\n    hastConfig.lang = newLang;\n    hastConfig.decorations = newDecorations;\n    state.lineInfo = newInfo;\n    return getLineNodes(highlighter.codeToHast(newFile.contents, hastConfig));\n  })();\n\n  return { oldLines, newLines };\n}\n"],"mappings":"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"}