{"version":3,"file":"resolveLanguage.js","names":["resolver"],"sources":["../../../src/highlighter/languages/resolveLanguage.ts"],"sourcesContent":["import { bundledLanguages } from 'shiki';\n\nimport type { SupportedLanguages } from '../../types';\nimport { isWorkerContext } from '../../utils/isWorkerContext';\nimport type { ResolvedLanguage } from '../../worker';\nimport { ResolvedLanguages, ResolvingLanguages } from './constants';\n\nexport async function resolveLanguage(\n  lang: Exclude<SupportedLanguages, 'text'>\n): Promise<ResolvedLanguage> {\n  // Prevent dynamic imports in worker contexts\n  if (isWorkerContext()) {\n    throw new Error(\n      `resolveLanguage(\"${lang}\") cannot be called from a worker context. ` +\n        'Languages must be pre-resolved on the main thread and passed to the worker via the resolvedLanguages parameter.'\n    );\n  }\n\n  const resolver = ResolvingLanguages.get(lang);\n  if (resolver != null) {\n    return resolver;\n  }\n\n  try {\n    const loader = bundledLanguages[lang];\n    if (loader == null) {\n      throw new Error(\n        `resolveLanguage: \"${lang}\" not found in bundled languages`\n      );\n    }\n\n    const resolver = loader().then(({ default: data }) => {\n      const resolvedLang = { name: lang, data };\n      if (!ResolvedLanguages.has(lang)) {\n        ResolvedLanguages.set(lang, resolvedLang);\n      }\n      return resolvedLang;\n    });\n    ResolvingLanguages.set(lang, resolver);\n    return await resolver;\n  } finally {\n    ResolvingLanguages.delete(lang);\n  }\n}\n"],"mappings":";;;;;AAOA,eAAsB,gBACpB,MAC2B;AAE3B,KAAI,iBAAiB,CACnB,OAAM,IAAI,MACR,oBAAoB,KAAK,4JAE1B;CAGH,MAAM,WAAW,mBAAmB,IAAI,KAAK;AAC7C,KAAI,YAAY,KACd,QAAO;AAGT,KAAI;EACF,MAAM,SAAS,iBAAiB;AAChC,MAAI,UAAU,KACZ,OAAM,IAAI,MACR,qBAAqB,KAAK,kCAC3B;EAGH,MAAMA,aAAW,QAAQ,CAAC,MAAM,EAAE,SAAS,WAAW;GACpD,MAAM,eAAe;IAAE,MAAM;IAAM;IAAM;AACzC,OAAI,CAAC,kBAAkB,IAAI,KAAK,CAC9B,mBAAkB,IAAI,MAAM,aAAa;AAE3C,UAAO;IACP;AACF,qBAAmB,IAAI,MAAMA,WAAS;AACtC,SAAO,MAAMA;WACL;AACR,qBAAmB,OAAO,KAAK"}