{
  "version": 3,
  "sources": ["../../../../../node_modules/.bun/lru_map@0.4.1/node_modules/lru_map/dist/lru.js", "../../../../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/src/worker/WorkerPoolManager.ts", "../../../../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/src/worker/getOrCreateWorkerPoolSingleton.ts"],
  "sourcesContent": ["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n!function(g,f){\n  if (typeof exports == 'object' && typeof module != \"undefined\") {\n    f(exports)\n  } else if (typeof define == 'function' && define.amd) {\n    define([\"exports\"], f)\n  } else {\n    f((g = g || self)[\"lru_map\"] = (g[\"lru_map\"] || {}))\n  }\n}(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nclass LRUMap {\n  constructor(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  _markEntryAsUsed(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  }\n\n  assign(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  }\n\n  get(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  }\n\n  set(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  }\n\n  shift() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }\n\n  // -------------------------------------------------------------------------------------\n  // Following code (until end of class definition) is optional and can be removed without\n  // breaking the core functionality.\n\n  find(key) {\n    let e = this._keymap.get(key);\n    return e ? e.value : undefined;\n  }\n\n  has(key) {\n    return this._keymap.has(key);\n  }\n\n  delete(key) {\n    var entry = this._keymap.get(key);\n    if (!entry) return;\n    this._keymap.delete(entry.key);\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined;\n      // link the newer entry to head\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined;\n      // link the newer entry to head\n      this.newest = entry[OLDER];\n    } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  }\n\n  clear() {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this._keymap.clear();\n  }\n\n  keys() {\n    return new KeyIterator(this.oldest);\n  }\n\n  values() {\n    return new ValueIterator(this.oldest);\n  }\n\n  entries() {\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return new EntryIterator(this.oldest);\n  }\n\n  forEach(fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n    let entry = this.oldest;\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  }\n\n  /** Returns a JSON (array) representation */\n  toJSON() {\n    var s = new Array(this.size), i = 0, entry = this.oldest;\n    while (entry) {\n      s[i++] = { key: entry.key, value: entry.value };\n      entry = entry[NEWER];\n    }\n    return s;\n  }\n\n  /** Returns a String representation */\n  toString() {\n    var s = '', entry = this.oldest;\n    while (entry) {\n      s += String(entry.key)+':'+entry.value;\n      entry = entry[NEWER];\n      if (entry) {\n        s += ' < ';\n      }\n    }\n    return s;\n  }\n}\n\nexports.LRUMap = LRUMap\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n});\n", "import { LRUMap } from 'lru_map';\n\nimport { DEFAULT_THEMES } from '../constants';\nimport { getResolvedLanguages } from '../highlighter/languages/getResolvedLanguages';\nimport { hasResolvedLanguages } from '../highlighter/languages/hasResolvedLanguages';\nimport { resolveLanguages } from '../highlighter/languages/resolveLanguages';\nimport { getSharedHighlighter } from '../highlighter/shared_highlighter';\nimport { attachResolvedThemes } from '../highlighter/themes/attachResolvedThemes';\nimport { getResolvedThemes } from '../highlighter/themes/getResolvedThemes';\nimport { hasResolvedThemes } from '../highlighter/themes/hasResolvedThemes';\nimport { resolveThemes } from '../highlighter/themes/resolveThemes';\nimport type {\n  DiffsHighlighter,\n  FileContents,\n  FileDiffMetadata,\n  RenderDiffOptions,\n  RenderDiffResult,\n  RenderFileOptions,\n  RenderFileResult,\n  SupportedLanguages,\n  ThemeRegistrationResolved,\n  ThemedDiffResult,\n  ThemedFileResult,\n} from '../types';\nimport { areThemesEqual } from '../utils/areThemesEqual';\nimport { getFiletypeFromFileName } from '../utils/getFiletypeFromFileName';\nimport { getThemes } from '../utils/getThemes';\nimport { renderDiffWithHighlighter } from '../utils/renderDiffWithHighlighter';\nimport { renderFileWithHighlighter } from '../utils/renderFileWithHighlighter';\nimport type {\n  AllWorkerTasks,\n  DiffRendererInstance,\n  FileRendererInstance,\n  InitializeWorkerTask,\n  RenderDiffRequest,\n  RenderDiffTask,\n  RenderFileRequest,\n  RenderFileTask,\n  ResolvedLanguage,\n  SetRenderOptionsWorkerTask,\n  SubmitRequest,\n  WorkerInitializationRenderOptions,\n  WorkerPoolOptions,\n  WorkerRenderingOptions,\n  WorkerRequestId,\n  WorkerResponse,\n  WorkerStats,\n} from './types';\n\nconst IGNORE_RESPONSE = Symbol('IGNORE_RESPONSE');\n\ninterface GetCachesResult {\n  fileCache: LRUMap<string, RenderFileResult>;\n  diffCache: LRUMap<string, RenderDiffResult>;\n}\n\ninterface ManagedWorker {\n  worker: Worker;\n  busy: boolean;\n  initialized: boolean;\n  langs: Set<SupportedLanguages>;\n}\n\ninterface ThemeSubscriber {\n  rerender(): void;\n}\n\nexport class WorkerPoolManager {\n  private highlighter: DiffsHighlighter | undefined;\n  private renderOptions: WorkerRenderingOptions;\n  private initialized: Promise<void> | boolean = false;\n  private workers: ManagedWorker[] = [];\n  private taskQueue: AllWorkerTasks[] = [];\n  private pendingTasks = new Map<WorkerRequestId, AllWorkerTasks>();\n  private nextRequestId = 0;\n  private themeSubscribers = new Set<ThemeSubscriber>();\n  private workersFailed = false;\n  private instanceRequestMap = new Map<\n    FileRendererInstance | DiffRendererInstance,\n    string\n  >();\n  private fileCache: LRUMap<string, RenderFileResult>;\n  private diffCache: LRUMap<string, RenderDiffResult>;\n\n  constructor(\n    private options: WorkerPoolOptions,\n    {\n      langs,\n      theme = DEFAULT_THEMES,\n      lineDiffType = 'word-alt',\n      tokenizeMaxLineLength = 1000,\n    }: WorkerInitializationRenderOptions\n  ) {\n    this.renderOptions = { theme, lineDiffType, tokenizeMaxLineLength };\n    this.fileCache = new LRUMap(options.totalASTLRUCacheSize ?? 100);\n    this.diffCache = new LRUMap(options.totalASTLRUCacheSize ?? 100);\n    void this.initialize(langs);\n  }\n\n  isWorkingPool(): boolean {\n    return !this.workersFailed;\n  }\n\n  getFileResultCache(file: FileContents): RenderFileResult | undefined {\n    return file.cacheKey != null\n      ? this.fileCache.get(file.cacheKey)\n      : undefined;\n  }\n\n  getDiffResultCache(diff: FileDiffMetadata): RenderDiffResult | undefined {\n    return diff.cacheKey != null\n      ? this.diffCache.get(diff.cacheKey)\n      : undefined;\n  }\n\n  inspectCaches(): GetCachesResult {\n    const { fileCache, diffCache } = this;\n    return { fileCache, diffCache };\n  }\n\n  evictFileFromCache(cacheKey: string): boolean {\n    return this.fileCache.delete(cacheKey) !== undefined;\n  }\n\n  evictDiffFromCache(cacheKey: string): boolean {\n    return this.diffCache.delete(cacheKey) !== undefined;\n  }\n\n  async setRenderOptions({\n    theme = DEFAULT_THEMES,\n    lineDiffType = 'word-alt',\n    tokenizeMaxLineLength = 1000,\n  }: Partial<WorkerRenderingOptions>): Promise<void> {\n    const newRenderOptions: WorkerRenderingOptions = {\n      theme,\n      lineDiffType,\n      tokenizeMaxLineLength,\n    };\n    if (!this.isInitialized()) {\n      await this.initialize();\n    }\n    const themesEqual = areThemesEqual(\n      newRenderOptions.theme,\n      this.renderOptions.theme\n    );\n    if (\n      themesEqual &&\n      newRenderOptions.lineDiffType === this.renderOptions.lineDiffType &&\n      newRenderOptions.tokenizeMaxLineLength ===\n        this.renderOptions.tokenizeMaxLineLength\n    ) {\n      return;\n    }\n\n    const themeNames = getThemes(theme);\n    let resolvedThemes: ThemeRegistrationResolved[] = [];\n    if (!themesEqual) {\n      if (hasResolvedThemes(themeNames)) {\n        resolvedThemes = getResolvedThemes(themeNames);\n      } else {\n        resolvedThemes = await resolveThemes(themeNames);\n      }\n    }\n\n    if (this.highlighter != null) {\n      attachResolvedThemes(resolvedThemes, this.highlighter);\n      await this.setRenderOptionsOnWorkers(newRenderOptions, resolvedThemes);\n    } else {\n      const [highlighter] = await Promise.all([\n        getSharedHighlighter({ themes: themeNames, langs: ['text'] }),\n        this.setRenderOptionsOnWorkers(newRenderOptions, resolvedThemes),\n      ]);\n      this.highlighter = highlighter;\n    }\n\n    this.renderOptions = newRenderOptions;\n    this.diffCache.clear();\n    this.fileCache.clear();\n\n    for (const instance of this.themeSubscribers) {\n      instance.rerender();\n    }\n  }\n\n  getFileRenderOptions(): RenderFileOptions {\n    const { tokenizeMaxLineLength, theme } = this.renderOptions;\n    return { theme, tokenizeMaxLineLength };\n  }\n\n  getDiffRenderOptions(): RenderDiffOptions {\n    return { ...this.renderOptions };\n  }\n\n  private async setRenderOptionsOnWorkers(\n    renderOptions: WorkerRenderingOptions,\n    resolvedThemes: ThemeRegistrationResolved[]\n  ): Promise<void> {\n    if (this.workersFailed) {\n      return;\n    }\n    if (!this.isInitialized()) {\n      await this.initialize();\n    }\n    const taskPromises: Promise<void>[] = [];\n    for (const managedWorker of this.workers) {\n      if (!managedWorker.initialized) {\n        console.log({ managedWorker });\n        throw new Error(\n          'setRenderOptionsOnWorkers: Somehow we have an uninitialized worker'\n        );\n      }\n      taskPromises.push(\n        new Promise<void>((resolve, reject) => {\n          const id = this.generateRequestId();\n          const task: SetRenderOptionsWorkerTask = {\n            type: 'set-render-options',\n            id,\n            request: {\n              type: 'set-render-options',\n              id,\n              renderOptions,\n              resolvedThemes,\n            },\n            resolve,\n            reject,\n            requestStart: Date.now(),\n          };\n          this.pendingTasks.set(id, task);\n          managedWorker.worker.postMessage(task.request);\n        })\n      );\n    }\n    await Promise.all(taskPromises);\n  }\n\n  subscribeToThemeChanges(instance: ThemeSubscriber): () => void {\n    this.themeSubscribers.add(instance);\n    return () => {\n      this.unsubscribeToThemeChanges(instance);\n    };\n  }\n\n  unsubscribeToThemeChanges(instance: ThemeSubscriber): void {\n    this.themeSubscribers.delete(instance);\n  }\n\n  isInitialized(): boolean {\n    return this.initialized === true;\n  }\n\n  async initialize(languages: SupportedLanguages[] = []): Promise<void> {\n    if (this.initialized === true) {\n      return;\n    } else if (this.initialized === false) {\n      this.initialized = new Promise((resolve, reject) => {\n        void (async () => {\n          try {\n            const themes = getThemes(this.renderOptions.theme);\n            let resolvedThemes: ThemeRegistrationResolved[] = [];\n            if (hasResolvedThemes(themes)) {\n              resolvedThemes = getResolvedThemes(themes);\n            } else {\n              resolvedThemes = await resolveThemes(themes);\n            }\n\n            let resolvedLanguages: ResolvedLanguage[] = [];\n            if (hasResolvedLanguages(languages)) {\n              resolvedLanguages = getResolvedLanguages(languages);\n            } else {\n              resolvedLanguages = await resolveLanguages(languages);\n            }\n\n            const [highlighter] = await Promise.all([\n              getSharedHighlighter({ themes, langs: ['text', ...languages] }),\n              this.initializeWorkers(resolvedThemes, resolvedLanguages),\n            ]);\n\n            // If we were terminated while initializing, we should probably kill\n            // any workers that may have been created\n            if (this.initialized === false) {\n              this.terminateWorkers();\n              reject();\n              return;\n            }\n            this.highlighter = highlighter;\n            this.initialized = true;\n            this.diffCache.clear();\n            this.fileCache.clear();\n            this.drainQueue();\n            resolve();\n          } catch (e) {\n            this.initialized = false;\n            this.workersFailed = true;\n            reject(e);\n          }\n        })();\n      });\n    } else {\n      return this.initialized;\n    }\n  }\n\n  private async initializeWorkers(\n    resolvedThemes: ThemeRegistrationResolved[],\n    resolvedLanguages: ResolvedLanguage[]\n  ): Promise<void> {\n    this.workersFailed = false;\n    const initPromises: Promise<unknown>[] = [];\n    if (this.workers.length > 0) {\n      this.terminateWorkers();\n    }\n    for (let i = 0; i < (this.options.poolSize ?? 8); i++) {\n      const worker = this.options.workerFactory();\n      const managedWorker: ManagedWorker = {\n        worker,\n        busy: false,\n        initialized: false,\n        langs: new Set(['text', ...resolvedLanguages.map(({ name }) => name)]),\n      };\n      worker.addEventListener(\n        'message',\n        (event: MessageEvent<WorkerResponse>) => {\n          this.handleWorkerMessage(managedWorker, event.data);\n        }\n      );\n      worker.addEventListener('error', (error) =>\n        console.error('Worker error:', error, managedWorker)\n      );\n      this.workers.push(managedWorker);\n      initPromises.push(\n        new Promise<void>((resolve, reject) => {\n          const id = this.generateRequestId();\n          const task: InitializeWorkerTask = {\n            type: 'initialize',\n            id,\n            request: {\n              type: 'initialize',\n              id,\n              renderOptions: this.renderOptions,\n              resolvedThemes,\n              resolvedLanguages,\n            },\n            resolve() {\n              managedWorker.initialized = true;\n              resolve();\n            },\n            reject,\n            requestStart: Date.now(),\n          };\n          this.pendingTasks.set(id, task);\n          this.executeTask(managedWorker, task);\n        })\n      );\n    }\n    await Promise.all(initPromises);\n  }\n\n  private drainQueue = () => {\n    this._queuedDrain = undefined;\n    // If we are initializing or things got cancelled while initializing, we\n    // should not attempt to drain the queue\n    if (this.initialized !== true || this.taskQueue.length === 0) {\n      return;\n    }\n    while (this.taskQueue.length > 0) {\n      const task = this.taskQueue[0];\n      const langs = getLangsFromTask(task);\n      const availableWorker = this.getAvailableWorker(langs);\n      if (availableWorker == null) {\n        break;\n      }\n      this.taskQueue.shift();\n      void this.resolveLanguagesAndExecuteTask(availableWorker, task, langs);\n    }\n  };\n\n  highlightFileAST(instance: FileRendererInstance, file: FileContents): void {\n    this.submitTask(instance, { type: 'file', file });\n  }\n\n  getPlainFileAST(file: FileContents): ThemedFileResult | undefined {\n    if (this.highlighter == null) {\n      void this.initialize();\n      return undefined;\n    }\n    return renderFileWithHighlighter(\n      file,\n      this.highlighter,\n      this.renderOptions,\n      true\n    );\n  }\n\n  highlightDiffAST(\n    instance: DiffRendererInstance,\n    diff: FileDiffMetadata\n  ): void {\n    this.submitTask(instance, { type: 'diff', diff });\n  }\n\n  getPlainDiffAST(diff: FileDiffMetadata): ThemedDiffResult | undefined {\n    return this.highlighter != null\n      ? renderDiffWithHighlighter(\n          diff,\n          this.highlighter,\n          this.renderOptions,\n          true\n        )\n      : undefined;\n  }\n\n  terminate(): void {\n    this.terminateWorkers();\n    this.fileCache.clear();\n    this.diffCache.clear();\n    this.instanceRequestMap.clear();\n    this.taskQueue.length = 0;\n    this.pendingTasks.clear();\n    this.highlighter = undefined;\n    this.initialized = false;\n    this.workersFailed = false;\n  }\n\n  private terminateWorkers() {\n    for (const managedWorker of this.workers) {\n      managedWorker.worker.terminate();\n    }\n    this.workers.length = 0;\n  }\n\n  getStats(): WorkerStats {\n    return {\n      totalWorkers: this.workers.length,\n      busyWorkers: this.workers.filter((w) => w.busy).length,\n      queuedTasks: this.taskQueue.length,\n      pendingTasks: this.pendingTasks.size,\n    };\n  }\n\n  private submitTask(\n    instance: FileRendererInstance,\n    request: Omit<RenderFileRequest, 'id'>\n  ): void;\n  private submitTask(\n    instance: DiffRendererInstance,\n    request: Omit<RenderDiffRequest, 'id'>\n  ): void;\n  private submitTask(\n    instance: FileRendererInstance | DiffRendererInstance,\n    request: SubmitRequest\n  ): void {\n    if (this.initialized === false) {\n      void this.initialize();\n    }\n\n    const id = this.generateRequestId();\n    const requestStart = Date.now();\n    const task: RenderFileTask | RenderDiffTask = (() => {\n      switch (request.type) {\n        case 'file':\n          return {\n            type: 'file',\n            id,\n            request: { ...request, id },\n            instance: instance as FileRendererInstance,\n            requestStart,\n          };\n        case 'diff':\n          return {\n            type: 'diff',\n            id,\n            request: { ...request, id },\n            instance: instance as DiffRendererInstance,\n            requestStart,\n          };\n      }\n    })();\n\n    this.instanceRequestMap.set(instance, id);\n    this.taskQueue.push(task);\n    this.queueDrain();\n  }\n\n  private async resolveLanguagesAndExecuteTask(\n    availableWorker: ManagedWorker,\n    task: AllWorkerTasks,\n    langs: SupportedLanguages[]\n  ): Promise<void> {\n    // Add resolved languages if required\n    if (task.type === 'file' || task.type === 'diff') {\n      const workerMissingLangs = langs.filter(\n        (lang) => !availableWorker.langs.has(lang)\n      );\n\n      if (workerMissingLangs.length > 0) {\n        if (hasResolvedLanguages(workerMissingLangs)) {\n          task.request.resolvedLanguages =\n            getResolvedLanguages(workerMissingLangs);\n        } else {\n          task.request.resolvedLanguages =\n            await resolveLanguages(workerMissingLangs);\n        }\n      }\n    }\n    this.executeTask(availableWorker, task);\n  }\n\n  private handleWorkerMessage(\n    managedWorker: ManagedWorker,\n    response: WorkerResponse\n  ): void {\n    const task = this.pendingTasks.get(response.id);\n    try {\n      if (task == null) {\n        throw new Error(\n          'handleWorkerMessage: Received response for unknown task'\n        );\n      } else if (response.type === 'error') {\n        const error = new Error(response.error);\n        if (response.stack) {\n          error.stack = response.stack;\n        }\n        if ('reject' in task) {\n          task.reject(error);\n        } else {\n          task.instance.onHighlightError(error);\n        }\n        throw error;\n      } else {\n        // If we've gotten a newer request from the same instance, we should\n        // ignore this response either because it's out of order or because we\n        // have a newer more important request\n        if (\n          'instance' in task &&\n          this.instanceRequestMap.get(task.instance) !== response.id\n        ) {\n          throw IGNORE_RESPONSE;\n        }\n        switch (response.requestType) {\n          case 'initialize':\n            if (task.type !== 'initialize') {\n              throw new Error('handleWorkerMessage: task/response dont match');\n            }\n            task.resolve();\n            break;\n          case 'set-render-options':\n            if (task.type !== 'set-render-options') {\n              throw new Error('handleWorkerMessage: task/response dont match');\n            }\n            task.resolve();\n            break;\n          case 'file': {\n            if (task.type !== 'file') {\n              throw new Error('handleWorkerMessage: task/response dont match');\n            }\n            const { result, options } = response;\n            const { instance, request } = task;\n            if (request.file.cacheKey != null) {\n              this.fileCache.set(request.file.cacheKey, { result, options });\n            }\n            instance.onHighlightSuccess(request.file, result, options);\n            break;\n          }\n          case 'diff': {\n            if (task.type !== 'diff') {\n              throw new Error('handleWorkerMessage: task/response dont match');\n            }\n            const { result, options } = response;\n            const { instance, request } = task;\n            if (request.diff.cacheKey != null) {\n              this.diffCache.set(request.diff.cacheKey, { result, options });\n            }\n            instance.onHighlightSuccess(request.diff, result, options);\n            break;\n          }\n        }\n      }\n    } catch (error) {\n      if (error !== IGNORE_RESPONSE) {\n        console.error(error, task, response);\n      }\n    }\n\n    if (\n      task != null &&\n      'instance' in task &&\n      this.instanceRequestMap.get(task.instance) === response.id\n    ) {\n      this.instanceRequestMap.delete(task.instance);\n    }\n    this.pendingTasks.delete(response.id);\n    managedWorker.busy = false;\n    if (this.taskQueue.length > 0) {\n      // We queue drain so that potentially multiple workers can free up\n      // allowing for better language matches if possible\n      this.queueDrain();\n    }\n  }\n\n  private _queuedDrain: Promise<void> | undefined;\n  private queueDrain() {\n    if (this._queuedDrain != null) return;\n    this._queuedDrain = Promise.resolve().then(this.drainQueue);\n  }\n\n  private executeTask(\n    managedWorker: ManagedWorker,\n    task: AllWorkerTasks\n  ): void {\n    managedWorker.busy = true;\n    this.pendingTasks.set(task.id, task);\n    for (const lang of getLangsFromTask(task)) {\n      managedWorker.langs.add(lang);\n    }\n    managedWorker.worker.postMessage(task.request);\n  }\n\n  private getAvailableWorker(\n    langs: SupportedLanguages[]\n  ): ManagedWorker | undefined {\n    let worker: ManagedWorker | undefined;\n    for (const managedWorker of this.workers) {\n      if (managedWorker.busy || !managedWorker.initialized) {\n        continue;\n      }\n      worker = managedWorker;\n      if (langs.length === 0) {\n        break;\n      }\n      let hasEveryLang = true;\n      for (const lang of langs) {\n        if (!managedWorker.langs.has(lang)) {\n          hasEveryLang = false;\n          break;\n        }\n      }\n      if (hasEveryLang) {\n        break;\n      }\n    }\n    return worker;\n  }\n\n  private generateRequestId(): WorkerRequestId {\n    return `req_${++this.nextRequestId}`;\n  }\n}\n\nfunction getLangsFromTask(task: AllWorkerTasks): SupportedLanguages[] {\n  const langs = new Set<SupportedLanguages>();\n  if (task.type === 'initialize' || task.type === 'set-render-options') {\n    return [];\n  }\n  switch (task.type) {\n    case 'file': {\n      langs.add(\n        task.request.file.lang ??\n          getFiletypeFromFileName(task.request.file.name)\n      );\n      break;\n    }\n    case 'diff': {\n      langs.add(\n        task.request.diff.lang ??\n          getFiletypeFromFileName(task.request.diff.name)\n      );\n      langs.add(\n        task.request.diff.lang ??\n          getFiletypeFromFileName(task.request.diff.prevName ?? '-')\n      );\n      break;\n    }\n  }\n  langs.delete('text');\n  return Array.from(langs);\n}\n", "import { WorkerPoolManager } from './WorkerPoolManager';\nimport type {\n  WorkerInitializationRenderOptions,\n  WorkerPoolOptions,\n} from './types';\n\nlet workerPoolSingletone: WorkerPoolManager | undefined;\n\nexport interface SetupWorkerPoolProps {\n  poolOptions: WorkerPoolOptions;\n  highlighterOptions: WorkerInitializationRenderOptions;\n}\n\nexport function getOrCreateWorkerPoolSingleton({\n  poolOptions,\n  highlighterOptions,\n}: SetupWorkerPoolProps): WorkerPoolManager {\n  if (workerPoolSingletone == null) {\n    workerPoolSingletone = new WorkerPoolManager(\n      poolOptions,\n      highlighterOptions\n    );\n    void workerPoolSingletone.initialize();\n  }\n  return workerPoolSingletone;\n}\n\nexport function terminateWorkerPoolSingleton(): void {\n  if (workerPoolSingletone == null) {\n    return;\n  }\n  workerPoolSingletone.terminate();\n  workerPoolSingletone = undefined;\n}\n"],
  "mappings": "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",
  "names": ["options: WorkerPoolOptions", "newRenderOptions: WorkerRenderingOptions", "resolvedThemes: ThemeRegistrationResolved[]", "taskPromises: Promise<void>[]", "task: SetRenderOptionsWorkerTask", "resolvedLanguages: ResolvedLanguage[]", "initPromises: Promise<unknown>[]", "managedWorker: ManagedWorker", "task: InitializeWorkerTask", "task: RenderFileTask | RenderDiffTask", "worker: ManagedWorker | undefined", "workerPoolSingletone: WorkerPoolManager | undefined"]
}
