import {
  ALTERNATE_FILE_NAMES_GIT,
  AttachedLanguages,
  AttachedThemes,
  COMMIT_METADATA_SPLIT,
  CORE_CSS_ATTRIBUTE,
  DEFAULT_THEMES,
  DIFFS_TAG_NAME,
  EXTENSION_TO_FILE_FORMAT,
  FILENAME_HEADER_REGEX,
  FILENAME_HEADER_REGEX_GIT,
  FILE_CONTEXT_BLOB,
  FILE_MODE_FROM_INDEX,
  GIT_DIFF_FILE_BREAK_REGEX,
  HEADER_METADATA_SLOT_ID,
  HUNK_HEADER,
  RegisteredCustomThemes,
  ResolvedLanguages,
  ResolvedThemes,
  ResolvingLanguages,
  ResolvingThemes,
  SPLIT_WITH_NEWLINES,
  UNIFIED_DIFF_FILE_BREAK_REGEX,
  UNSAFE_CSS_ATTRIBUTE,
  areThemesEqual,
  attachResolvedLanguages,
  attachResolvedThemes,
  cleanLastNewline,
  cleanUpResolvedLanguages,
  cleanUpResolvedThemes,
  codeToHtml,
  createDiffSpanDecoration,
  createHastElement,
  createIconElement,
  createTextNodeElement,
  createTransformerWithState,
  createTwoFilesPatch,
  disposeHighlighter,
  extendFileFormatMap,
  findCodeElement,
  formatCSSVariablePrefix,
  getFiletypeFromFileName,
  getHighlighterIfLoaded,
  getHighlighterThemeStyles,
  getLineNodes,
  getResolvedLanguages,
  getResolvedOrResolveLanguage,
  getResolvedOrResolveTheme,
  getResolvedThemes,
  getSharedHighlighter,
  getThemes,
  getTokenStyleObject,
  hasResolvedLanguages,
  hasResolvedThemes,
  isHighlighterLoaded,
  isHighlighterLoading,
  isHighlighterNull,
  isWorkerContext,
  preloadHighlighter,
  processLine,
  pushOrJoinSpan,
  registerCustomTheme,
  renderDiffWithHighlighter,
  renderFileWithHighlighter,
  resolveLanguage,
  resolveLanguages,
  resolveTheme,
  resolveThemes,
  stringifyTokenStyle
} from "./chunk-34OTWCE7.js";
import {
  toHtml
} from "./chunk-2WHVLGAD.js";
import "./chunk-G3PMV62Z.js";

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/areSelectionsEqual.js
function areSelectionsEqual(selectionA, selectionB) {
  return selectionA?.start === selectionB?.start && selectionA?.end === selectionB?.end && selectionA?.side === selectionB?.side && selectionA?.endSide === selectionB?.endSide;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/managers/LineSelectionManager.js
var LineSelectionManager = class {
  pre;
  selectedRange = null;
  renderedSelectionRange;
  anchor;
  _queuedRender;
  constructor(options = {}) {
    this.options = options;
  }
  setOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
    this.removeEventListeners();
    if (this.options.enableLineSelection === true) this.attachEventListeners();
  }
  cleanUp() {
    this.removeEventListeners();
    if (this._queuedRender != null) {
      cancelAnimationFrame(this._queuedRender);
      this._queuedRender = void 0;
    }
    if (this.pre != null) delete this.pre.dataset.interactiveLineNumbers;
    this.pre = void 0;
  }
  setup(pre) {
    this.setDirty();
    if (this.pre !== pre) this.cleanUp();
    this.pre = pre;
    const { enableLineSelection = false } = this.options;
    if (enableLineSelection) {
      this.pre.dataset.interactiveLineNumbers = "";
      this.attachEventListeners();
    } else {
      this.removeEventListeners();
      delete this.pre.dataset.interactiveLineNumbers;
    }
    this.setSelection(this.selectedRange);
  }
  setDirty() {
    this.renderedSelectionRange = void 0;
  }
  isDirty() {
    return this.renderedSelectionRange === void 0;
  }
  setSelection(range) {
    const isRangeChange = !(range === this.selectedRange || areSelectionsEqual(range ?? void 0, this.selectedRange ?? void 0));
    if (!this.isDirty() && !isRangeChange) return;
    this.selectedRange = range;
    this.renderSelection();
    if (isRangeChange) this.notifySelectionChange();
  }
  getSelection() {
    return this.selectedRange;
  }
  attachEventListeners() {
    if (this.pre == null) return;
    this.removeEventListeners();
    this.pre.addEventListener("mousedown", this.handleMouseDown);
  }
  removeEventListeners() {
    if (this.pre == null) return;
    this.pre.removeEventListener("mousedown", this.handleMouseDown);
    document.removeEventListener("mousemove", this.handleMouseMove);
    document.removeEventListener("mouseup", this.handleMouseUp);
  }
  handleMouseDown = (event) => {
    const mouseEventData = event.button === 0 ? this.getMouseEventDataForPath(event.composedPath(), "click") : void 0;
    if (mouseEventData == null) return;
    event.preventDefault();
    const { lineNumber, eventSide, lineIndex } = mouseEventData;
    if (event.shiftKey && this.selectedRange != null) {
      const range = this.deriveRowRangeFromDOM(this.selectedRange, this.pre?.dataset.type === "split");
      if (range == null) return;
      const useStart = range.start <= range.end ? lineIndex >= range.start : lineIndex <= range.end;
      this.anchor = {
        line: useStart ? this.selectedRange.start : this.selectedRange.end,
        side: (useStart ? this.selectedRange.side : this.selectedRange.endSide ?? this.selectedRange.side) ?? "additions"
      };
      this.updateSelection(lineNumber, eventSide);
      this.notifySelectionStart(this.selectedRange);
    } else {
      if (this.selectedRange?.start === lineNumber && this.selectedRange?.end === lineNumber) {
        this.updateSelection(null);
        this.notifySelectionEnd(null);
        this.notifySelectionChange();
        return;
      }
      this.selectedRange = null;
      this.anchor = {
        line: lineNumber,
        side: eventSide
      };
      this.updateSelection(lineNumber, eventSide);
      this.notifySelectionStart(this.selectedRange);
    }
    document.addEventListener("mousemove", this.handleMouseMove);
    document.addEventListener("mouseup", this.handleMouseUp);
  };
  handleMouseMove = (event) => {
    const mouseEventData = this.getMouseEventDataForPath(event.composedPath(), "move");
    if (mouseEventData == null || this.anchor == null) return;
    const { lineNumber, eventSide } = mouseEventData;
    this.updateSelection(lineNumber, eventSide);
  };
  handleMouseUp = () => {
    this.anchor = void 0;
    document.removeEventListener("mousemove", this.handleMouseMove);
    document.removeEventListener("mouseup", this.handleMouseUp);
    this.notifySelectionEnd(this.selectedRange);
    this.notifySelectionChange();
  };
  updateSelection(currentLine, side) {
    if (currentLine == null) this.selectedRange = null;
    else {
      const anchorSide = this.anchor?.side ?? side;
      this.selectedRange = {
        start: this.anchor?.line ?? currentLine,
        end: currentLine,
        side: anchorSide,
        endSide: anchorSide !== side ? side : void 0
      };
    }
    this._queuedRender ??= requestAnimationFrame(this.renderSelection);
  }
  renderSelection = () => {
    if (this._queuedRender != null) {
      cancelAnimationFrame(this._queuedRender);
      this._queuedRender = void 0;
    }
    if (this.pre == null || this.renderedSelectionRange === this.selectedRange) return;
    const allSelected = this.pre.querySelectorAll("[data-selected-line]");
    for (const element of allSelected) element.removeAttribute("data-selected-line");
    this.renderedSelectionRange = this.selectedRange;
    if (this.selectedRange == null) return;
    const codeElements = this.pre.querySelectorAll("[data-code]");
    if (codeElements.length === 0) return;
    if (codeElements.length > 2) {
      console.error(codeElements);
      throw new Error("LineSelectionManager.applySelectionToDOM: Somehow there are more than 2 code elements...");
    }
    const split = this.pre.dataset.type === "split";
    const rowRange = this.deriveRowRangeFromDOM(this.selectedRange, split);
    if (rowRange == null) {
      console.error({
        rowRange,
        selectedRange: this.selectedRange
      });
      throw new Error("LineSelectionManager.renderSelection: No valid rowRange");
    }
    const isSingle = rowRange.start === rowRange.end;
    const first = Math.min(rowRange.start, rowRange.end);
    const last = Math.max(rowRange.start, rowRange.end);
    for (const code of codeElements) for (const element of code.children) {
      if (!(element instanceof HTMLElement)) continue;
      const lineIndex = this.getLineIndex(element, split);
      if ((lineIndex ?? 0) > last) break;
      if (lineIndex == null || lineIndex < first) continue;
      let attributeValue = isSingle ? "single" : lineIndex === first ? "first" : lineIndex === last ? "last" : "";
      element.setAttribute("data-selected-line", attributeValue);
      if (element.nextSibling instanceof HTMLElement && element.nextSibling.hasAttribute("data-line-annotation")) {
        if (isSingle) {
          attributeValue = "last";
          element.setAttribute("data-selected-line", "first");
        } else if (lineIndex === first) attributeValue = "";
        else if (lineIndex === last) element.setAttribute("data-selected-line", "");
        element.nextSibling.setAttribute("data-selected-line", attributeValue);
      }
    }
  };
  deriveRowRangeFromDOM(range, split) {
    if (range == null) return void 0;
    const start = this.findRowIndexForLineNumber(range.start, range.side, split);
    const end = range.end === range.start && (range.endSide == null || range.endSide === range.side) ? start : this.findRowIndexForLineNumber(range.end, range.endSide ?? range.side, split);
    return start != null && end != null ? {
      start,
      end
    } : void 0;
  }
  findRowIndexForLineNumber(lineNumber, targetSide = "additions", split) {
    if (this.pre == null) return void 0;
    const elements = Array.from(this.pre.querySelectorAll(`[data-line="${lineNumber}"]`));
    elements.push(...Array.from(this.pre.querySelectorAll(`[data-alt-line="${lineNumber}"]`)));
    if (elements.length === 0) return void 0;
    for (const element of elements) {
      if (!(element instanceof HTMLElement)) continue;
      if (this.getLineSideFromElement(element) === targetSide) return this.getLineIndex(element, split);
      else if (parseInt(element.dataset.altLine ?? "") === lineNumber) return this.getLineIndex(element, split);
    }
    console.error("LineSelectionManager.findRowIndexForLineNumber: Invalid selection", lineNumber, targetSide);
  }
  notifySelectionChange() {
    const { onLineSelected } = this.options;
    if (onLineSelected == null) return;
    onLineSelected(this.selectedRange ?? null);
  }
  notifySelectionStart(range) {
    const { onLineSelectionStart } = this.options;
    if (onLineSelectionStart == null) return;
    onLineSelectionStart(range);
  }
  notifySelectionEnd(range) {
    const { onLineSelectionEnd } = this.options;
    if (onLineSelectionEnd == null) return;
    onLineSelectionEnd(range);
  }
  getMouseEventDataForPath(path, eventType) {
    let lineNumber;
    let lineIndex;
    let isNumberColumn = false;
    let eventSide;
    for (const element of path) {
      if (!(element instanceof HTMLElement)) continue;
      if (element.hasAttribute("data-column-number")) {
        isNumberColumn = true;
        continue;
      }
      if (element.hasAttribute("data-line")) {
        lineNumber = this.getLineNumber(element);
        lineIndex = this.getLineIndex(element, this.pre?.dataset.type === "split");
        if (element.dataset.lineType === "change-deletion") eventSide = "deletions";
        else if (element.dataset.lineType === "change-additions") eventSide = "additions";
        if (lineIndex == null || lineNumber == null) {
          lineIndex = void 0;
          lineNumber = void 0;
          break;
        }
        if (eventSide != null) break;
        continue;
      }
      if (element.hasAttribute("data-code")) {
        eventSide ??= element.hasAttribute("data-deletions") ? "deletions" : "additions";
        break;
      }
    }
    if (eventType === "click" && !isNumberColumn || lineIndex == null || lineNumber == null) return;
    return {
      lineIndex,
      lineNumber,
      eventSide: eventSide ?? "additions"
    };
  }
  getLineNumber(element) {
    const lineNumber = parseInt(element.dataset.line ?? "", 10);
    return !Number.isNaN(lineNumber) ? lineNumber : void 0;
  }
  getLineIndex(element, split) {
    const lineIndexes = (element.dataset.lineIndex ?? "").split(",").map((value) => parseInt(value)).filter((value) => !Number.isNaN(value));
    if (split && lineIndexes.length === 2) return lineIndexes[1];
    else if (!split) return lineIndexes[0];
  }
  getLineSideFromElement(element) {
    if (element.dataset.lineType === "change-deletion") return "deletions";
    if (element.dataset.lineType === "change-addition") return "additions";
    const parent = element.closest("[data-code]");
    if (!(parent instanceof HTMLElement)) return "additions";
    return parent.hasAttribute("data-deletions") ? "deletions" : "additions";
  }
};
function pluckLineSelectionOptions({ enableLineSelection, onLineSelected, onLineSelectionStart, onLineSelectionEnd }) {
  return {
    enableLineSelection,
    onLineSelected,
    onLineSelectionStart,
    onLineSelectionEnd
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/managers/MouseEventManager.js
function isLineEventData(data, mode) {
  if (data == null) return false;
  if (mode === "file") return data.type === "line";
  else return data.type === "diff-line";
}
function isExpandoEventData(data) {
  return data?.type === "line-info";
}
var MouseEventManager = class {
  hoveredLine;
  pre;
  hoverSlot;
  constructor(mode, options) {
    this.mode = mode;
    this.options = options;
  }
  setOptions(options) {
    this.options = options;
  }
  cleanUp() {
    this.pre?.removeEventListener("click", this.handleMouseClick);
    this.pre?.removeEventListener("mousemove", this.handleMouseMove);
    this.pre?.removeEventListener("mouseout", this.handleMouseLeave);
    delete this.pre?.dataset.interactiveLines;
    delete this.pre?.dataset.interactiveLineNumbers;
    this.pre = void 0;
  }
  setup(pre) {
    const { __debugMouseEvents, onLineClick, onLineNumberClick, onLineEnter, onLineLeave, onHunkExpand, enableHoverUtility = false } = this.options;
    this.cleanUp();
    this.pre = pre;
    if (enableHoverUtility && this.hoverSlot == null) {
      this.hoverSlot = document.createElement("div");
      this.hoverSlot.dataset.hoverSlot = "";
      const slotElement = document.createElement("slot");
      slotElement.name = "hover-slot";
      this.hoverSlot.appendChild(slotElement);
    } else if (!enableHoverUtility && this.hoverSlot != null) {
      this.hoverSlot.parentNode?.removeChild(this.hoverSlot);
      this.hoverSlot = void 0;
    }
    if (onLineClick != null || onLineNumberClick != null || onHunkExpand != null) {
      pre.addEventListener("click", this.handleMouseClick);
      if (onLineClick != null) pre.dataset.interactiveLines = "";
      else if (onLineNumberClick != null) pre.dataset.interactiveLineNumbers = "";
      debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.attachEventListeners: Attaching click events for:", (() => {
        const reasons = [];
        if (__debugMouseEvents === "both" || __debugMouseEvents === "click") {
          if (onLineClick != null) reasons.push("onLineClick");
          if (onLineNumberClick != null) reasons.push("onLineNumberClick");
          if (onHunkExpand != null) reasons.push("expandable hunk separators");
        }
        return reasons;
      })());
    }
    if (onLineEnter != null || onLineLeave != null || enableHoverUtility) {
      pre.addEventListener("mousemove", this.handleMouseMove);
      debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.attachEventListeners: Attaching mouse move event");
      pre.addEventListener("mouseleave", this.handleMouseLeave);
      debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.attachEventListeners: Attaching mouse leave event");
    }
  }
  getHoveredLine = () => {
    if (this.hoveredLine != null) {
      if (this.mode === "diff" && this.hoveredLine.type === "diff-line") return {
        lineNumber: this.hoveredLine.lineNumber,
        side: this.hoveredLine.annotationSide
      };
      if (this.mode === "file" && this.hoveredLine.type === "line") return { lineNumber: this.hoveredLine.lineNumber };
    }
  };
  handleMouseClick = (event) => {
    debugLogIfEnabled(this.options.__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseClick:", event);
    this.handleMouseEvent({
      eventType: "click",
      event
    });
  };
  handleMouseMove = (event) => {
    debugLogIfEnabled(this.options.__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseMove:", event);
    this.handleMouseEvent({
      eventType: "move",
      event
    });
  };
  handleMouseLeave = (event) => {
    const { __debugMouseEvents } = this.options;
    debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseLeave: no event");
    if (this.hoveredLine == null) {
      debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseLeave: returned early, no .hoveredLine");
      return;
    }
    this.hoverSlot?.parentElement?.removeChild(this.hoverSlot);
    this.options.onLineLeave?.({
      ...this.hoveredLine,
      event
    });
    this.hoveredLine = void 0;
  };
  handleMouseEvent({ eventType, event }) {
    const { __debugMouseEvents } = this.options;
    const composedPath = event.composedPath();
    debugLogIfEnabled(__debugMouseEvents, eventType, "FileDiff.DEBUG.handleMouseEvent:", {
      eventType,
      composedPath
    });
    const data = this.getLineData(composedPath);
    debugLogIfEnabled(__debugMouseEvents, eventType, "FileDiff.DEBUG.handleMouseEvent: getLineData result:", data);
    const { onLineClick, onLineNumberClick, onLineEnter, onLineLeave, onHunkExpand } = this.options;
    switch (eventType) {
      case "move":
        if (isLineEventData(data, this.mode) && this.hoveredLine?.lineElement === data.lineElement) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', returned early because same line");
          break;
        }
        if (this.hoveredLine != null) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', clearing an existing hovered line and firing onLineLeave");
          this.hoverSlot?.parentElement?.removeChild(this.hoverSlot);
          onLineLeave?.({
            ...this.hoveredLine,
            event
          });
          this.hoveredLine = void 0;
        }
        if (isLineEventData(data, this.mode)) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', setting up a new hoveredLine and firing onLineEnter");
          this.hoveredLine = data;
          if (this.hoverSlot != null) data.numberElement?.appendChild(this.hoverSlot);
          onLineEnter?.({
            ...this.hoveredLine,
            event
          });
        }
        break;
      case "click":
        debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', with data:", data);
        if (data == null) break;
        if (isExpandoEventData(data) && onHunkExpand != null) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', expanding a hunk");
          onHunkExpand(data.hunkIndex, data.direction);
          break;
        }
        if (isLineEventData(data, this.mode)) if (onLineNumberClick != null && data.numberColumn) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', firing 'onLineNumberClick'");
          onLineNumberClick({
            ...data,
            event
          });
        } else if (onLineClick != null) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', firing 'onLineClick'");
          onLineClick({
            ...data,
            event
          });
        } else debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', fell through, no event to fire");
        break;
    }
  }
  getLineData(path) {
    let numberColumn = false;
    const lineElement = path.find((element) => {
      if (!(element instanceof HTMLElement)) return false;
      numberColumn = numberColumn || "columnNumber" in element.dataset;
      return "line" in element.dataset || "expandIndex" in element.dataset;
    });
    if (!(lineElement instanceof HTMLElement)) return void 0;
    if (lineElement.dataset.expandIndex != null) {
      const hunkIndex = parseInt(lineElement.dataset.expandIndex);
      if (isNaN(hunkIndex)) return;
      let direction;
      for (const element of path) {
        if (element === lineElement) break;
        if (element instanceof HTMLElement) {
          direction = direction ?? ("expandUp" in element.dataset ? "up" : void 0) ?? ("expandDown" in element.dataset ? "down" : void 0) ?? ("expandBoth" in element.dataset ? "both" : void 0);
          if (direction != null) break;
        }
      }
      return direction != null ? {
        type: "line-info",
        hunkIndex,
        direction
      } : void 0;
    }
    const lineNumber = parseInt(lineElement.dataset.line ?? "");
    if (isNaN(lineNumber)) return;
    const lineType = lineElement.dataset.lineType;
    if (lineType !== "context" && lineType !== "context-expanded" && lineType !== "change-deletion" && lineType !== "change-addition") return;
    const numberElement = (() => {
      const numberElement$1 = lineElement.children[0];
      return numberElement$1 instanceof HTMLElement && numberElement$1.dataset.columnNumber != null ? numberElement$1 : void 0;
    })();
    if (this.mode === "file") return {
      type: "line",
      lineElement,
      lineNumber,
      numberElement,
      numberColumn
    };
    return {
      type: "diff-line",
      annotationSide: (() => {
        if (lineType === "change-deletion") return "deletions";
        if (lineType === "change-addition") return "additions";
        const parent = lineElement.closest("[data-code]");
        if (!(parent instanceof HTMLElement)) return "additions";
        return "deletions" in parent.dataset ? "deletions" : "additions";
      })(),
      lineType,
      lineElement,
      numberElement,
      lineNumber,
      numberColumn
    };
  }
};
function debugLogIfEnabled(debugLogType = "none", logIfType, ...args) {
  switch (debugLogType) {
    case "none":
      return;
    case "both":
      break;
    case "click":
      if (logIfType !== "click") return;
      break;
    case "move":
      if (logIfType !== "move") return;
      break;
  }
  console.log(...args);
}
function pluckMouseEventOptions({ onLineClick, onLineNumberClick, onLineEnter, onLineLeave, enableHoverUtility, __debugMouseEvents }, onHunkExpand) {
  return {
    onLineClick,
    onLineNumberClick,
    onLineEnter,
    onLineLeave,
    enableHoverUtility,
    __debugMouseEvents,
    onHunkExpand
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/managers/ResizeManager.js
var ResizeManager = class {
  observedNodes = /* @__PURE__ */ new Map();
  cleanUp() {
    this.resizeObserver?.disconnect();
    this.observedNodes.clear();
  }
  resizeObserver;
  setup(pre) {
    this.cleanUp();
    const annotationElements = pre.querySelectorAll('[data-line-annotation*=","]');
    this.resizeObserver ??= new ResizeObserver(this.handleResizeObserver);
    const codeElements = pre.querySelectorAll("code");
    for (const codeElement of codeElements) {
      let numberElement = codeElement.querySelector("[data-column-number]");
      if (!(numberElement instanceof HTMLElement)) numberElement = null;
      const item = {
        type: "code",
        codeElement,
        numberElement,
        codeWidth: "auto",
        numberWidth: 0
      };
      this.observedNodes.set(codeElement, item);
      this.resizeObserver.observe(codeElement);
      if (numberElement != null) {
        this.observedNodes.set(numberElement, item);
        this.resizeObserver.observe(numberElement);
      }
    }
    if (codeElements.length <= 1) return;
    const elementMap = /* @__PURE__ */ new Map();
    for (const element of annotationElements) {
      if (!(element instanceof HTMLElement)) continue;
      const { lineAnnotation = "" } = element.dataset;
      if (!/^\d+,\d+$/.test(lineAnnotation)) {
        console.error("DiffFileRenderer.setupResizeObserver: Invalid element or annotation", {
          lineAnnotation,
          element
        });
        continue;
      }
      let pairs = elementMap.get(lineAnnotation);
      if (pairs == null) {
        pairs = [];
        elementMap.set(lineAnnotation, pairs);
      }
      pairs.push(element);
    }
    for (const [key, pair] of elementMap) {
      if (pair.length !== 2) {
        console.error("DiffFileRenderer.setupResizeObserver: Bad Pair", key, pair);
        continue;
      }
      const [container1, container2] = pair;
      const child1 = container1.firstElementChild;
      const child2 = container2.firstElementChild;
      if (!(container1 instanceof HTMLElement) || !(container2 instanceof HTMLElement) || !(child1 instanceof HTMLElement) || !(child2 instanceof HTMLElement)) continue;
      const item = {
        type: "annotations",
        column1: {
          container: container1,
          child: child1,
          childHeight: 0
        },
        column2: {
          container: container2,
          child: child2,
          childHeight: 0
        },
        currentHeight: "auto"
      };
      this.observedNodes.set(child1, item);
      this.observedNodes.set(child2, item);
      this.resizeObserver.observe(child1);
      this.resizeObserver.observe(child2);
    }
  }
  handleResizeObserver = (entries) => {
    for (const entry of entries) {
      const { target, borderBoxSize } = entry;
      if (!(target instanceof HTMLElement)) {
        console.error("FileDiff.handleResizeObserver: Invalid element for ResizeObserver", entry);
        continue;
      }
      const item = this.observedNodes.get(target);
      if (item == null) {
        console.error("FileDiff.handleResizeObserver: Not a valid observed node", entry);
        continue;
      }
      const specs = borderBoxSize[0];
      if (item.type === "annotations") {
        const column = (() => {
          if (target === item.column1.child) return item.column1;
          if (target === item.column2.child) return item.column2;
        })();
        if (column == null) {
          console.error(`FileDiff.handleResizeObserver: Couldn't find a column for`, {
            item,
            target
          });
          continue;
        }
        column.childHeight = specs.blockSize;
        const newHeight = Math.max(item.column1.childHeight, item.column2.childHeight);
        if (newHeight !== item.currentHeight) {
          item.currentHeight = Math.max(newHeight, 0);
          item.column1.container.style.setProperty("--diffs-annotation-min-height", `${item.currentHeight}px`);
          item.column2.container.style.setProperty("--diffs-annotation-min-height", `${item.currentHeight}px`);
        }
      } else if (item.type === "code") {
        if (target === item.codeElement) {
          if (specs.inlineSize !== item.codeWidth) {
            item.codeWidth = specs.inlineSize;
            item.codeElement.style.setProperty("--diffs-column-content-width", `${Math.max(item.codeWidth - item.numberWidth, 0)}px`);
            item.codeElement.style.setProperty("--diffs-column-width", `${item.codeWidth}px`);
          }
        } else if (target === item.numberElement) {
          if (specs.inlineSize !== item.numberWidth) {
            item.numberWidth = specs.inlineSize;
            item.codeElement.style.setProperty("--diffs-column-number-width", `${item.numberWidth}px`);
            if (item.codeWidth !== "auto") item.codeElement.style.setProperty("--diffs-column-content-width", `${Math.max(item.codeWidth - item.numberWidth, 0)}px`);
          }
        }
      }
    }
  };
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/highlighter/languages/areLanguagesAttached.js
function areLanguagesAttached(languages) {
  for (const language of Array.isArray(languages) ? languages : [languages]) if (!AttachedLanguages.has(language)) return false;
  return true;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/highlighter/themes/areThemesAttached.js
function areThemesAttached(themes) {
  for (const theme of getThemes(themes)) if (!AttachedThemes.has(theme)) return false;
  return true;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createAnnotationElement.js
function createAnnotationElement(span) {
  return createHastElement({
    tagName: "div",
    children: [createHastElement({
      tagName: "div",
      children: span.annotations?.map((slotId) => createHastElement({
        tagName: "slot",
        properties: { name: slotId }
      })),
      properties: { "data-annotation-content": "" }
    })],
    properties: { "data-line-annotation": `${span.hunkIndex},${span.lineIndex}` }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getIconForType.js
function getIconForType(type) {
  switch (type) {
    case "file":
      return "diffs-icon-file-code";
    case "change":
      return "diffs-icon-symbol-modified";
    case "new":
      return "diffs-icon-symbol-added";
    case "deleted":
      return "diffs-icon-symbol-deleted";
    case "rename-pure":
    case "rename-changed":
      return "diffs-icon-symbol-moved";
  }
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createFileHeaderElement.js
function createFileHeaderElement({ fileOrDiff, themeStyles, themeType }) {
  const fileDiff = "type" in fileOrDiff ? fileOrDiff : void 0;
  const properties = {
    "data-diffs-header": "",
    "data-change-type": fileDiff?.type,
    "data-theme-type": themeType !== "system" ? themeType : void 0,
    style: themeStyles
  };
  return createHastElement({
    tagName: "div",
    children: [createHeaderElement({
      name: fileOrDiff.name,
      prevName: "prevName" in fileOrDiff ? fileOrDiff.prevName : void 0,
      iconType: fileDiff?.type ?? "file"
    }), createMetadataElement(fileDiff)],
    properties
  });
}
function createHeaderElement({ name, prevName, iconType }) {
  const children = [createIconElement({
    name: getIconForType(iconType),
    properties: { "data-change-icon": iconType }
  })];
  if (prevName != null) {
    children.push(createHastElement({
      tagName: "div",
      children: [createTextNodeElement(prevName)],
      properties: { "data-prev-name": "" }
    }));
    children.push(createIconElement({
      name: "diffs-icon-arrow-right-short",
      properties: { "data-rename-icon": "" }
    }));
  }
  children.push(createHastElement({
    tagName: "div",
    children: [createTextNodeElement(name)],
    properties: { "data-title": "" }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: { "data-header-content": "" }
  });
}
function createMetadataElement(fileDiff) {
  const children = [];
  if (fileDiff != null) {
    let additions = 0;
    let deletions = 0;
    for (const hunk of fileDiff.hunks) {
      additions += hunk.additionLines;
      deletions += hunk.deletionLines;
    }
    if (deletions > 0 || additions === 0) children.push(createHastElement({
      tagName: "span",
      children: [createTextNodeElement(`-${deletions}`)],
      properties: { "data-deletions-count": "" }
    }));
    if (additions > 0 || deletions === 0) children.push(createHastElement({
      tagName: "span",
      children: [createTextNodeElement(`+${additions}`)],
      properties: { "data-additions-count": "" }
    }));
  }
  children.push(createHastElement({
    tagName: "slot",
    properties: { name: HEADER_METADATA_SLOT_ID }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: { "data-metadata": "" }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createPreElement.js
function createPreElement(options) {
  return createHastElement({
    tagName: "pre",
    properties: createPreWrapperProperties(options)
  });
}
function createPreWrapperProperties({ diffIndicators, disableBackground, disableLineNumbers, overflow, split, themeType, themeStyles, totalLines }) {
  const properties = {
    "data-diffs": "",
    "data-type": split ? "split" : "file",
    "data-overflow": overflow,
    "data-disable-line-numbers": disableLineNumbers ? "" : void 0,
    "data-background": !disableBackground ? "" : void 0,
    "data-indicators": diffIndicators === "bars" || diffIndicators === "classic" ? diffIndicators : void 0,
    "data-theme-type": themeType !== "system" ? themeType : void 0,
    style: themeStyles,
    tabIndex: 0
  };
  properties.style += `--diffs-min-number-column-width-default:${`${totalLines}`.length}ch;`;
  return properties;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getHighlighterOptions.js
function getHighlighterOptions(lang, options) {
  return {
    langs: [lang ?? "text"],
    themes: getThemes(options.theme)
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getLineAnnotationName.js
function getLineAnnotationName(annotation) {
  return `annotation-${"side" in annotation ? `${annotation.side}-` : ""}${annotation.lineNumber}`;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/renderers/FileRenderer.js
var FileRenderer = class {
  highlighter;
  renderCache;
  computedLang = "text";
  lineAnnotations = {};
  constructor(options = { theme: DEFAULT_THEMES }, onRenderUpdate, workerManager) {
    this.options = options;
    this.onRenderUpdate = onRenderUpdate;
    this.workerManager = workerManager;
    if (workerManager?.isWorkingPool() !== true) this.highlighter = areThemesAttached(options.theme ?? DEFAULT_THEMES) ? getHighlighterIfLoaded() : void 0;
  }
  setOptions(options) {
    this.options = options;
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
  }
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = {};
    for (const annotation of lineAnnotations) {
      const arr = this.lineAnnotations[annotation.lineNumber] ?? [];
      this.lineAnnotations[annotation.lineNumber] = arr;
      arr.push(annotation);
    }
  }
  cleanUp() {
    this.renderCache = void 0;
    this.highlighter = void 0;
    this.workerManager = void 0;
    this.onRenderUpdate = void 0;
  }
  hydrate(file) {
    const { options } = this.getRenderOptions(file);
    let cache = this.workerManager?.getFileResultCache(file);
    if (cache != null && !areRenderOptionsEqual(options, cache.options)) cache = void 0;
    this.renderCache ??= {
      file,
      options,
      highlighted: true,
      result: cache?.result
    };
    if (this.workerManager?.isWorkingPool() === true && this.renderCache.result == null) this.workerManager.highlightFileAST(this, file);
    else this.asyncHighlight(file).then(({ result, options: options$1 }) => {
      this.onHighlightSuccess(file, result, options$1);
    });
  }
  getRenderOptions(file) {
    const options = (() => {
      if (this.workerManager?.isWorkingPool() === true) return this.workerManager.getFileRenderOptions();
      const { theme = DEFAULT_THEMES, tokenizeMaxLineLength = 1e3 } = this.options;
      return {
        theme,
        tokenizeMaxLineLength
      };
    })();
    const { renderCache } = this;
    if (renderCache?.result == null) return {
      options,
      forceRender: true
    };
    if (file !== renderCache.file || !areRenderOptionsEqual(options, renderCache.options)) return {
      options,
      forceRender: true
    };
    return {
      options,
      forceRender: false
    };
  }
  renderFile(file = this.renderCache?.file) {
    if (file == null) return;
    const cache = this.workerManager?.getFileResultCache(file);
    if (cache != null && this.renderCache == null) this.renderCache = {
      file,
      highlighted: true,
      ...cache
    };
    const { options, forceRender } = this.getRenderOptions(file);
    this.renderCache ??= {
      file,
      highlighted: false,
      options,
      result: void 0
    };
    if (this.workerManager?.isWorkingPool() === true) {
      this.renderCache.result ??= this.workerManager.getPlainFileAST(file);
      if (!this.renderCache.highlighted || forceRender) this.workerManager.highlightFileAST(this, file);
    } else {
      this.computedLang = file.lang ?? getFiletypeFromFileName(file.name);
      const hasThemes = this.highlighter != null && areThemesAttached(options.theme);
      const hasLangs = this.highlighter != null && areLanguagesAttached(this.computedLang);
      if (this.highlighter != null && hasThemes && (forceRender || !this.renderCache.highlighted && hasLangs || this.renderCache.result == null)) {
        const { result, options: options$1 } = this.renderFileWithHighlighter(file, this.highlighter, !hasLangs);
        this.renderCache = {
          file,
          options: options$1,
          highlighted: hasLangs,
          result
        };
      }
      if (!hasThemes || !hasLangs) this.asyncHighlight(file).then(({ result, options: options$1 }) => {
        this.onHighlightSuccess(file, result, options$1);
      });
    }
    return this.renderCache.result != null ? this.processFileResult(this.renderCache.file, this.renderCache.result) : void 0;
  }
  async asyncRender(file) {
    const { result } = await this.asyncHighlight(file);
    return this.processFileResult(file, result);
  }
  async asyncHighlight(file) {
    this.computedLang = file.lang ?? getFiletypeFromFileName(file.name);
    const hasThemes = this.highlighter != null && hasResolvedThemes(getThemes(this.options.theme));
    const hasLangs = this.highlighter != null && areLanguagesAttached(this.computedLang);
    if (this.highlighter == null || !hasThemes || !hasLangs) this.highlighter = await this.initializeHighlighter();
    return this.renderFileWithHighlighter(file, this.highlighter);
  }
  renderFileWithHighlighter(file, highlighter, plainText = false) {
    const { options } = this.getRenderOptions(file);
    return {
      result: renderFileWithHighlighter(file, highlighter, options, plainText),
      options
    };
  }
  processFileResult(file, result) {
    const { disableFileHeader = false } = this.options;
    const codeAST = [];
    let lineIndex = 1;
    for (const line of result.code) {
      codeAST.push(line);
      const annotations = this.lineAnnotations[lineIndex];
      if (annotations != null) codeAST.push(createAnnotationElement({
        type: "annotation",
        hunkIndex: 0,
        lineIndex,
        annotations: annotations.map((annotation) => getLineAnnotationName(annotation))
      }));
      lineIndex++;
    }
    return {
      codeAST,
      preAST: this.createPreElement(result.code.length, result.themeStyles, result.baseThemeType),
      headerAST: !disableFileHeader ? this.renderHeader(file, result.themeStyles, result.baseThemeType) : void 0,
      totalLines: result.code.length,
      themeStyles: result.themeStyles,
      baseThemeType: result.baseThemeType,
      css: ""
    };
  }
  renderHeader(file, themeStyles, baseThemeType) {
    const { themeType = "system" } = this.options;
    return createFileHeaderElement({
      fileOrDiff: file,
      themeStyles,
      themeType: baseThemeType ?? themeType
    });
  }
  renderFullHTML(result) {
    return toHtml(this.renderFullAST(result));
  }
  renderFullAST(result, children = []) {
    children.push(createHastElement({
      tagName: "code",
      children: result.codeAST,
      properties: { "data-code": "" }
    }));
    return {
      ...result.preAST,
      children
    };
  }
  renderPartialHTML(children, includeCodeNode = false) {
    if (!includeCodeNode) return toHtml(children);
    return toHtml(createHastElement({
      tagName: "code",
      children,
      properties: { "data-code": "" }
    }));
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
    return this.highlighter;
  }
  onHighlightSuccess(file, result, options) {
    if (this.renderCache == null) return;
    const triggerRenderUpdate = this.renderCache.file !== file || !this.renderCache.highlighted || !areRenderOptionsEqual(options, this.renderCache.options);
    this.renderCache = {
      file,
      options,
      highlighted: true,
      result
    };
    if (triggerRenderUpdate) this.onRenderUpdate?.();
  }
  onHighlightError(error) {
    console.error(error);
  }
  createPreElement(totalLines, themeStyles, baseThemeType) {
    const { disableLineNumbers = false, overflow = "scroll", themeType = "system" } = this.options;
    return createPreElement({
      diffIndicators: "none",
      disableBackground: true,
      disableLineNumbers,
      overflow,
      themeStyles,
      themeType: baseThemeType ?? themeType,
      split: false,
      totalLines
    });
  }
};
function areRenderOptionsEqual(optionsA, optionsB) {
  return areThemesEqual(optionsA.theme, optionsB.theme) && optionsA.tokenizeMaxLineLength === optionsB.tokenizeMaxLineLength;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/sprite.js
var SVGSpriteSheet = `<svg data-icon-sprite aria-hidden="true" width="0" height="0">
  <symbol id="diffs-icon-arrow-right-short" viewBox="0 0 16 16">
    <path d="M8.47 4.22a.75.75 0 0 0 0 1.06l1.97 1.97H3.75a.75.75 0 0 0 0 1.5h6.69l-1.97 1.97a.75.75 0 1 0 1.06 1.06l3.25-3.25a.75.75 0 0 0 0-1.06L9.53 4.22a.75.75 0 0 0-1.06 0"/>
  </symbol>
  <symbol id="diffs-icon-brand-github" viewBox="0 0 16 16">
    <path d="M8 0c4.42 0 8 3.58 8 8a8.01 8.01 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27s-1.36.09-2 .27c-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8"/>
  </symbol>
  <symbol id="diffs-icon-chevron" viewBox="0 0 16 16">
    <path d="M1.47 4.47a.75.75 0 0 1 1.06 0L8 9.94l5.47-5.47a.75.75 0 1 1 1.06 1.06l-6 6a.75.75 0 0 1-1.06 0l-6-6a.75.75 0 0 1 0-1.06"/>
  </symbol>
  <symbol id="diffs-icon-chevrons-narrow" viewBox="0 0 10 16">
    <path d="M4.47 2.22a.75.75 0 0 1 1.06 0l3.25 3.25a.75.75 0 0 1-1.06 1.06L5 3.81 2.28 6.53a.75.75 0 0 1-1.06-1.06zM1.22 9.47a.75.75 0 0 1 1.06 0L5 12.19l2.72-2.72a.75.75 0 0 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0l-3.25-3.25a.75.75 0 0 1 0-1.06"/>
  </symbol>
  <symbol id="diffs-icon-diff-split" viewBox="0 0 16 16">
    <path d="M14 0H8.5v16H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2m-1.5 6.5v1h1a.5.5 0 0 1 0 1h-1v1a.5.5 0 0 1-1 0v-1h-1a.5.5 0 0 1 0-1h1v-1a.5.5 0 0 1 1 0"/><path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h5.5V0zm.5 7.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1" opacity=".3"/>
  </symbol>
  <symbol id="diffs-icon-diff-unified" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M16 14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8.5h16zm-8-4a.5.5 0 0 0-.5.5v1h-1a.5.5 0 0 0 0 1h1v1a.5.5 0 0 0 1 0v-1h1a.5.5 0 0 0 0-1h-1v-1A.5.5 0 0 0 8 10" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14 0a2 2 0 0 1 2 2v5.5H0V2a2 2 0 0 1 2-2zM6.5 3.5a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1z" clip-rule="evenodd" opacity=".4"/>
  </symbol>
  <symbol id="diffs-icon-expand" viewBox="0 0 16 16">
    <path d="M3.47 5.47a.75.75 0 0 1 1.06 0L8 8.94l3.47-3.47a.75.75 0 1 1 1.06 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06"/>
  </symbol>
  <symbol id="diffs-icon-expand-all" viewBox="0 0 16 16">
    <path d="M11.47 9.47a.75.75 0 1 1 1.06 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06L8 12.94zM7.526 1.418a.75.75 0 0 1 1.004.052l4 4a.75.75 0 1 1-1.06 1.06L8 3.06 4.53 6.53a.75.75 0 1 1-1.06-1.06l4-4z"/>
  </symbol>
  <symbol id="diffs-icon-file-code" viewBox="0 0 16 16">
    <path d="M10.75 0c.199 0 .39.08.53.22l3.5 3.5c.14.14.22.331.22.53v9A2.75 2.75 0 0 1 12.25 16h-8.5A2.75 2.75 0 0 1 1 13.25V2.75A2.75 2.75 0 0 1 3.75 0zm-7 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h8.5c.69 0 1.25-.56 1.25-1.25V5h-1.25A2.25 2.25 0 0 1 10 2.75V1.5z"/><path d="M7.248 6.19a.75.75 0 0 1 .063 1.058L5.753 9l1.558 1.752a.75.75 0 0 1-1.122.996l-2-2.25a.75.75 0 0 1 0-.996l2-2.25a.75.75 0 0 1 1.06-.063M8.69 7.248a.75.75 0 1 1 1.12-.996l2 2.25a.75.75 0 0 1 0 .996l-2 2.25a.75.75 0 1 1-1.12-.996L10.245 9z"/>
  </symbol>
  <symbol id="diffs-icon-symbol-added" viewBox="0 0 16 16">
    <path d="M8 4a.75.75 0 0 1 .75.75v2.5h2.5a.75.75 0 0 1 0 1.5h-2.5v2.5a.75.75 0 0 1-1.5 0v-2.5h-2.5a.75.75 0 0 1 0-1.5h2.5v-2.5A.75.75 0 0 1 8 4"/><path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/>
  </symbol>
  <symbol id="diffs-icon-symbol-deleted" viewBox="0 0 16 16">
    <path d="M4 8a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5A.75.75 0 0 1 4 8"/><path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/>
  </symbol>
  <symbol id="diffs-icon-symbol-diffstat" viewBox="0 0 16 16">
    <path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/><path d="M8.75 4.296a.75.75 0 0 0-1.5 0V6.25h-2a.75.75 0 0 0 0 1.5h2v1.5h1.5v-1.5h2a.75.75 0 0 0 0-1.5h-2zM5.25 10a.75.75 0 0 0 0 1.5h5.5a.75.75 0 0 0 0-1.5z"/>
  </symbol>
  <symbol id="diffs-icon-symbol-ignored" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706s.826.607 1.706.802c.898.2 2.091.288 3.704.288s2.806-.088 3.704-.288c.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5s-2.806.088-3.704.288c-.88.196-1.381.478-1.706.802s-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8M0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m11.53-2.47a.75.75 0 0 0-1.06-1.06l-6 6a.75.75 0 1 0 1.06 1.06z"/>
  </symbol>
  <symbol id="diffs-icon-symbol-modified" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706s.826.607 1.706.802c.898.2 2.091.288 3.704.288s2.806-.088 3.704-.288c.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5s-2.806.088-3.704.288c-.88.196-1.381.478-1.706.802s-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8M0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m8 3a3 3 0 1 0 0-6 3 3 0 0 0 0 6"/>
  </symbol>
  <symbol id="diffs-icon-symbol-moved" viewBox="0 0 16 16">
    <path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/><path d="M8.495 4.695a.75.75 0 0 0-.05 1.06L10.486 8l-2.041 2.246a.75.75 0 0 0 1.11 1.008l2.5-2.75a.75.75 0 0 0 0-1.008l-2.5-2.75a.75.75 0 0 0-1.06-.051m-4 0a.75.75 0 0 0-.05 1.06l2.044 2.248-1.796 1.995a.75.75 0 0 0 1.114 1.004l2.25-2.5a.75.75 0 0 0-.002-1.007l-2.5-2.75a.75.75 0 0 0-1.06-.05"/>
  </symbol>
  <symbol id="diffs-icon-symbol-ref" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706.286.286.71.54 1.41.73V1.86c-.7.19-1.124.444-1.41.73-.324.325-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8m4 6.397c.697.07 1.522.103 2.5.103 1.613 0 2.806-.088 3.704-.288.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5c-.978 0-1.803.033-2.5.103zM0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m7-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z"/>
  </symbol>
</svg>`;

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/areFilesEqual.js
function areFilesEqual(fileA, fileB) {
  return fileA?.cacheKey === fileB?.cacheKey && fileA?.contents === fileB?.contents && fileA?.name === fileB?.name && fileA?.lang === fileB?.lang;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createAnnotationWrapperNode.js
function createAnnotationWrapperNode(slot) {
  const wrapper = document.createElement("div");
  wrapper.dataset.annotationSlot = "";
  wrapper.slot = slot;
  wrapper.style.whiteSpace = "normal";
  return wrapper;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createCodeNode.js
function createCodeNode({ pre, columnType } = {}) {
  const code = document.createElement("code");
  code.dataset.code = "";
  if (columnType != null) code.dataset[columnType] = "";
  pre?.appendChild(code);
  return code;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createHoverContentNode.js
function createHoverContentNode() {
  const hoverContent = document.createElement("div");
  hoverContent.slot = "hover-slot";
  hoverContent.style.position = "absolute";
  hoverContent.style.top = "0";
  hoverContent.style.bottom = "0";
  hoverContent.style.textAlign = "center";
  hoverContent.style.whiteSpace = "normal";
  return hoverContent;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createUnsafeCSSStyleNode.js
function createUnsafeCSSStyleNode() {
  const node = document.createElement("style");
  node.setAttribute(UNSAFE_CSS_ATTRIBUTE, "");
  return node;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/style.js
var style_default = "@layer base, theme, unsafe;\n\n@layer base {\n  :host {\n    --diffs-bg: #fff;\n    --diffs-fg: #000;\n    --diffs-font-fallback:\n      'SF Mono', Monaco, Consolas, 'Ubuntu Mono', 'Liberation Mono',\n      'Courier New', monospace;\n    --diffs-header-font-fallback:\n      system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue',\n      'Noto Sans', 'Liberation Sans', Arial, sans-serif;\n\n    --diffs-mixer: light-dark(black, white);\n    --diffs-gap-fallback: 8px;\n\n    /*\n    // Available CSS Color Overrides\n    --diffs-bg-buffer-override\n    --diffs-bg-hover-override\n    --diffs-bg-context-override\n    --diffs-bg-separator-override\n\n    --diffs-fg-number-override\n    --diffs-fg-number-addition-override\n    --diffs-fg-number-deletion-override\n\n    --diffs-deletion-color-override\n    --diffs-addition-color-override\n    --diffs-modified-color-override\n\n    --diffs-bg-deletion-override\n    --diffs-bg-deletion-number-override\n    --diffs-bg-deletion-hover-override\n    --diffs-bg-deletion-emphasis-override\n\n    --diffs-bg-addition-override\n    --diffs-bg-addition-number-override\n    --diffs-bg-addition-hover-override\n    --diffs-bg-addition-emphasis-override\n\n    // Line Selection Color Overrides (for enableLineSelection)\n    --diffs-selection-color-override\n    --diffs-bg-selection-override\n    --diffs-bg-selection-number-override\n    --diffs-bg-selection-background-override\n    --diffs-bg-selection-number-background-override\n\n    // Available CSS Layout Overrides\n    --diffs-gap-inline\n    --diffs-gap-block\n    --diffs-gap-style\n    --diffs-tab-size\n  */\n\n    color-scheme: light dark;\n    display: block;\n    font-family: var(\n      --diffs-header-font-family,\n      var(--diffs-header-font-fallback)\n    );\n    font-size: var(--diffs-font-size, 13px);\n    line-height: var(--diffs-line-height, 20px);\n    font-feature-settings: var(--diffs-font-features);\n  }\n\n  /* NOTE(mdo): Some semantic HTML elements (e.g. `pre`, `code`) have default\n * user-agent styles. These must be overridden to use our custom styles. */\n  pre,\n  code,\n  [data-error-wrapper] {\n    margin: 0;\n    padding: 0;\n    display: block;\n    outline: none;\n    font-family: var(--diffs-font-family, var(--diffs-font-fallback));\n  }\n\n  *,\n  *::before,\n  *::after {\n    box-sizing: border-box;\n  }\n\n  [data-icon-sprite] {\n    display: none;\n  }\n\n  /* NOTE(mdo): Headers and separators are within pre/code, so we need to reset\n * their font-family explicitly. */\n  [data-diffs-header],\n  [data-separator] {\n    font-family: var(\n      --diffs-header-font-family,\n      var(--diffs-header-font-fallback)\n    );\n  }\n\n  [data-file-info] {\n    padding: 10px;\n    font-weight: 700;\n    color: var(--fg);\n    /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n    background-color: color-mix(in lab, var(--bg) 98%, var(--fg));\n    border-block: 1px solid color-mix(in lab, var(--bg) 95%, var(--fg));\n  }\n\n  [data-diffs-header],\n  [data-diffs],\n  [data-error-wrapper] {\n    --diffs-bg: light-dark(var(--diffs-light-bg), var(--diffs-dark-bg));\n    /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n    --diffs-bg-buffer: var(\n      --diffs-bg-buffer-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 92%, var(--diffs-mixer)),\n        color-mix(in lab, var(--diffs-bg) 92%, var(--diffs-mixer))\n      )\n    );\n    --diffs-bg-hover: var(\n      --diffs-bg-hover-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 97%, var(--diffs-mixer)),\n        color-mix(in lab, var(--diffs-bg) 91%, var(--diffs-mixer))\n      )\n    );\n    --diffs-bg-context: var(\n      --diffs-bg-context-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 98.5%, var(--diffs-mixer)),\n        color-mix(in lab, var(--diffs-bg) 92.5%, var(--diffs-mixer))\n      )\n    );\n    --diffs-bg-separator: var(\n      --diffs-bg-separator-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 96%, var(--diffs-mixer)),\n        color-mix(in lab, var(--diffs-bg) 85%, var(--diffs-mixer))\n      )\n    );\n\n    --diffs-fg: light-dark(var(--diffs-light), var(--diffs-dark));\n    --diffs-fg-number: var(\n      --diffs-fg-number-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-fg) 65%, var(--diffs-bg)),\n        color-mix(in lab, var(--diffs-fg) 65%, var(--diffs-bg))\n      )\n    );\n\n    --diffs-deletion-base: var(\n      --diffs-deletion-color-override,\n      light-dark(\n        var(\n          --diffs-light-deletion-color,\n          var(--diffs-deletion-color, rgb(255, 0, 0))\n        ),\n        var(\n          --diffs-dark-deletion-color,\n          var(--diffs-deletion-color, rgb(255, 0, 0))\n        )\n      )\n    );\n    --diffs-addition-base: var(\n      --diffs-addition-color-override,\n      light-dark(\n        var(\n          --diffs-light-addition-color,\n          var(--diffs-addition-color, rgb(0, 255, 0))\n        ),\n        var(\n          --diffs-dark-addition-color,\n          var(--diffs-addition-color, rgb(0, 255, 0))\n        )\n      )\n    );\n    --diffs-modified-base: var(\n      --diffs-modified-color-override,\n      light-dark(\n        var(\n          --diffs-light-modified-color,\n          var(--diffs-modified-color, rgb(0, 0, 255))\n        ),\n        var(\n          --diffs-dark-modified-color,\n          var(--diffs-modified-color, rgb(0, 0, 255))\n        )\n      )\n    );\n\n    /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n    --diffs-bg-deletion: var(\n      --diffs-bg-deletion-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 88%, var(--diffs-deletion-base)),\n        color-mix(in lab, var(--diffs-bg) 80%, var(--diffs-deletion-base))\n      )\n    );\n    --diffs-bg-deletion-number: var(\n      --diffs-bg-deletion-number-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 91%, var(--diffs-deletion-base)),\n        color-mix(in lab, var(--diffs-bg) 85%, var(--diffs-deletion-base))\n      )\n    );\n    --diffs-bg-deletion-hover: var(\n      --diffs-bg-deletion-hover-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 80%, var(--diffs-deletion-base)),\n        color-mix(in lab, var(--diffs-bg) 75%, var(--diffs-deletion-base))\n      )\n    );\n    --diffs-bg-deletion-emphasis: var(\n      --diffs-bg-deletion-emphasis-override,\n      light-dark(\n        rgb(from var(--diffs-deletion-base) r g b / 0.15),\n        rgb(from var(--diffs-deletion-base) r g b / 0.2)\n      )\n    );\n\n    --diffs-bg-addition: var(\n      --diffs-bg-addition-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 88%, var(--diffs-addition-base)),\n        color-mix(in lab, var(--diffs-bg) 80%, var(--diffs-addition-base))\n      )\n    );\n    --diffs-bg-addition-number: var(\n      --diffs-bg-addition-number-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 91%, var(--diffs-addition-base)),\n        color-mix(in lab, var(--diffs-bg) 85%, var(--diffs-addition-base))\n      )\n    );\n    --diffs-bg-addition-hover: var(\n      --diffs-bg-addition-hover-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 80%, var(--diffs-addition-base)),\n        color-mix(in lab, var(--diffs-bg) 70%, var(--diffs-addition-base))\n      )\n    );\n    --diffs-bg-addition-emphasis: var(\n      --diffs-bg-addition-emphasis-override,\n      light-dark(\n        rgb(from var(--diffs-addition-base) r g b / 0.15),\n        rgb(from var(--diffs-addition-base) r g b / 0.2)\n      )\n    );\n\n    --diffs-selection-base: var(--diffs-modified-base);\n    --diffs-selection-number-fg: light-dark(\n      color-mix(in lab, var(--diffs-selection-base) 65%, var(--diffs-mixer)),\n      color-mix(in lab, var(--diffs-selection-base) 75%, var(--diffs-mixer))\n    );\n    --diffs-bg-selection: var(\n      --diffs-bg-selection-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 82%, var(--diffs-selection-base)),\n        color-mix(in lab, var(--diffs-bg) 75%, var(--diffs-selection-base))\n      )\n    );\n    --diffs-bg-selection-number: var(\n      --diffs-bg-selection-number-override,\n      light-dark(\n        color-mix(in lab, var(--diffs-bg) 75%, var(--diffs-selection-base)),\n        color-mix(in lab, var(--diffs-bg) 60%, var(--diffs-selection-base))\n      )\n    );\n\n    background-color: var(--diffs-bg);\n    color: var(--diffs-fg);\n  }\n\n  [data-diffs] {\n    --diffs-code-grid: minmax(min-content, max-content) 1fr;\n\n    [data-column-content] span {\n      color: light-dark(var(--diffs-light), var(--diffs-dark));\n      font-weight: var(--diffs-light-font-weight);\n      font-style: var(--diffs-light-font-style);\n    }\n  }\n\n  [data-column-content] {\n    background-color: var(--diffs-line-bg, 'transparent');\n    grid-column: 2 / 3;\n  }\n\n  [data-diffs][data-dehydrated] {\n    --diffs-code-grid: minmax(min-content, max-content) minmax(0, 1fr);\n  }\n\n  @media (prefers-color-scheme: dark) {\n    [data-diffs-header],\n    [data-diffs] {\n      color-scheme: dark;\n    }\n\n    [data-diffs] [data-column-content] span {\n      font-weight: var(--diffs-dark-font-weight);\n      font-style: var(--diffs-dark-font-style);\n    }\n  }\n\n  [data-diffs-header][data-theme-type='light'],\n  [data-diffs][data-theme-type='light'] {\n    color-scheme: light;\n  }\n\n  [data-diffs][data-theme-type='light'] [data-column-content] span {\n    font-weight: var(--diffs-light-font-weight);\n    font-style: var(--diffs-light-font-style);\n  }\n\n  [data-diffs-header][data-theme-type='dark'],\n  [data-diffs][data-theme-type='dark'] {\n    color-scheme: dark;\n  }\n\n  [data-diffs][data-theme-type='dark'] [data-column-content] span {\n    font-weight: var(--diffs-dark-font-weight);\n    font-style: var(--diffs-dark-font-style);\n  }\n\n  [data-type='split'][data-overflow='wrap'] {\n    display: grid;\n    grid-auto-flow: dense;\n    grid-template-columns: repeat(2, var(--diffs-code-grid));\n  }\n\n  [data-type='split'][data-overflow='scroll'] {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 2px;\n  }\n\n  [data-code] {\n    display: block;\n    display: grid;\n    grid-auto-flow: dense;\n    grid-template-columns: var(--diffs-code-grid);\n    overflow: scroll clip;\n    overscroll-behavior-x: none;\n    tab-size: var(--diffs-tab-size, 2);\n    align-self: flex-start;\n    padding-top: var(--diffs-gap-block, var(--diffs-gap-fallback));\n    padding-bottom: max(\n      0px,\n      calc(var(--diffs-gap-block, var(--diffs-gap-fallback)) - 6px)\n    );\n  }\n\n  [data-code]::-webkit-scrollbar {\n    width: 0;\n    height: 6px;\n  }\n\n  [data-code]::-webkit-scrollbar-track {\n    background: transparent;\n  }\n\n  [data-code]::-webkit-scrollbar-thumb {\n    background-color: transparent;\n    border: 1px solid transparent;\n    background-clip: content-box;\n    border-radius: 3px;\n  }\n\n  [data-diffs]:hover [data-code]::-webkit-scrollbar-thumb {\n    background-color: var(--diffs-bg-context);\n  }\n\n  [data-code]::-webkit-scrollbar-corner {\n    background-color: transparent;\n  }\n\n  /*\n   * If we apply these rules globally it will mean that webkit will opt into the\n   * standards compliant version of custom css scrollbars, which we do not want\n   * because the custom stuff will look better\n  */\n  @supports (-moz-appearance: none) {\n    [data-code] {\n      scrollbar-width: thin;\n      scrollbar-color: var(--diffs-bg-context) transparent;\n      padding-bottom: var(--diffs-gap-block, var(--diffs-gap-fallback));\n    }\n  }\n\n  [data-diffs][data-type='split'][data-overflow='wrap'] {\n    padding-block: var(--diffs-gap-block, var(--diffs-gap-fallback));\n  }\n\n  [data-diffs-header] ~ [data-diffs] [data-code],\n  [data-diffs-header] ~ [data-diffs][data-overflow='wrap'] {\n    padding-top: 0;\n  }\n\n  [data-type='split'][data-overflow='wrap'] [data-code] {\n    display: contents;\n  }\n\n  [data-line-annotation],\n  [data-no-newline],\n  [data-line] {\n    position: relative;\n    display: grid;\n    grid-template-columns: subgrid;\n    grid-column: 1 / 3;\n  }\n\n  [data-line-annotation][data-selected-line] {\n    background-color: unset;\n\n    &::before {\n      content: '';\n      position: sticky;\n      top: 0;\n      left: 0;\n      display: block;\n      border-right: var(--diffs-gap-style, 1px solid var(--diffs-bg));\n      background-color: var(--diffs-bg-selection-number);\n    }\n\n    [data-annotation-content] {\n      background-color: var(--diffs-bg-selection);\n    }\n  }\n\n  [data-interactive-lines] [data-line] {\n    cursor: pointer;\n  }\n\n  [data-buffer] {\n    position: sticky;\n    left: 0;\n    grid-column: 1 / 3;\n    -webkit-user-select: none;\n            user-select: none;\n    /* We multiply by 1.414 (2) to better approximate the diagonal repeat distance */\n    background-image: repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent calc(3px * 1.414),\n      var(--diffs-bg-buffer) calc(3px * 1.414),\n      var(--diffs-bg-buffer) calc(4px * 1.414)\n    );\n    min-height: 1lh;\n    width: var(--diffs-column-width, auto);\n  }\n\n  [data-separator] {\n    grid-column: span 2;\n  }\n\n  [data-separator='metadata'],\n  [data-separator]:empty {\n    min-height: 4px;\n    background-color: var(--diffs-bg-separator);\n    display: grid;\n    grid-template-columns: subgrid;\n  }\n\n  [data-separator-wrapper] {\n    -webkit-user-select: none;\n            user-select: none;\n    fill: currentColor;\n    overflow: hidden;\n  }\n\n  [data-separator='metadata'] [data-separator-wrapper] {\n    grid-column: 2 / 3;\n    width: var(--diffs-column-content-width);\n    position: sticky;\n    left: var(--diffs-column-number-width);\n    padding: 4px 1ch;\n  }\n\n  [data-separator='line-info'] {\n    margin-block: var(--diffs-gap-block, var(--diffs-gap-fallback));\n  }\n\n  [data-separator='line-info'][data-separator-first] {\n    margin-top: 0;\n  }\n\n  [data-separator='line-info'][data-separator-last] {\n    margin-bottom: 0;\n  }\n\n  [data-separator='line-info'] [data-separator-wrapper] {\n    position: sticky;\n    display: flex;\n    align-items: center;\n    gap: 2px;\n    width: auto;\n    width: calc(var(--diffs-column-width) - var(--diffs-gap-fallback));\n    border-radius: 6px;\n  }\n\n  @media (pointer: fine) {\n    [data-separator-wrapper][data-separator-multi-button] {\n      display: grid;\n      grid-template-columns: auto minmax(0, 1fr);\n      grid-template-rows: 15px 15px;\n\n      [data-expand-button] {\n        height: 15px;\n      }\n    }\n\n    [data-type='split']\n      [data-additions]\n      [data-separator-wrapper][data-separator-multi-button] {\n      grid-template-columns: minmax(0, 1fr) auto;\n    }\n\n    [data-type='split'] [data-additions] [data-expand-button] {\n      grid-column: 2;\n    }\n\n    [data-type='split'] [data-additions] [data-separator-content] {\n      grid-column: 1;\n    }\n  }\n\n  [data-expand-button],\n  [data-separator-content] {\n    display: flex;\n    align-items: center;\n    background-color: var(--diffs-bg-separator);\n  }\n\n  [data-expand-button] {\n    justify-content: center;\n    flex-shrink: 0;\n    cursor: pointer;\n    width: 32px;\n    height: 32px;\n    opacity: 0.65;\n  }\n\n  [data-hover-slot] {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    display: flex;\n    justify-content: flex-end;\n  }\n\n  @media (pointer: fine) {\n    [data-expand-button]:hover {\n      opacity: 1;\n    }\n\n    [data-line]:hover {\n      z-index: 2;\n    }\n  }\n\n  [data-expand-up] [data-icon] {\n    transform: scaleY(-1);\n  }\n\n  [data-separator-content] {\n    flex: 1 1 auto;\n    padding: 0 1ch;\n    height: 32px;\n    opacity: 0.65;\n    overflow: hidden;\n    justify-content: flex-start;\n\n    grid-column: 2;\n    grid-row: 1 / -1;\n  }\n\n  [data-unmodified-lines] {\n    display: block;\n    overflow: hidden;\n    min-width: 0;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    flex: 0 1 auto;\n  }\n\n  [data-type='split'] [data-additions] [data-separator-content] {\n    justify-content: flex-end;\n  }\n\n  [data-type='file']\n    [data-code]\n    [data-separator='line-info']\n    [data-separator-wrapper] {\n    left: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    margin-left: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    margin-right: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    width: calc(\n      var(--diffs-column-width) -\n        (var(--diffs-gap-inline, var(--diffs-gap-fallback)) * 2)\n    );\n  }\n\n  [data-type='split']\n    [data-deletions]\n    [data-separator='line-info']\n    [data-separator-wrapper] {\n    left: var(--diffs-gap-fallback);\n    margin-left: var(--diffs-gap-fallback);\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  [data-type='split']\n    [data-additions]\n    [data-separator='line-info']\n    [data-separator-wrapper] {\n    left: 0;\n    margin-right: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n    flex-direction: row-reverse;\n  }\n\n  [data-line] {\n    background-color: var(--diffs-bg);\n    color: var(--diffs-fg);\n  }\n\n  [data-type='split'][data-overflow='wrap'] [data-deletions] {\n    [data-line-annotation],\n    [data-buffer],\n    [data-line],\n    [data-separator] {\n      grid-column: 1 / 3;\n    }\n  }\n\n  [data-line-annotation] {\n    min-height: var(--diffs-annotation-min-height, 0);\n    background-color: var(--diffs-bg-context);\n    z-index: 3;\n  }\n\n  [data-type='split'][data-overflow='wrap'] [data-additions] {\n    [data-line-annotation],\n    [data-buffer],\n    [data-line],\n    [data-separator] {\n      margin-left: 2px;\n      grid-column: 3 / 5;\n    }\n  }\n\n  [data-separator='custom'] {\n    display: grid;\n    grid-template-columns: subgrid;\n  }\n\n  [data-column-content],\n  [data-column-number] {\n    position: relative;\n    padding-inline: 1ch;\n  }\n\n  [data-indicators='classic'] [data-column-content] {\n    padding-inline-start: 2ch;\n  }\n\n  [data-indicators='classic'] {\n    [data-line-type='change-addition'] [data-column-content]::before,\n    [data-line-type='change-deletion'] [data-column-content]::before {\n      display: inline-block;\n      width: 1ch;\n      height: 1lh;\n      position: absolute;\n      top: 0;\n      left: 0;\n      -webkit-user-select: none;\n              user-select: none;\n    }\n\n    [data-line-type='change-addition'] [data-column-content]::before {\n      content: '+';\n      color: var(--diffs-addition-base);\n    }\n\n    [data-line-type='change-deletion'] [data-column-content]::before {\n      content: '-';\n      color: var(--diffs-deletion-base);\n    }\n  }\n\n  [data-indicators='bars'] {\n    [data-line-type='change-deletion'] [data-column-number]::before,\n    [data-line-type='change-addition'] [data-column-number]::before {\n      content: '';\n      display: block;\n      width: 4px;\n      height: 100%;\n      position: absolute;\n      top: 0;\n      left: 0;\n      -webkit-user-select: none;\n              user-select: none;\n    }\n\n    [data-line-type='change-deletion'] [data-column-number]::before {\n      background-image: linear-gradient(\n        0deg,\n        var(--diffs-bg-deletion) 50%,\n        var(--diffs-deletion-base) 50%\n      );\n      background-repeat: repeat;\n      background-size: 2px 2px;\n      background-size: calc(1lh / round(1lh / 2px)) calc(1lh / round(1lh / 2px));\n    }\n\n    [data-line-type='change-addition'] [data-column-number]::before {\n      background-color: var(--diffs-addition-base);\n    }\n  }\n\n  [data-overflow='wrap'] [data-column-content],\n  [data-overflow='wrap'] [data-annotation-content] {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  [data-overflow='scroll'] [data-column-content] {\n    white-space: pre;\n    min-height: 1lh;\n  }\n\n  [data-column-number] {\n    grid-column: 1 / 2;\n    box-sizing: content-box;\n    text-align: right;\n    position: sticky;\n    left: 0;\n    -webkit-user-select: none;\n            user-select: none;\n    background-color: var(--diffs-bg);\n    color: var(--diffs-fg-number);\n    z-index: 1;\n    min-width: var(\n      --diffs-min-number-column-width,\n      var(--diffs-min-number-column-width-default, 3ch)\n    );\n    padding-left: 2ch;\n    border-right: var(--diffs-gap-style, 1px solid var(--diffs-bg));\n  }\n\n  [data-disable-line-numbers] {\n    &[data-indicators='bars'] [data-column-number] {\n      min-width: 4px;\n      border-right: var(--diffs-gap-style, 1px solid var(--diffs-bg));\n    }\n\n    [data-column-number] {\n      border-right: none;\n      min-width: 0;\n      padding: 0;\n    }\n\n    [data-line-number-content] {\n      display: none;\n    }\n\n    [data-hover-slot] {\n      right: unset;\n      left: 0;\n      justify-content: flex-start;\n    }\n\n    &[data-indicators='bars'] [data-hover-slot] {\n      /* Using 5px here because theres a 1px separator after the bar */\n      left: 5px;\n    }\n  }\n\n  [data-interactive-line-numbers] [data-column-number] {\n    cursor: pointer;\n  }\n\n  [data-diff-span] {\n    border-radius: 3px;\n    -webkit-box-decoration-break: clone;\n            box-decoration-break: clone;\n  }\n\n  [data-line-type='change-addition'] {\n    [data-column-number] {\n      color: var(\n        --diffs-fg-number-addition-override,\n        var(--diffs-addition-base)\n      );\n    }\n\n    [data-diff-span] {\n      background-color: var(--diffs-bg-addition-emphasis);\n    }\n  }\n\n  [data-line-type='change-deletion'] {\n    [data-column-number] {\n      color: var(\n        --diffs-fg-number-deletion-override,\n        var(--diffs-deletion-base)\n      );\n    }\n\n    [data-diff-span] {\n      background-color: var(--diffs-bg-deletion-emphasis);\n    }\n  }\n\n  [data-background] [data-line-type='change-addition'] {\n    --diffs-line-bg: var(--diffs-bg-addition);\n\n    [data-column-number] {\n      background-color: var(--diffs-bg-addition-number);\n    }\n  }\n\n  [data-background] [data-line-type='change-deletion'] {\n    --diffs-line-bg: var(--diffs-bg-deletion);\n\n    [data-column-number] {\n      background-color: var(--diffs-bg-deletion-number);\n    }\n  }\n\n  [data-line-type='context-expanded'] {\n    --diffs-line-bg: var(--diffs-bg-context);\n\n    [data-column-number] {\n      background-color: var(--diffs-bg-context);\n    }\n  }\n\n  /* By wrapping hovers in a pointer: fine, we ensure that mobile devices don't\n*  require a double click */\n  @media (pointer: fine) {\n    [data-line]:hover:not([data-selected-line]) {\n      [data-column-number],\n      [data-column-content] {\n        background-color: var(--diffs-bg-hover);\n      }\n    }\n\n    [data-background] [data-line]:hover:not([data-selected-line]) {\n      &[data-line-type='change-deletion'] [data-column-number],\n      &[data-line-type='change-deletion'] [data-column-content] {\n        background-color: var(--diffs-bg-deletion-hover);\n      }\n\n      &[data-line-type='change-addition'] [data-column-number],\n      &[data-line-type='change-addition'] [data-column-content] {\n        background-color: var(--diffs-bg-addition-hover);\n      }\n    }\n  }\n\n  [data-diffs-header] {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    gap: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    min-height: calc(\n      1lh + (var(--diffs-gap-block, var(--diffs-gap-fallback)) * 3)\n    );\n    padding-inline: 16px;\n  }\n\n  [data-header-content] {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    gap: var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    min-width: 0;\n    white-space: nowrap;\n  }\n\n  [data-header-content] [data-prev-name],\n  [data-header-content] [data-title] {\n    direction: rtl;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    min-width: 0;\n    white-space: nowrap;\n  }\n\n  [data-prev-name] {\n    opacity: 0.7;\n  }\n\n  [data-rename-icon] {\n    fill: currentColor;\n    flex-shrink: 0;\n    flex-grow: 0;\n  }\n\n  [data-diffs-header] [data-metadata] {\n    display: flex;\n    align-items: center;\n    gap: 1ch;\n    white-space: nowrap;\n  }\n\n  [data-diffs-header] [data-additions-count] {\n    font-family: var(--diffs-font-family, var(--diffs-font-fallback));\n    color: var(--diffs-addition-base);\n  }\n\n  [data-diffs-header] [data-deletions-count] {\n    font-family: var(--diffs-font-family, var(--diffs-font-fallback));\n    color: var(--diffs-deletion-base);\n  }\n\n  [data-no-newline] {\n    -webkit-user-select: none;\n            user-select: none;\n\n    [data-column-content] {\n      opacity: 0.6;\n    }\n  }\n\n  [data-annotation-content] {\n    position: sticky;\n    left: var(--diffs-column-number-width, 0);\n    grid-column: 2 / -1;\n    width: var(--diffs-column-content-width, auto);\n    align-self: flex-start;\n    z-index: 2;\n    height: 100%;\n  }\n\n  /* Undo some of the stuff that the 'pre' tag does */\n  [data-annotation-slot] {\n    text-wrap-mode: wrap;\n    word-break: normal;\n    white-space-collapse: collapse;\n  }\n\n  [data-change-icon] {\n    fill: currentColor;\n    flex-shrink: 0;\n  }\n\n  [data-change-icon='change'],\n  [data-change-icon='rename-pure'],\n  [data-change-icon='rename-changed'] {\n    color: var(--diffs-modified-base);\n  }\n\n  [data-change-icon='new'] {\n    color: var(--diffs-addition-base);\n  }\n\n  [data-change-icon='deleted'] {\n    color: var(--diffs-deletion-base);\n  }\n\n  [data-change-icon='file'] {\n    opacity: 0.6;\n  }\n\n  /* Line selection highlighting */\n  [data-line-type='context'][data-selected-line] {\n    [data-column-number] {\n      color: var(--diffs-selection-number-fg);\n      background-color: var(--diffs-bg-selection-number);\n    }\n\n    [data-column-content] {\n      background-color: var(--diffs-bg-selection);\n    }\n  }\n\n  [data-line-type='context-expanded'],\n  [data-line-type='change-addition'],\n  [data-line-type='change-deletion'] {\n    &[data-selected-line] {\n      [data-column-content] {\n        background-color: light-dark(\n          color-mix(\n            in lab,\n            var(--diffs-line-bg, var(--diffs-bg)) 82%,\n            var(--diffs-selection-base)\n          ),\n          color-mix(\n            in lab,\n            var(--diffs-line-bg, var(--diffs-bg)) 75%,\n            var(--diffs-selection-base)\n          )\n        );\n      }\n\n      [data-column-number] {\n        color: var(--diffs-selection-number-fg);\n        background-color: light-dark(\n          color-mix(\n            in lab,\n            var(--diffs-line-bg, var(--diffs-bg)) 75%,\n            var(--diffs-selection-base)\n          ),\n          color-mix(\n            in lab,\n            var(--diffs-line-bg, var(--diffs-bg)) 60%,\n            var(--diffs-selection-base)\n          )\n        );\n      }\n    }\n  }\n\n  [data-error-wrapper] {\n    overflow: auto;\n    padding: var(--diffs-gap-block, var(--diffs-gap-fallback))\n      var(--diffs-gap-inline, var(--diffs-gap-fallback));\n    max-height: 400px;\n    scrollbar-width: none;\n\n    [data-error-message] {\n      font-weight: bold;\n      font-size: 18px;\n      color: var(--diffs-deletion-base);\n    }\n\n    [data-error-stack] {\n      color: var(--diffs-fg-number);\n    }\n  }\n}\n";

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/cssWrappers.js
var LAYER_ORDER = `@layer base, theme, unsafe;`;
function wrapCoreCSS(mainCSS) {
  return `${LAYER_ORDER}
${style_default}
@layer theme {
  ${mainCSS}
}`;
}
function wrapUnsafeCSS(unsafeCSS) {
  return `${LAYER_ORDER}
@layer unsafe {
  ${unsafeCSS}
}`;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/prerenderHTMLIfNecessary.js
function prerenderHTMLIfNecessary(element, html) {
  if (html == null) return;
  const shadowRoot = element.shadowRoot ?? element.attachShadow({ mode: "open" });
  if (shadowRoot.innerHTML === "") shadowRoot.innerHTML = html;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/setWrapperNodeProps.js
function setPreNodeProperties({ diffIndicators, disableBackground, disableLineNumbers, overflow, pre, split, themeStyles, themeType, totalLines }) {
  if (themeType === "system") delete pre.dataset.themeType;
  else pre.dataset.themeType = themeType;
  switch (diffIndicators) {
    case "bars":
    case "classic":
      pre.dataset.indicators = diffIndicators;
      break;
    case "none":
      delete pre.dataset.indicators;
      break;
  }
  if (disableLineNumbers) pre.dataset.disableLineNumbers = "";
  else delete pre.dataset.disableLineNumbers;
  if (disableBackground) delete pre.dataset.background;
  else pre.dataset.background = "";
  pre.dataset.type = split ? "split" : "file";
  pre.dataset.overflow = overflow;
  pre.dataset.diffs = "";
  pre.tabIndex = 0;
  pre.style = themeStyles;
  pre.style.setProperty("--diffs-min-number-column-width-default", `${`${totalLines}`.length}ch`);
  return pre;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/components/web-components.js
if (typeof HTMLElement !== "undefined" && customElements.get(DIFFS_TAG_NAME) == null) {
  let sheet;
  class FileDiffContainer extends HTMLElement {
    constructor() {
      super();
      if (this.shadowRoot != null) return;
      const shadowRoot = this.attachShadow({ mode: "open" });
      if (sheet == null) {
        sheet = new CSSStyleSheet();
        sheet.replaceSync(`@layer base, theme, unsafe;
@layer base {
${style_default}
}`);
      }
      shadowRoot.adoptedStyleSheets = [sheet];
    }
  }
  customElements.define(DIFFS_TAG_NAME, FileDiffContainer);
}
var DiffsContainerLoaded = true;

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/components/File.js
var instanceId = -1;
var File = class {
  static LoadedCustomComponent = DiffsContainerLoaded;
  __id = ++instanceId;
  fileContainer;
  spriteSVG;
  pre;
  code;
  unsafeCSSStyle;
  hoverContent;
  errorWrapper;
  headerElement;
  headerMetadata;
  fileRenderer;
  resizeManager;
  mouseEventManager;
  lineSelectionManager;
  annotationElements = [];
  lineAnnotations = [];
  file;
  constructor(options = { theme: DEFAULT_THEMES }, workerManager, isContainerManaged = false) {
    this.options = options;
    this.workerManager = workerManager;
    this.isContainerManaged = isContainerManaged;
    this.fileRenderer = new FileRenderer(options, this.handleHighlightRender, this.workerManager);
    this.resizeManager = new ResizeManager();
    this.mouseEventManager = new MouseEventManager("file", pluckMouseEventOptions(options));
    this.lineSelectionManager = new LineSelectionManager(pluckLineSelectionOptions(options));
    this.workerManager?.subscribeToThemeChanges(this);
  }
  handleHighlightRender = () => {
    this.rerender();
  };
  rerender() {
    if (this.file == null) return;
    this.render({
      file: this.file,
      forceRender: true
    });
  }
  setOptions(options) {
    if (options == null) return;
    this.options = options;
    this.mouseEventManager.setOptions(pluckMouseEventOptions(options));
    this.lineSelectionManager.setOptions(pluckLineSelectionOptions(options));
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
    this.fileRenderer.setThemeType(themeType);
    if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
    else this.headerElement.dataset.themeType = themeType;
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  getHoveredLine = () => {
    return this.mouseEventManager.getHoveredLine();
  };
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = lineAnnotations;
  }
  setSelectedLines(range) {
    this.lineSelectionManager.setSelection(range);
  }
  cleanUp() {
    this.fileRenderer.cleanUp();
    this.resizeManager.cleanUp();
    this.mouseEventManager.cleanUp();
    this.lineSelectionManager.cleanUp();
    this.workerManager?.unsubscribeToThemeChanges(this);
    this.workerManager = void 0;
    this.file = void 0;
    if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
    if (this.fileContainer?.shadowRoot != null) this.fileContainer.shadowRoot.innerHTML = "";
    this.fileContainer = void 0;
    this.pre = void 0;
    this.headerElement = void 0;
    this.errorWrapper = void 0;
    this.unsafeCSSStyle = void 0;
  }
  hydrate(props) {
    const { fileContainer, prerenderedHTML } = props;
    prerenderHTMLIfNecessary(fileContainer, prerenderedHTML);
    for (const element of Array.from(fileContainer.shadowRoot?.children ?? [])) {
      if (element instanceof SVGElement) {
        this.spriteSVG = element;
        continue;
      }
      if (!(element instanceof HTMLElement)) continue;
      if (element instanceof HTMLPreElement) {
        this.pre = element;
        continue;
      }
      if (element instanceof HTMLStyleElement && element.hasAttribute(UNSAFE_CSS_ATTRIBUTE)) {
        this.unsafeCSSStyle = element;
        continue;
      }
      if ("diffsHeader" in element.dataset) {
        this.headerElement = element;
        continue;
      }
    }
    if (this.pre == null) this.render(props);
    else {
      const { file, lineAnnotations } = props;
      this.fileContainer = fileContainer;
      delete this.pre.dataset.dehydrated;
      this.lineAnnotations = lineAnnotations ?? this.lineAnnotations;
      this.file = file;
      this.fileRenderer.hydrate(file);
      this.renderAnnotations();
      this.renderHoverUtility();
      this.injectUnsafeCSS();
      this.mouseEventManager.setup(this.pre);
      this.lineSelectionManager.setup(this.pre);
      if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(this.pre);
    }
  }
  render({ file, fileContainer, forceRender = false, containerWrapper, lineAnnotations }) {
    const annotationsChanged = lineAnnotations != null && (lineAnnotations.length > 0 || this.lineAnnotations.length > 0) ? lineAnnotations !== this.lineAnnotations : false;
    if (!forceRender && areFilesEqual(this.file, file) && !annotationsChanged) return;
    this.file = file;
    this.fileRenderer.setOptions(this.options);
    if (lineAnnotations != null) this.setLineAnnotations(lineAnnotations);
    this.fileRenderer.setLineAnnotations(this.lineAnnotations);
    const { disableFileHeader = false } = this.options;
    if (disableFileHeader) {
      if (this.headerElement != null) {
        this.headerElement.parentNode?.removeChild(this.headerElement);
        this.headerElement = void 0;
      }
    }
    fileContainer = this.getOrCreateFileContainerNode(fileContainer, containerWrapper);
    try {
      const fileResult = this.fileRenderer.renderFile(file);
      if (fileResult == null) {
        if (this.workerManager != null && !this.workerManager.isInitialized()) this.workerManager.initialize().then(() => this.rerender());
        return;
      }
      if (fileResult.headerAST != null) this.applyHeaderToDOM(fileResult.headerAST, fileContainer);
      const pre = this.getOrCreatePreNode(fileContainer);
      this.applyHunksToDOM(fileResult, pre);
      this.renderAnnotations();
      this.renderHoverUtility();
    } catch (error) {
      if (error instanceof Error) this.applyErrorToDOM(error, fileContainer);
    }
  }
  renderAnnotations() {
    if (this.isContainerManaged || this.fileContainer == null) return;
    for (const element of this.annotationElements) element.parentNode?.removeChild(element);
    this.annotationElements.length = 0;
    const { renderAnnotation } = this.options;
    if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
      const content = renderAnnotation(annotation);
      if (content == null) continue;
      const el = createAnnotationWrapperNode(getLineAnnotationName(annotation));
      el.appendChild(content);
      this.annotationElements.push(el);
      this.fileContainer.appendChild(el);
    }
  }
  renderHoverUtility() {
    const { renderHoverUtility } = this.options;
    if (this.fileContainer == null || renderHoverUtility == null) return;
    if (this.hoverContent == null) {
      this.hoverContent = createHoverContentNode();
      this.fileContainer.appendChild(this.hoverContent);
    }
    const element = renderHoverUtility(this.mouseEventManager.getHoveredLine);
    this.hoverContent.innerHTML = "";
    if (element != null) this.hoverContent.appendChild(element);
  }
  injectUnsafeCSS() {
    if (this.fileContainer?.shadowRoot == null) return;
    const { unsafeCSS } = this.options;
    if (unsafeCSS == null || unsafeCSS === "") {
      if (this.unsafeCSSStyle != null) {
        this.unsafeCSSStyle.parentNode?.removeChild(this.unsafeCSSStyle);
        this.unsafeCSSStyle = void 0;
      }
      return;
    }
    if (this.unsafeCSSStyle == null) {
      this.unsafeCSSStyle = createUnsafeCSSStyleNode();
      this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
    }
    this.unsafeCSSStyle.innerText = wrapUnsafeCSS(unsafeCSS);
  }
  applyHunksToDOM(result, pre) {
    this.cleanupErrorWrapper();
    this.applyPreNodeAttributes(pre, result);
    pre.innerHTML = "";
    this.code = createCodeNode();
    this.code.innerHTML = this.fileRenderer.renderPartialHTML(result.codeAST);
    pre.appendChild(this.code);
    this.injectUnsafeCSS();
    this.mouseEventManager.setup(pre);
    this.lineSelectionManager.setup(pre);
    this.lineSelectionManager.setDirty();
    if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(pre);
    else this.resizeManager.cleanUp();
  }
  applyHeaderToDOM(headerAST, container) {
    const { file } = this;
    if (file == null) return;
    this.cleanupErrorWrapper();
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = toHtml(headerAST);
    const newHeader = tempDiv.firstElementChild;
    if (!(newHeader instanceof HTMLElement)) return;
    if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
    else container.shadowRoot?.prepend(newHeader);
    this.headerElement = newHeader;
    if (this.isContainerManaged) return;
    const { renderCustomMetadata } = this.options;
    if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
    const content = renderCustomMetadata?.(file) ?? void 0;
    if (content != null) {
      this.headerMetadata = document.createElement("div");
      this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
      if (content instanceof Element) this.headerMetadata.appendChild(content);
      else this.headerMetadata.innerText = `${content}`;
      container.appendChild(this.headerMetadata);
    }
  }
  getOrCreateFileContainerNode(fileContainer, parentNode) {
    this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement(DIFFS_TAG_NAME);
    if (parentNode != null && this.fileContainer.parentNode !== parentNode) parentNode.appendChild(this.fileContainer);
    if (this.spriteSVG == null) {
      const fragment = document.createElement("div");
      fragment.innerHTML = SVGSpriteSheet;
      const firstChild = fragment.firstChild;
      if (firstChild instanceof SVGElement) {
        this.spriteSVG = firstChild;
        this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
      }
    }
    return this.fileContainer;
  }
  getOrCreatePreNode(container) {
    if (this.pre == null) {
      this.pre = document.createElement("pre");
      container.shadowRoot?.appendChild(this.pre);
    } else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
    return this.pre;
  }
  applyPreNodeAttributes(pre, { totalLines, themeStyles, baseThemeType }) {
    const { overflow = "scroll", themeType = "system", disableLineNumbers = false } = this.options;
    setPreNodeProperties({
      pre,
      split: false,
      themeStyles,
      overflow,
      disableLineNumbers,
      themeType: baseThemeType ?? themeType,
      diffIndicators: "none",
      disableBackground: true,
      totalLines
    });
  }
  applyErrorToDOM(error, container) {
    this.cleanupErrorWrapper();
    const pre = this.getOrCreatePreNode(container);
    pre.innerHTML = "";
    pre.parentNode?.removeChild(pre);
    this.pre = void 0;
    const shadowRoot = container.shadowRoot ?? container.attachShadow({ mode: "open" });
    this.errorWrapper ??= document.createElement("div");
    this.errorWrapper.dataset.errorWrapper = "";
    this.errorWrapper.innerHTML = "";
    shadowRoot.appendChild(this.errorWrapper);
    const errorMessage = document.createElement("div");
    errorMessage.dataset.errorMessage = "";
    errorMessage.innerText = error.message;
    this.errorWrapper.appendChild(errorMessage);
    const errorStack = document.createElement("pre");
    errorStack.dataset.errorStack = "";
    errorStack.innerText = error.stack ?? "No Error Stack";
    this.errorWrapper.appendChild(errorStack);
  }
  cleanupErrorWrapper() {
    this.errorWrapper?.parentNode?.removeChild(this.errorWrapper);
    this.errorWrapper = void 0;
  }
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/managers/ScrollSyncManager.js
var ScrollSyncManager = class {
  isDeletionsScrolling = false;
  isAdditionsScrolling = false;
  timeoutId = -1;
  codeDeletions;
  codeAdditions;
  cleanUp() {
    this.codeDeletions?.removeEventListener("scroll", this.handleDeletionsScroll);
    this.codeAdditions?.removeEventListener("scroll", this.handleAdditionsScroll);
    clearTimeout(this.timeoutId);
    this.codeDeletions = void 0;
    this.codeAdditions = void 0;
  }
  setup(pre, codeDeletions, codeAdditions) {
    if (codeDeletions == null || codeAdditions == null) for (const element of pre.children ?? []) {
      if (!(element instanceof HTMLElement)) continue;
      if ("deletions" in element.dataset) codeDeletions = element;
      else if ("additions" in element.dataset) codeAdditions = element;
    }
    if (codeAdditions == null || codeDeletions == null) {
      this.cleanUp();
      return;
    }
    this.codeDeletions?.removeEventListener("scroll", this.handleDeletionsScroll);
    this.codeAdditions?.removeEventListener("scroll", this.handleAdditionsScroll);
    this.codeDeletions = codeDeletions;
    this.codeAdditions = codeAdditions;
    codeDeletions.addEventListener("scroll", this.handleDeletionsScroll, { passive: true });
    codeAdditions.addEventListener("scroll", this.handleAdditionsScroll, { passive: true });
  }
  handleDeletionsScroll = () => {
    if (this.isAdditionsScrolling) return;
    this.isDeletionsScrolling = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.isDeletionsScrolling = false;
    }, 300);
    this.codeAdditions?.scrollTo({ left: this.codeDeletions?.scrollLeft });
  };
  handleAdditionsScroll = () => {
    if (this.isDeletionsScrolling) return;
    this.isAdditionsScrolling = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.isAdditionsScrolling = false;
    }, 300);
    this.codeDeletions?.scrollTo({ left: this.codeAdditions?.scrollLeft });
  };
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createEmptyRowBuffer.js
function createEmptyRowBuffer(size) {
  return createHastElement({
    tagName: "div",
    properties: {
      "data-buffer": "",
      style: `grid-row: span ${size};min-height:calc(${size} * 1lh)`
    }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createNoNewlineElement.js
function createNoNewlineElement(type) {
  return createHastElement({
    tagName: "div",
    children: [createHastElement({
      tagName: "span",
      properties: { "data-column-number": "" }
    }), createHastElement({
      tagName: "span",
      children: [createTextNodeElement("No newline at end of file")],
      properties: { "data-column-content": "" }
    })],
    properties: {
      "data-no-newline": "",
      "data-line-type": type
    }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createSeparator.js
function createExpandButton(type) {
  return createHastElement({
    tagName: "div",
    children: [createIconElement({
      name: type === "both" ? "diffs-icon-expand-all" : "diffs-icon-expand",
      properties: { "data-icon": "" }
    })],
    properties: {
      "data-expand-button": "",
      "data-expand-both": type === "both" ? "" : void 0,
      "data-expand-up": type === "up" ? "" : void 0,
      "data-expand-down": type === "down" ? "" : void 0
    }
  });
}
function createSeparator({ type, content, expandIndex, chunked = false, slotName, isFirstHunk, isLastHunk }) {
  const children = [];
  if (type === "metadata" && content != null) children.push(createHastElement({
    tagName: "div",
    children: [createTextNodeElement(content)],
    properties: { "data-separator-wrapper": "" }
  }));
  if (type === "line-info" && content != null) {
    const contentChildren = [];
    if (expandIndex != null) if (!chunked) contentChildren.push(createExpandButton(!isFirstHunk && !isLastHunk ? "both" : isFirstHunk ? "down" : "up"));
    else {
      if (!isFirstHunk) contentChildren.push(createExpandButton("up"));
      if (!isLastHunk) contentChildren.push(createExpandButton("down"));
    }
    contentChildren.push(createHastElement({
      tagName: "div",
      children: [createHastElement({
        tagName: "span",
        children: [createTextNodeElement(content)],
        properties: { "data-unmodified-lines": "" }
      })],
      properties: { "data-separator-content": "" }
    }));
    children.push(createHastElement({
      tagName: "div",
      children: contentChildren,
      properties: {
        "data-separator-wrapper": "",
        "data-separator-multi-button": contentChildren.length > 2 ? "" : void 0
      }
    }));
  }
  if (type === "custom" && slotName != null) children.push(createHastElement({
    tagName: "slot",
    properties: { name: slotName }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: {
      "data-separator": children.length === 0 ? "" : type,
      "data-expand-index": expandIndex,
      "data-separator-first": isFirstHunk ? "" : void 0,
      "data-separator-last": isLastHunk ? "" : void 0
    }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getHunkSeparatorSlotName.js
function getHunkSeparatorSlotName(type, hunkIndex) {
  return `hunk-separator-${type}-${hunkIndex}`;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getTotalLineCountFromHunks.js
function getTotalLineCountFromHunks(hunks) {
  const lastHunk = hunks[hunks.length - 1];
  if (lastHunk == null) return 0;
  return Math.max(lastHunk.additionStart + lastHunk.additionCount, lastHunk.deletionStart + lastHunk.deletionCount);
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/renderers/DiffHunksRenderer.js
var EXPANDED_REGION = {
  fromStart: 0,
  fromEnd: 0
};
var DiffHunksRenderer = class {
  highlighter;
  diff;
  expandedHunks = /* @__PURE__ */ new Map();
  deletionAnnotations = {};
  additionAnnotations = {};
  computedLang = "text";
  renderCache;
  constructor(options = { theme: DEFAULT_THEMES }, onRenderUpdate, workerManager) {
    this.options = options;
    this.onRenderUpdate = onRenderUpdate;
    this.workerManager = workerManager;
    if (workerManager?.isWorkingPool() !== true) this.highlighter = areThemesAttached(options.theme ?? DEFAULT_THEMES) ? getHighlighterIfLoaded() : void 0;
  }
  cleanUp() {
    this.highlighter = void 0;
    this.diff = void 0;
    this.renderCache = void 0;
    this.workerManager = void 0;
    this.onRenderUpdate = void 0;
  }
  setOptions(options) {
    this.options = options;
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if (this.getOptionsWithDefaults().themeType === themeType) return;
    this.mergeOptions({ themeType });
  }
  expandHunk(index, direction) {
    const { expansionLineCount } = this.getOptionsWithDefaults();
    const region = this.expandedHunks.get(index) ?? {
      fromStart: 0,
      fromEnd: 0
    };
    if (direction === "up" || direction === "both") region.fromStart += expansionLineCount;
    if (direction === "down" || direction === "both") region.fromEnd += expansionLineCount;
    this.expandedHunks.set(index, region);
  }
  setLineAnnotations(lineAnnotations) {
    this.additionAnnotations = {};
    this.deletionAnnotations = {};
    for (const annotation of lineAnnotations) {
      const map = (() => {
        switch (annotation.side) {
          case "deletions":
            return this.deletionAnnotations;
          case "additions":
            return this.additionAnnotations;
        }
      })();
      const arr = map[annotation.lineNumber] ?? [];
      map[annotation.lineNumber] = arr;
      arr.push(annotation);
    }
  }
  getOptionsWithDefaults() {
    const { diffIndicators = "bars", diffStyle = "split", disableBackground = false, disableFileHeader = false, disableLineNumbers = false, expandUnchanged = false, expansionLineCount = 100, hunkSeparators = "line-info", lineDiffType = "word-alt", maxLineDiffLength = 1e3, overflow = "scroll", theme = DEFAULT_THEMES, themeType = "system", tokenizeMaxLineLength = 1e3, useCSSClasses = false } = this.options;
    return {
      diffIndicators,
      diffStyle,
      disableBackground,
      disableFileHeader,
      disableLineNumbers,
      expandUnchanged,
      expansionLineCount,
      hunkSeparators,
      lineDiffType,
      maxLineDiffLength,
      overflow,
      theme: this.workerManager?.getDiffRenderOptions().theme ?? theme,
      themeType,
      tokenizeMaxLineLength,
      useCSSClasses
    };
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
    return this.highlighter;
  }
  hydrate(diff) {
    if (diff == null) return;
    this.diff = diff;
    const { options } = this.getRenderOptions(diff);
    let cache = this.workerManager?.getDiffResultCache(diff);
    if (cache != null && !areRenderOptionsEqual2(options, cache.options)) cache = void 0;
    this.renderCache ??= {
      diff,
      highlighted: true,
      options,
      result: cache?.result
    };
    if (this.workerManager?.isWorkingPool() === true && this.renderCache.result == null) this.workerManager.highlightDiffAST(this, this.diff);
    else this.asyncHighlight(diff).then(({ result, options: options$1 }) => {
      this.onHighlightSuccess(diff, result, options$1);
    });
  }
  getRenderOptions(diff) {
    const options = (() => {
      if (this.workerManager?.isWorkingPool() === true) return this.workerManager.getDiffRenderOptions();
      const { theme, tokenizeMaxLineLength, lineDiffType } = this.getOptionsWithDefaults();
      return {
        theme,
        tokenizeMaxLineLength,
        lineDiffType
      };
    })();
    this.getOptionsWithDefaults();
    const { renderCache } = this;
    if (renderCache?.result == null) return {
      options,
      forceRender: true
    };
    if (diff !== renderCache.diff || !areRenderOptionsEqual2(options, renderCache.options)) return {
      options,
      forceRender: true
    };
    return {
      options,
      forceRender: false
    };
  }
  renderDiff(diff = this.renderCache?.diff) {
    if (diff == null) return;
    const cache = this.workerManager?.getDiffResultCache(diff);
    if (cache != null && this.renderCache == null) this.renderCache = {
      diff,
      highlighted: true,
      ...cache
    };
    const { options, forceRender } = this.getRenderOptions(diff);
    this.renderCache ??= {
      diff,
      highlighted: false,
      options,
      result: void 0
    };
    if (this.workerManager?.isWorkingPool() === true) {
      this.renderCache.result ??= this.workerManager.getPlainDiffAST(diff);
      if (!this.renderCache.highlighted || forceRender) this.workerManager.highlightDiffAST(this, diff);
    } else {
      this.computedLang = diff.lang ?? getFiletypeFromFileName(diff.name);
      const hasThemes = this.highlighter != null && areThemesAttached(options.theme);
      const hasLangs = this.highlighter != null && areLanguagesAttached(this.computedLang);
      if (this.highlighter != null && hasThemes && (forceRender || !this.renderCache.highlighted && hasLangs || this.renderCache.result == null)) {
        const { result, options: options$1 } = this.renderDiffWithHighlighter(diff, this.highlighter, !hasLangs);
        this.renderCache = {
          diff,
          options: options$1,
          highlighted: hasLangs,
          result
        };
      }
      if (!hasThemes || !hasLangs) this.asyncHighlight(diff).then(({ result, options: options$1 }) => {
        this.onHighlightSuccess(diff, result, options$1);
      });
    }
    return this.renderCache.result != null ? this.processDiffResult(this.renderCache.diff, this.renderCache.result) : void 0;
  }
  async asyncRender(diff) {
    const { result } = await this.asyncHighlight(diff);
    return this.processDiffResult(diff, result);
  }
  createPreElement(split, totalLines, themeStyles, baseThemeType) {
    const { diffIndicators, disableBackground, disableLineNumbers, overflow, themeType } = this.getOptionsWithDefaults();
    return createPreElement({
      diffIndicators,
      disableBackground,
      disableLineNumbers,
      overflow,
      themeStyles,
      split,
      themeType: baseThemeType ?? themeType,
      totalLines
    });
  }
  async asyncHighlight(diff) {
    this.computedLang = diff.lang ?? getFiletypeFromFileName(diff.name);
    const hasThemes = this.highlighter != null && areThemesAttached(this.options.theme ?? DEFAULT_THEMES);
    const hasLangs = this.highlighter != null && areLanguagesAttached(this.computedLang);
    if (this.highlighter == null || !hasThemes || !hasLangs) this.highlighter = await this.initializeHighlighter();
    return this.renderDiffWithHighlighter(diff, this.highlighter);
  }
  renderDiffWithHighlighter(diff, highlighter, plainText = false) {
    const { options } = this.getRenderOptions(diff);
    return {
      result: renderDiffWithHighlighter(diff, highlighter, options, plainText),
      options
    };
  }
  onHighlightSuccess(diff, result, options) {
    if (this.renderCache == null) return;
    const triggerRenderUpdate = this.renderCache.diff !== diff || !this.renderCache.highlighted || !areRenderOptionsEqual2(this.renderCache.options, options);
    this.renderCache = {
      diff,
      options,
      highlighted: true,
      result
    };
    if (triggerRenderUpdate) this.onRenderUpdate?.();
  }
  onHighlightError(error) {
    console.error(error);
  }
  processDiffResult(fileDiff, { code, themeStyles, baseThemeType }) {
    const { diffStyle, disableFileHeader } = this.getOptionsWithDefaults();
    this.diff = fileDiff;
    const unified = diffStyle === "unified";
    let additionsAST = [];
    let deletionsAST = [];
    let unifiedAST = [];
    let hunkIndex = 0;
    const hunkData = [];
    let prevHunk;
    let lineIndex = 0;
    for (const hunk of fileDiff.hunks) {
      lineIndex += hunk.collapsedBefore;
      lineIndex = this.renderHunks({
        ast: code,
        hunk,
        prevHunk,
        hunkIndex,
        isLastHunk: hunkIndex === fileDiff.hunks.length - 1,
        additionsAST,
        deletionsAST,
        unifiedAST,
        hunkData,
        lineIndex
      });
      hunkIndex++;
      prevHunk = hunk;
    }
    const totalLines = Math.max(getTotalLineCountFromHunks(fileDiff.hunks), fileDiff.newLines?.length ?? 0, fileDiff.oldLines?.length ?? 0);
    additionsAST = !unified && (code.hunks != null || code.newLines.length > 0) ? additionsAST : void 0;
    deletionsAST = !unified && (code.hunks != null || code.oldLines.length > 0) ? deletionsAST : void 0;
    unifiedAST = unifiedAST.length > 0 ? unifiedAST : void 0;
    const preNode = this.createPreElement(deletionsAST != null && additionsAST != null, totalLines, themeStyles, baseThemeType);
    return {
      additionsAST,
      deletionsAST,
      unifiedAST,
      hunkData,
      preNode,
      themeStyles,
      baseThemeType,
      headerElement: !disableFileHeader ? this.renderHeader(this.diff, themeStyles, baseThemeType) : void 0,
      totalLines,
      css: ""
    };
  }
  renderFullAST(result, children = []) {
    if (result.unifiedAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.unifiedAST,
      properties: {
        "data-code": "",
        "data-unified": ""
      }
    }));
    if (result.deletionsAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.deletionsAST,
      properties: {
        "data-code": "",
        "data-deletions": ""
      }
    }));
    if (result.additionsAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.additionsAST,
      properties: {
        "data-code": "",
        "data-additions": ""
      }
    }));
    return {
      ...result.preNode,
      children
    };
  }
  renderFullHTML(result, tempChildren = []) {
    return toHtml(this.renderFullAST(result, tempChildren));
  }
  renderPartialHTML(children, columnType) {
    if (columnType == null) return toHtml(children);
    return toHtml(createHastElement({
      tagName: "code",
      children,
      properties: {
        "data-code": "",
        [`data-${columnType}`]: ""
      }
    }));
  }
  renderCollapsedHunks({ ast, hunkData, hunkIndex, hunkSpecs, isFirstHunk, isLastHunk, rangeSize, lineIndex, additionLineNumber, deletionLineNumber, unifiedAST, deletionsAST, additionsAST }) {
    if (rangeSize <= 0) return;
    const { hunkSeparators, expandUnchanged, diffStyle, expansionLineCount } = this.getOptionsWithDefaults();
    const expandable = ast.hunks == null && ast.newLines.length > 0 && ast.oldLines.length > 0;
    const expandedRegion = this.expandedHunks.get(hunkIndex) ?? EXPANDED_REGION;
    const chunked = rangeSize > expansionLineCount;
    const collapsedLines = Math.max(!expandUnchanged ? rangeSize - (expandedRegion.fromEnd + expandedRegion.fromStart) : 0, 0);
    const pushHunkSeparator = ({ type, linesAST }) => {
      if (hunkSeparators === "line-info" || hunkSeparators === "custom") {
        const slotName = getHunkSeparatorSlotName(type, hunkIndex);
        linesAST.push(createSeparator({
          type: hunkSeparators,
          content: getModifiedLinesString(collapsedLines),
          expandIndex: expandable ? hunkIndex : void 0,
          chunked,
          slotName,
          isFirstHunk,
          isLastHunk
        }));
        hunkData.push({
          slotName,
          hunkIndex,
          lines: collapsedLines,
          type,
          expandable: expandable ? {
            up: expandable && !isFirstHunk,
            down: expandable,
            chunked
          } : void 0
        });
      } else if (hunkSeparators === "metadata" && hunkSpecs != null) linesAST.push(createSeparator({
        type: "metadata",
        content: hunkSpecs,
        isFirstHunk,
        isLastHunk
      }));
      else if (hunkSeparators === "simple" && hunkIndex > 0) linesAST.push(createSeparator({
        type: "simple",
        isFirstHunk,
        isLastHunk: false
      }));
    };
    const renderRange = ({ rangeLen, fromStart }) => {
      if (ast.newLines == null || ast.oldLines == null) return;
      const offset = isLastHunk ? 0 : fromStart ? rangeSize : rangeLen;
      let dLineNumber = deletionLineNumber - offset;
      let aLineNumber = additionLineNumber - offset;
      let lIndex = lineIndex - offset;
      for (let i = 0; i < rangeLen; i++) {
        const oldLine = ast.oldLines[dLineNumber];
        const newLine = ast.newLines[aLineNumber];
        if (oldLine == null || newLine == null) {
          console.error({
            aLineNumber,
            dLineNumber,
            ast
          });
          throw new Error("DiffHunksRenderer.renderHunks prefill context invalid. Must include data for old and new lines");
        }
        dLineNumber++;
        aLineNumber++;
        if (diffStyle === "unified") this.pushLineWithAnnotation({
          newLine,
          unifiedAST,
          unifiedSpan: this.getAnnotations("unified", dLineNumber, aLineNumber, hunkIndex, lIndex)
        });
        else this.pushLineWithAnnotation({
          newLine,
          oldLine,
          additionsAST,
          deletionsAST,
          ...this.getAnnotations("split", dLineNumber, aLineNumber, hunkIndex, lIndex)
        });
        lIndex++;
      }
    };
    if (expandable) renderRange({
      rangeLen: Math.min(collapsedLines === 0 || expandUnchanged ? rangeSize : expandedRegion.fromStart, rangeSize),
      fromStart: true
    });
    if (collapsedLines > 0) if (diffStyle === "unified") pushHunkSeparator({
      type: "unified",
      linesAST: unifiedAST
    });
    else {
      pushHunkSeparator({
        type: "deletions",
        linesAST: deletionsAST
      });
      pushHunkSeparator({
        type: "additions",
        linesAST: additionsAST
      });
    }
    if (collapsedLines > 0 && expandedRegion.fromEnd > 0 && !isLastHunk) renderRange({
      rangeLen: Math.min(expandedRegion.fromEnd, rangeSize),
      fromStart: false
    });
  }
  renderHunks({ hunk, hunkData, hunkIndex, lineIndex, isLastHunk, prevHunk, ast, deletionsAST, additionsAST, unifiedAST }) {
    const { diffStyle } = this.getOptionsWithDefaults();
    const unified = diffStyle === "unified";
    let additionLineNumber = hunk.additionStart - 1;
    let deletionLineNumber = hunk.deletionStart - 1;
    this.renderCollapsedHunks({
      additionLineNumber,
      additionsAST,
      ast,
      deletionLineNumber,
      deletionsAST,
      hunkData,
      hunkIndex,
      hunkSpecs: hunk.hunkSpecs,
      isFirstHunk: prevHunk == null,
      isLastHunk: false,
      lineIndex,
      rangeSize: Math.max(hunk.collapsedBefore, 0),
      unifiedAST
    });
    let { oldLines, newLines, oldIndex, newIndex } = (() => {
      if (ast.hunks != null) {
        const lineHunk = ast.hunks[hunkIndex];
        if (lineHunk == null) {
          console.error({
            ast,
            hunkIndex
          });
          throw new Error(`DiffHunksRenderer.renderHunks: lineHunk doesn't exist`);
        }
        return {
          oldLines: lineHunk.oldLines,
          newLines: lineHunk.newLines,
          oldIndex: 0,
          newIndex: 0
        };
      }
      return {
        oldLines: ast.oldLines,
        newLines: ast.newLines,
        oldIndex: deletionLineNumber,
        newIndex: additionLineNumber
      };
    })();
    for (const hunkContent of hunk.hunkContent) if (hunkContent.type === "context") {
      const { length: len } = hunkContent.lines;
      for (let i = 0; i < len; i++) {
        const oldLine = oldLines[oldIndex];
        const newLine = newLines[newIndex];
        oldIndex++;
        newIndex++;
        additionLineNumber++;
        deletionLineNumber++;
        if (unified) {
          if (newLine == null) throw new Error("DiffHunksRenderer.renderHunks: newLine doesnt exist for context...");
          this.pushLineWithAnnotation({
            newLine,
            unifiedAST,
            unifiedSpan: this.getAnnotations("unified", deletionLineNumber, additionLineNumber, hunkIndex, lineIndex)
          });
        } else {
          if (newLine == null || oldLine == null) throw new Error("DiffHunksRenderer.renderHunks: newLine or oldLine doesnt exist for context...");
          this.pushLineWithAnnotation({
            oldLine,
            newLine,
            deletionsAST,
            additionsAST,
            ...this.getAnnotations("split", deletionLineNumber, additionLineNumber, hunkIndex, lineIndex)
          });
        }
        lineIndex++;
      }
      if (hunkContent.noEOFCR) {
        const node = createNoNewlineElement("context");
        if (unified) unifiedAST.push(node);
        else {
          deletionsAST.push(node);
          additionsAST.push(node);
        }
      }
    } else {
      const { length: dLen } = hunkContent.deletions;
      const { length: aLen } = hunkContent.additions;
      const len = unified ? dLen + aLen : Math.max(dLen, aLen);
      let spanSize = 0;
      for (let i = 0; i < len; i++) {
        const { oldLine, newLine } = (() => {
          let oldLine$1 = oldLines[oldIndex];
          let newLine$1 = newLines[newIndex];
          if (unified) if (i < dLen) newLine$1 = void 0;
          else oldLine$1 = void 0;
          else {
            if (i >= dLen) oldLine$1 = void 0;
            if (i >= aLen) newLine$1 = void 0;
          }
          if (oldLine$1 == null && newLine$1 == null) {
            console.error({
              i,
              len,
              ast,
              hunkContent
            });
            throw new Error("renderHunks: oldLine and newLine are null, something is wrong");
          }
          return {
            oldLine: oldLine$1,
            newLine: newLine$1
          };
        })();
        if (oldLine != null) {
          oldIndex++;
          deletionLineNumber++;
        }
        if (newLine != null) {
          newIndex++;
          additionLineNumber++;
        }
        if (unified) {
          this.pushLineWithAnnotation({
            oldLine,
            newLine,
            unifiedAST,
            unifiedSpan: this.getAnnotations("unified", oldLine != null ? deletionLineNumber : void 0, newLine != null ? additionLineNumber : void 0, hunkIndex, lineIndex)
          });
          lineIndex++;
        } else {
          if (oldLine == null || newLine == null) spanSize++;
          const annotationSpans = this.getAnnotations("split", oldLine != null ? deletionLineNumber : void 0, newLine != null ? additionLineNumber : void 0, hunkIndex, lineIndex);
          if (annotationSpans != null) {
            if (spanSize > 0) {
              if (aLen > dLen) deletionsAST.push(createEmptyRowBuffer(spanSize));
              else additionsAST.push(createEmptyRowBuffer(spanSize));
              spanSize = 0;
            }
          }
          this.pushLineWithAnnotation({
            newLine,
            oldLine,
            deletionsAST,
            additionsAST,
            ...annotationSpans
          });
          lineIndex++;
        }
      }
      if (!unified) {
        if (spanSize > 0) {
          if (aLen > dLen) deletionsAST.push(createEmptyRowBuffer(spanSize));
          else additionsAST.push(createEmptyRowBuffer(spanSize));
          spanSize = 0;
        }
        if (hunkContent.noEOFCRDeletions) {
          deletionsAST.push(createNoNewlineElement("change-deletion"));
          if (!hunkContent.noEOFCRAdditions) additionsAST.push(createEmptyRowBuffer(1));
        }
        if (hunkContent.noEOFCRAdditions) {
          additionsAST.push(createNoNewlineElement("change-addition"));
          if (!hunkContent.noEOFCRDeletions) deletionsAST.push(createEmptyRowBuffer(1));
        }
      }
    }
    if (isLastHunk && ast.newLines != null && ast.newLines.length > 0) this.renderCollapsedHunks({
      additionLineNumber,
      additionsAST,
      ast,
      deletionLineNumber,
      deletionsAST,
      hunkData,
      hunkIndex: hunkIndex + 1,
      hunkSpecs: void 0,
      isFirstHunk: false,
      isLastHunk: true,
      lineIndex,
      rangeSize: Math.max(ast.newLines.length - Math.max(hunk.additionStart + hunk.additionCount - 1, 0), 0),
      unifiedAST
    });
    return lineIndex;
  }
  pushLineWithAnnotation({ newLine, oldLine, unifiedAST, additionsAST, deletionsAST, unifiedSpan, deletionSpan, additionSpan }) {
    if (unifiedAST != null) {
      if (oldLine != null) unifiedAST.push(oldLine);
      else if (newLine != null) unifiedAST.push(newLine);
      if (unifiedSpan != null) unifiedAST.push(createAnnotationElement(unifiedSpan));
    } else if (deletionsAST != null && additionsAST != null) {
      if (oldLine != null) deletionsAST.push(oldLine);
      if (newLine != null) additionsAST.push(newLine);
      if (deletionSpan != null) deletionsAST.push(createAnnotationElement(deletionSpan));
      if (additionSpan != null) additionsAST.push(createAnnotationElement(additionSpan));
    }
  }
  getAnnotations(type, oldLineNumber, newLineNumber, hunkIndex, lineIndex) {
    const deletionSpan = {
      type: "annotation",
      hunkIndex,
      lineIndex,
      annotations: []
    };
    if (oldLineNumber != null) for (const anno of this.deletionAnnotations[oldLineNumber] ?? []) deletionSpan.annotations.push(getLineAnnotationName(anno));
    const additionSpan = {
      type: "annotation",
      hunkIndex,
      lineIndex,
      annotations: []
    };
    if (newLineNumber != null) for (const anno of this.additionAnnotations[newLineNumber] ?? []) (type === "unified" ? deletionSpan : additionSpan).annotations.push(getLineAnnotationName(anno));
    if (type === "unified") {
      if (deletionSpan.annotations.length > 0) return deletionSpan;
      return;
    }
    if (additionSpan.annotations.length === 0 && deletionSpan.annotations.length === 0) return;
    return {
      deletionSpan,
      additionSpan
    };
  }
  renderHeader(diff, themeStyles, baseThemeType) {
    const { themeType } = this.getOptionsWithDefaults();
    return createFileHeaderElement({
      fileOrDiff: diff,
      themeStyles,
      themeType: baseThemeType ?? themeType
    });
  }
};
function areRenderOptionsEqual2(optionsA, optionsB) {
  return areThemesEqual(optionsA.theme, optionsB.theme) && optionsA.tokenizeMaxLineLength === optionsB.tokenizeMaxLineLength && optionsA.lineDiffType === optionsB.lineDiffType;
}
function getModifiedLinesString(lines) {
  return `${lines} unmodified line${lines > 1 ? "s" : ""}`;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/parseLineType.js
function parseLineType(line) {
  const firstChar = line[0];
  if (firstChar !== "+" && firstChar !== "-" && firstChar !== " " && firstChar !== "\\") {
    console.error(`parseLineType: Invalid firstChar: "${firstChar}", full line: "${line}"`);
    return;
  }
  return {
    line: line.substring(1),
    type: firstChar === " " ? "context" : firstChar === "\\" ? "metadata" : firstChar === "+" ? "addition" : "deletion"
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/parsePatchFiles.js
function processPatch(data, cacheKeyPrefix) {
  const isGitDiff = GIT_DIFF_FILE_BREAK_REGEX.test(data);
  const rawFiles = data.split(isGitDiff ? GIT_DIFF_FILE_BREAK_REGEX : UNIFIED_DIFF_FILE_BREAK_REGEX);
  let patchMetadata;
  const files = [];
  let currentFile;
  for (const file of rawFiles) {
    if (isGitDiff && !GIT_DIFF_FILE_BREAK_REGEX.test(file)) {
      if (patchMetadata == null) patchMetadata = file;
      else console.error("parsePatchContent: unknown file blob:", file);
      continue;
    } else if (!isGitDiff && !UNIFIED_DIFF_FILE_BREAK_REGEX.test(file)) {
      if (patchMetadata == null) patchMetadata = file;
      else console.error("parsePatchContent: unknown file blob:", file);
      continue;
    }
    let lastHunkEnd = 0;
    const hunks = file.split(FILE_CONTEXT_BLOB);
    currentFile = void 0;
    for (const hunk of hunks) {
      const lines = hunk.split(SPLIT_WITH_NEWLINES);
      const firstLine = lines.shift();
      if (firstLine == null) {
        console.error("parsePatchContent: invalid hunk", hunk);
        continue;
      }
      const match = firstLine.match(HUNK_HEADER);
      const hunkContent = [];
      let additionLines = 0;
      let deletionLines = 0;
      if (match == null || currentFile == null) {
        if (currentFile != null) {
          console.error("parsePatchContent: Invalid hunk", hunk);
          continue;
        }
        currentFile = {
          name: "",
          prevName: void 0,
          type: "change",
          hunks: [],
          splitLineCount: 0,
          unifiedLineCount: 0,
          cacheKey: cacheKeyPrefix != null ? `${cacheKeyPrefix}-${files.length}` : void 0
        };
        lines.unshift(firstLine);
        for (const line of lines) {
          const filenameMatch = line.match(isGitDiff ? FILENAME_HEADER_REGEX_GIT : FILENAME_HEADER_REGEX);
          if (line.startsWith("diff --git")) {
            const [, , prevName, , name] = line.trim().match(ALTERNATE_FILE_NAMES_GIT) ?? [];
            currentFile.name = name.trim();
            if (prevName !== name) currentFile.prevName = prevName.trim();
          } else if (filenameMatch != null) {
            const [, type, fileName] = filenameMatch;
            if (type === "---" && fileName !== "/dev/null") {
              currentFile.prevName = fileName.trim();
              currentFile.name = fileName.trim();
            } else if (type === "+++" && fileName !== "/dev/null") currentFile.name = fileName.trim();
          } else if (isGitDiff) {
            if (line.startsWith("new mode ")) currentFile.mode = line.replace("new mode", "").trim();
            if (line.startsWith("old mode ")) currentFile.oldMode = line.replace("old mode", "").trim();
            if (line.startsWith("new file mode")) {
              currentFile.type = "new";
              currentFile.mode = line.replace("new file mode", "").trim();
            }
            if (line.startsWith("deleted file mode")) {
              currentFile.type = "deleted";
              currentFile.mode = line.replace("deleted file mode", "").trim();
            }
            if (line.startsWith("similarity index")) if (line.startsWith("similarity index 100%")) currentFile.type = "rename-pure";
            else currentFile.type = "rename-changed";
            if (line.startsWith("index ")) {
              const [, mode] = line.trim().match(FILE_MODE_FROM_INDEX) ?? [];
              if (mode != null) currentFile.mode = mode;
            }
            if (line.startsWith("rename from ")) currentFile.prevName = line.replace("rename from ", "");
            if (line.startsWith("rename to ")) currentFile.name = line.replace("rename to ", "").trim();
          }
        }
        continue;
      } else {
        let currentContent;
        let lastLineType;
        while (lines.length > 0 && (lines[lines.length - 1] === "\n" || lines[lines.length - 1] === "")) lines.pop();
        for (const rawLine of lines) {
          const parsedLine = parseLineType(rawLine);
          if (parsedLine == null) continue;
          const { type, line } = parsedLine;
          if (type === "addition") {
            if (currentContent == null || currentContent.type !== "change") {
              currentContent = createContentGroup("change");
              hunkContent.push(currentContent);
            }
            currentContent.additions.push(line);
            additionLines++;
            lastLineType = "addition";
          } else if (type === "deletion") {
            if (currentContent == null || currentContent.type !== "change") {
              currentContent = createContentGroup("change");
              hunkContent.push(currentContent);
            }
            currentContent.deletions.push(line);
            deletionLines++;
            lastLineType = "deletion";
          } else if (type === "context") {
            if (currentContent == null || currentContent.type !== "context") {
              currentContent = createContentGroup("context");
              hunkContent.push(currentContent);
            }
            currentContent.lines.push(line);
            lastLineType = "context";
          } else if (type === "metadata" && currentContent != null) {
            if (currentContent.type === "context") currentContent.noEOFCR = true;
            else if (lastLineType === "deletion") {
              currentContent.noEOFCRDeletions = true;
              const lastIndex = currentContent.deletions.length - 1;
              if (lastIndex >= 0) currentContent.deletions[lastIndex] = cleanLastNewline(currentContent.deletions[lastIndex]);
            } else if (lastLineType === "addition") {
              currentContent.noEOFCRAdditions = true;
              const lastIndex = currentContent.additions.length - 1;
              if (lastIndex >= 0) currentContent.additions[lastIndex] = cleanLastNewline(currentContent.additions[lastIndex]);
            }
          }
        }
      }
      const hunkData = {
        collapsedBefore: 0,
        splitLineCount: 0,
        splitLineStart: 0,
        unifiedLineCount: 0,
        unifiedLineStart: 0,
        additionCount: parseInt(match[4] ?? "1"),
        additionStart: parseInt(match[3]),
        additionLines,
        deletionCount: parseInt(match[2] ?? "1"),
        deletionStart: parseInt(match[1]),
        deletionLines,
        hunkContent,
        hunkContext: match[5],
        hunkSpecs: firstLine
      };
      if (isNaN(hunkData.additionCount) || isNaN(hunkData.deletionCount) || isNaN(hunkData.additionStart) || isNaN(hunkData.deletionStart)) {
        console.error("parsePatchContent: invalid hunk metadata", hunkData);
        continue;
      }
      hunkData.collapsedBefore = Math.max(hunkData.additionStart - 1 - lastHunkEnd, 0);
      currentFile.hunks.push(hunkData);
      lastHunkEnd = hunkData.additionStart + hunkData.additionCount - 1;
      for (const content of hunkContent) if (content.type === "context") {
        hunkData.splitLineCount += content.lines.length;
        hunkData.unifiedLineCount += content.lines.length;
      } else {
        hunkData.splitLineCount += Math.max(content.additions.length, content.deletions.length);
        hunkData.unifiedLineCount += content.deletions.length + content.additions.length;
      }
      hunkData.splitLineStart = currentFile.splitLineCount;
      hunkData.unifiedLineStart = currentFile.unifiedLineCount;
      currentFile.splitLineCount += hunkData.splitLineCount;
      currentFile.unifiedLineCount += hunkData.unifiedLineCount;
    }
    if (currentFile != null) {
      if (!isGitDiff && currentFile.prevName != null && currentFile.name !== currentFile.prevName) if (currentFile.hunks.length > 0) currentFile.type = "rename-changed";
      else currentFile.type = "rename-pure";
      if (currentFile.type !== "rename-pure" && currentFile.type !== "rename-changed") currentFile.prevName = void 0;
      files.push(currentFile);
    }
  }
  return {
    patchMetadata,
    files
  };
}
function parsePatchFiles(data, cacheKeyPrefix) {
  const patches = [];
  for (const patch of data.split(COMMIT_METADATA_SPLIT)) try {
    patches.push(processPatch(patch, cacheKeyPrefix != null ? `${cacheKeyPrefix}-${patches.length}` : void 0));
  } catch (error) {
    console.error(error);
  }
  return patches;
}
function createContentGroup(type) {
  if (type === "change") return {
    type: "change",
    additions: [],
    deletions: [],
    noEOFCRAdditions: false,
    noEOFCRDeletions: false
  };
  return {
    type: "context",
    lines: [],
    noEOFCR: false
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/parseDiffFromFile.js
function parseDiffFromFile(oldFile, newFile) {
  const fileData = parsePatchFiles(createTwoFilesPatch(oldFile.name, newFile.name, oldFile.contents, newFile.contents, oldFile.header, newFile.header))[0]?.files[0];
  if (fileData == null) throw new Error("parseDiffFrom: FileInvalid diff -- probably need to fix something -- if the files are the same maybe?");
  fileData.oldLines = oldFile.contents.split(SPLIT_WITH_NEWLINES);
  fileData.newLines = newFile.contents.split(SPLIT_WITH_NEWLINES);
  if (oldFile.cacheKey != null && newFile.cacheKey != null) fileData.cacheKey = `${oldFile.cacheKey}:${newFile.cacheKey}`;
  return fileData;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/components/FileDiff.js
var instanceId2 = -1;
var FileDiff = class {
  static LoadedCustomComponent = DiffsContainerLoaded;
  __id = ++instanceId2;
  fileContainer;
  spriteSVG;
  pre;
  unsafeCSSStyle;
  hoverContent;
  headerElement;
  headerMetadata;
  customHunkElements = [];
  errorWrapper;
  hunksRenderer;
  resizeManager;
  scrollSyncManager;
  mouseEventManager;
  lineSelectionManager;
  annotationElements = [];
  lineAnnotations = [];
  oldFile;
  newFile;
  fileDiff;
  constructor(options = { theme: DEFAULT_THEMES }, workerManager, isContainerManaged = false) {
    this.options = options;
    this.workerManager = workerManager;
    this.isContainerManaged = isContainerManaged;
    this.hunksRenderer = new DiffHunksRenderer({
      ...options,
      hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
    }, this.handleHighlightRender, this.workerManager);
    this.resizeManager = new ResizeManager();
    this.scrollSyncManager = new ScrollSyncManager();
    this.mouseEventManager = new MouseEventManager("diff", pluckMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
    this.lineSelectionManager = new LineSelectionManager(pluckLineSelectionOptions(options));
    this.workerManager?.subscribeToThemeChanges(this);
  }
  handleHighlightRender = () => {
    this.rerender();
  };
  setOptions(options) {
    if (options == null) return;
    this.options = options;
    this.hunksRenderer.setOptions({
      ...this.options,
      hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
    });
    this.mouseEventManager.setOptions(pluckMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
    this.lineSelectionManager.setOptions(pluckLineSelectionOptions(options));
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
    this.hunksRenderer.setThemeType(themeType);
    if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
    else this.headerElement.dataset.themeType = themeType;
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  getHoveredLine = () => {
    return this.mouseEventManager.getHoveredLine();
  };
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = lineAnnotations;
  }
  setSelectedLines(range) {
    this.lineSelectionManager.setSelection(range);
  }
  cleanUp() {
    this.hunksRenderer.cleanUp();
    this.resizeManager.cleanUp();
    this.mouseEventManager.cleanUp();
    this.scrollSyncManager.cleanUp();
    this.lineSelectionManager.cleanUp();
    this.workerManager?.unsubscribeToThemeChanges(this);
    this.workerManager = void 0;
    this.fileDiff = void 0;
    this.oldFile = void 0;
    this.newFile = void 0;
    if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
    if (this.fileContainer?.shadowRoot != null) this.fileContainer.shadowRoot.innerHTML = "";
    this.fileContainer = void 0;
    this.pre = void 0;
    this.headerElement = void 0;
    this.errorWrapper = void 0;
  }
  hydrate(props) {
    const { fileContainer, prerenderedHTML } = props;
    prerenderHTMLIfNecessary(fileContainer, prerenderedHTML);
    for (const element of Array.from(fileContainer.shadowRoot?.children ?? [])) {
      if (element instanceof SVGElement) {
        this.spriteSVG = element;
        continue;
      }
      if (!(element instanceof HTMLElement)) continue;
      if (element instanceof HTMLPreElement) {
        this.pre = element;
        continue;
      }
      if ("diffsHeader" in element.dataset) {
        this.headerElement = element;
        continue;
      }
      if (element instanceof HTMLStyleElement && element.hasAttribute(UNSAFE_CSS_ATTRIBUTE)) {
        this.unsafeCSSStyle = element;
        continue;
      }
    }
    if (this.pre == null) this.render(props);
    else {
      const { lineAnnotations, oldFile, newFile, fileDiff } = props;
      this.fileContainer = fileContainer;
      delete this.pre.dataset.dehydrated;
      this.lineAnnotations = lineAnnotations ?? this.lineAnnotations;
      this.newFile = newFile;
      this.oldFile = oldFile;
      this.fileDiff = fileDiff ?? (oldFile != null && newFile != null ? parseDiffFromFile(oldFile, newFile) : void 0);
      this.hunksRenderer.hydrate(this.fileDiff);
      this.renderAnnotations();
      this.renderHoverUtility();
      this.injectUnsafeCSS();
      this.mouseEventManager.setup(this.pre);
      this.lineSelectionManager.setup(this.pre);
      if ((this.options.overflow ?? "scroll") === "scroll") {
        this.resizeManager.setup(this.pre);
        this.scrollSyncManager.setup(this.pre);
      }
    }
  }
  rerender() {
    if (this.fileDiff == null && this.newFile == null && this.oldFile == null) return;
    this.render({
      oldFile: this.oldFile,
      newFile: this.newFile,
      fileDiff: this.fileDiff,
      forceRender: true
    });
  }
  handleExpandHunk = (hunkIndex, direction) => {
    this.expandHunk(hunkIndex, direction);
  };
  expandHunk(hunkIndex, direction) {
    this.hunksRenderer.expandHunk(hunkIndex, direction);
    this.rerender();
  }
  render({ oldFile, newFile, fileDiff, forceRender = false, lineAnnotations, fileContainer, containerWrapper }) {
    const filesDidChange = oldFile != null && newFile != null && (!areFilesEqual(oldFile, this.oldFile) || !areFilesEqual(newFile, this.newFile));
    const annotationsChanged = lineAnnotations != null && (lineAnnotations.length > 0 || this.lineAnnotations.length > 0) ? lineAnnotations !== this.lineAnnotations : false;
    if (!forceRender && !annotationsChanged && (fileDiff != null && fileDiff === this.fileDiff || fileDiff == null && !filesDidChange)) return;
    this.oldFile = oldFile;
    this.newFile = newFile;
    if (fileDiff != null) this.fileDiff = fileDiff;
    else if (oldFile != null && newFile != null && filesDidChange) this.fileDiff = parseDiffFromFile(oldFile, newFile);
    if (lineAnnotations != null) this.setLineAnnotations(lineAnnotations);
    if (this.fileDiff == null) return;
    this.hunksRenderer.setOptions({
      ...this.options,
      hunkSeparators: typeof this.options.hunkSeparators === "function" ? "custom" : this.options.hunkSeparators
    });
    this.hunksRenderer.setLineAnnotations(this.lineAnnotations);
    const { disableFileHeader = false } = this.options;
    if (disableFileHeader) {
      if (this.headerElement != null) {
        this.headerElement.parentNode?.removeChild(this.headerElement);
        this.headerElement = void 0;
      }
    }
    fileContainer = this.getOrCreateFileContainer(fileContainer, containerWrapper);
    try {
      const hunksResult = this.hunksRenderer.renderDiff(this.fileDiff);
      if (hunksResult == null) {
        if (this.workerManager != null && !this.workerManager.isInitialized()) this.workerManager.initialize().then(() => this.rerender());
        return;
      }
      if (hunksResult.headerElement != null) this.applyHeaderToDOM(hunksResult.headerElement, fileContainer);
      const pre = this.getOrCreatePreNode(fileContainer);
      this.applyHunksToDOM(pre, hunksResult);
      this.renderSeparators(hunksResult.hunkData);
      this.renderAnnotations();
      this.renderHoverUtility();
    } catch (error) {
      if (error instanceof Error) this.applyErrorToDOM(error, fileContainer);
    }
  }
  renderSeparators(hunkData) {
    const { hunkSeparators } = this.options;
    if (this.isContainerManaged || this.fileContainer == null || typeof hunkSeparators !== "function") return;
    for (const element of this.customHunkElements) element.parentNode?.removeChild(element);
    this.customHunkElements.length = 0;
    for (const hunk of hunkData) {
      const element = document.createElement("div");
      element.style.display = "contents";
      element.slot = hunk.slotName;
      element.appendChild(hunkSeparators(hunk, this));
      this.fileContainer.appendChild(element);
      this.customHunkElements.push(element);
    }
  }
  renderAnnotations() {
    if (this.isContainerManaged || this.fileContainer == null) return;
    for (const element of this.annotationElements) element.parentNode?.removeChild(element);
    this.annotationElements.length = 0;
    const { renderAnnotation } = this.options;
    if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
      const content = renderAnnotation(annotation);
      if (content == null) continue;
      const el = createAnnotationWrapperNode(getLineAnnotationName(annotation));
      el.appendChild(content);
      this.annotationElements.push(el);
      this.fileContainer.appendChild(el);
    }
  }
  renderHoverUtility() {
    const { renderHoverUtility } = this.options;
    if (this.fileContainer == null || renderHoverUtility == null) return;
    if (this.hoverContent == null) {
      this.hoverContent = createHoverContentNode();
      this.fileContainer.appendChild(this.hoverContent);
    }
    const element = renderHoverUtility(this.mouseEventManager.getHoveredLine);
    this.hoverContent.innerHTML = "";
    if (element != null) this.hoverContent.appendChild(element);
  }
  getOrCreateFileContainer(fileContainer, parentNode) {
    this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement(DIFFS_TAG_NAME);
    if (parentNode != null && this.fileContainer.parentNode !== parentNode) parentNode.appendChild(this.fileContainer);
    if (this.spriteSVG == null) {
      const fragment = document.createElement("div");
      fragment.innerHTML = SVGSpriteSheet;
      const firstChild = fragment.firstChild;
      if (firstChild instanceof SVGElement) {
        this.spriteSVG = firstChild;
        this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
      }
    }
    return this.fileContainer;
  }
  getFileContainer() {
    return this.fileContainer;
  }
  getOrCreatePreNode(container) {
    if (this.pre == null) {
      this.pre = document.createElement("pre");
      container.shadowRoot?.appendChild(this.pre);
    } else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
    return this.pre;
  }
  applyHeaderToDOM(headerAST, container) {
    this.cleanupErrorWrapper();
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = toHtml(headerAST);
    const newHeader = tempDiv.firstElementChild;
    if (!(newHeader instanceof HTMLElement)) return;
    if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
    else container.shadowRoot?.prepend(newHeader);
    this.headerElement = newHeader;
    if (this.isContainerManaged) return;
    const { renderHeaderMetadata } = this.options;
    if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
    const content = renderHeaderMetadata?.({
      oldFile: this.oldFile,
      newFile: this.newFile,
      fileDiff: this.fileDiff
    }) ?? void 0;
    if (content != null) {
      this.headerMetadata = document.createElement("div");
      this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
      if (content instanceof Element) this.headerMetadata.appendChild(content);
      else this.headerMetadata.innerText = `${content}`;
      container.appendChild(this.headerMetadata);
    }
  }
  injectUnsafeCSS() {
    if (this.fileContainer?.shadowRoot == null) return;
    const { unsafeCSS } = this.options;
    if (unsafeCSS == null || unsafeCSS === "") return;
    if (this.unsafeCSSStyle == null) {
      this.unsafeCSSStyle = createUnsafeCSSStyleNode();
      this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
    }
    this.unsafeCSSStyle.innerText = wrapUnsafeCSS(unsafeCSS);
  }
  applyHunksToDOM(pre, result) {
    this.cleanupErrorWrapper();
    this.applyPreNodeAttributes(pre, result);
    pre.innerHTML = "";
    let codeDeletions;
    let codeAdditions;
    if (result.unifiedAST != null) {
      const codeUnified = createCodeNode({ columnType: "unified" });
      codeUnified.innerHTML = this.hunksRenderer.renderPartialHTML(result.unifiedAST);
      pre.appendChild(codeUnified);
    } else {
      if (result.deletionsAST != null) {
        codeDeletions = createCodeNode({ columnType: "deletions" });
        codeDeletions.innerHTML = this.hunksRenderer.renderPartialHTML(result.deletionsAST);
        pre.appendChild(codeDeletions);
      }
      if (result.additionsAST != null) {
        codeAdditions = createCodeNode({ columnType: "additions" });
        codeAdditions.innerHTML = this.hunksRenderer.renderPartialHTML(result.additionsAST);
        pre.appendChild(codeAdditions);
      }
    }
    this.injectUnsafeCSS();
    this.mouseEventManager.setup(pre);
    this.lineSelectionManager.setup(pre);
    if ((this.options.overflow ?? "scroll") === "scroll") {
      this.resizeManager.setup(pre);
      this.scrollSyncManager.setup(pre, codeDeletions, codeAdditions);
    } else {
      this.resizeManager.cleanUp();
      this.scrollSyncManager.cleanUp();
    }
  }
  applyPreNodeAttributes(pre, { themeStyles, baseThemeType, additionsAST, deletionsAST, totalLines }) {
    const { diffIndicators = "bars", disableBackground = false, disableLineNumbers = false, overflow = "scroll", themeType = "system", diffStyle = "split" } = this.options;
    setPreNodeProperties({
      pre,
      diffIndicators,
      disableBackground,
      disableLineNumbers,
      overflow,
      split: diffStyle === "unified" ? false : additionsAST != null && deletionsAST != null,
      themeStyles,
      themeType: baseThemeType ?? themeType,
      totalLines
    });
  }
  applyErrorToDOM(error, container) {
    this.cleanupErrorWrapper();
    const pre = this.getOrCreatePreNode(container);
    pre.innerHTML = "";
    pre.parentNode?.removeChild(pre);
    this.pre = void 0;
    const shadowRoot = container.shadowRoot ?? container.attachShadow({ mode: "open" });
    this.errorWrapper ??= document.createElement("div");
    this.errorWrapper.dataset.errorWrapper = "";
    this.errorWrapper.innerHTML = "";
    shadowRoot.appendChild(this.errorWrapper);
    const errorMessage = document.createElement("div");
    errorMessage.dataset.errorMessage = "";
    errorMessage.innerText = error.message;
    this.errorWrapper.appendChild(errorMessage);
    const errorStack = document.createElement("pre");
    errorStack.dataset.errorStack = "";
    errorStack.innerText = error.stack ?? "No Error Stack";
    this.errorWrapper.appendChild(errorStack);
  }
  cleanupErrorWrapper() {
    this.errorWrapper?.parentNode?.removeChild(this.errorWrapper);
    this.errorWrapper = void 0;
  }
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/managers/UniversalRenderingManager.js
var queuedCallbacks = /* @__PURE__ */ new Set();
var callbacks = /* @__PURE__ */ new Set();
var frameId = null;
var isRendering = false;
function queueRender(callback) {
  if (isRendering) {
    queuedCallbacks.add(callback);
    return;
  }
  callbacks.add(callback);
  frameId ??= requestAnimationFrame(render);
}
function render(time) {
  isRendering = true;
  for (const callback of callbacks) try {
    callback(time);
  } catch (error) {
    console.error(error);
  }
  callbacks.clear();
  if (queuedCallbacks.size > 0) {
    callbacks = new Set(queuedCallbacks);
    queuedCallbacks.clear();
    frameId = requestAnimationFrame(render);
  } else frameId = null;
  isRendering = false;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/shiki-stream/tokenizer.js
var ShikiStreamTokenizer = class ShikiStreamTokenizer2 {
  options;
  tokensStable = [];
  tokensUnstable = [];
  lastUnstableCodeChunk = "";
  lastStableGrammarState;
  constructor(options) {
    this.options = options;
  }
  /**
  * Enqueue a chunk of code to the buffer.
  */
  async enqueue(chunk) {
    const chunkLines = (this.lastUnstableCodeChunk + chunk).split("\n");
    const stable = [];
    let unstable = [];
    const recall = this.tokensUnstable.length;
    chunkLines.forEach((line, i) => {
      const isLastLine = i === chunkLines.length - 1;
      const result = this.options.highlighter.codeToTokens(line, {
        ...this.options,
        grammarState: this.lastStableGrammarState
      });
      const tokens = result.tokens[0];
      if (!isLastLine) tokens.push({
        content: "\n",
        offset: 0
      });
      if (!isLastLine) {
        this.lastStableGrammarState = result.grammarState;
        stable.push(...tokens);
      } else {
        unstable = tokens;
        this.lastUnstableCodeChunk = line;
      }
    });
    this.tokensStable.push(...stable);
    this.tokensUnstable = unstable;
    return {
      recall,
      stable,
      unstable
    };
  }
  close() {
    const stable = this.tokensUnstable;
    this.tokensUnstable = [];
    this.lastUnstableCodeChunk = "";
    this.lastStableGrammarState = void 0;
    return { stable };
  }
  clear() {
    this.tokensStable = [];
    this.tokensUnstable = [];
    this.lastUnstableCodeChunk = "";
    this.lastStableGrammarState = void 0;
  }
  clone() {
    const clone = new ShikiStreamTokenizer2(this.options);
    clone.lastUnstableCodeChunk = this.lastUnstableCodeChunk;
    clone.tokensUnstable = this.tokensUnstable;
    clone.tokensStable = this.tokensStable;
    clone.lastStableGrammarState = this.lastStableGrammarState;
    return clone;
  }
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/shiki-stream/stream.js
var CodeToTokenTransformStream = class extends TransformStream {
  tokenizer;
  options;
  constructor(options) {
    const tokenizer = new ShikiStreamTokenizer(options);
    const { allowRecalls = false } = options;
    super({
      async transform(chunk, controller) {
        const { stable, unstable: buffer, recall } = await tokenizer.enqueue(chunk);
        if (allowRecalls && recall > 0) controller.enqueue({ recall });
        for (const token of stable) controller.enqueue(token);
        if (allowRecalls) for (const token of buffer) controller.enqueue(token);
      },
      async flush(controller) {
        const { stable } = tokenizer.close();
        if (!allowRecalls) for (const token of stable) controller.enqueue(token);
      }
    });
    this.tokenizer = tokenizer;
    this.options = options;
  }
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createRowNodes.js
function createRowNodes(line) {
  const row = document.createElement("div");
  row.dataset.line = `${line}`;
  const lineColumn = document.createElement("div");
  lineColumn.dataset.columnNumber = "";
  lineColumn.textContent = `${line}`;
  const content = document.createElement("div");
  content.dataset.columnContent = "";
  row.appendChild(lineColumn);
  row.appendChild(content);
  return {
    row,
    content
  };
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createSpanNodeFromToken.js
function createSpanFromToken(token) {
  const element = document.createElement("span");
  element.style = stringifyTokenStyle(token.htmlStyle ?? getTokenStyleObject(token));
  element.textContent = token.content;
  return element;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/components/FileStream.js
var FileStream = class {
  highlighter;
  stream;
  abortController;
  fileContainer;
  pre;
  code;
  constructor(options = { theme: DEFAULT_THEMES }) {
    this.options = options;
    this.currentLineIndex = this.options.startingLineIndex ?? 1;
  }
  cleanUp() {
    this.abortController?.abort();
    this.abortController = void 0;
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.options = {
      ...this.options,
      themeType
    };
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.options.lang, this.options));
    return this.highlighter;
  }
  queuedSetupArgs;
  async setup(_source, _wrapper) {
    const isSettingUp = this.queuedSetupArgs != null;
    this.queuedSetupArgs = [_source, _wrapper];
    if (isSettingUp) return;
    this.highlighter ??= await this.initializeHighlighter();
    const [source, wrapper] = this.queuedSetupArgs;
    this.queuedSetupArgs = void 0;
    const stream = source;
    this.setupStream(stream, wrapper, this.highlighter);
  }
  setupStream(stream, wrapper, highlighter) {
    const { disableLineNumbers = false, overflow = "scroll", theme = DEFAULT_THEMES, themeType = "system" } = this.options;
    const fileContainer = this.getOrCreateFileContainer();
    if (fileContainer.parentElement == null) wrapper.appendChild(fileContainer);
    this.pre ??= document.createElement("pre");
    if (this.pre.parentElement == null) fileContainer.shadowRoot?.appendChild(this.pre);
    const themeStyles = getHighlighterThemeStyles({
      theme,
      highlighter
    });
    const baseThemeType = typeof theme === "string" ? highlighter.getTheme(theme).type : void 0;
    const pre = setPreNodeProperties({
      diffIndicators: "none",
      disableBackground: true,
      disableLineNumbers,
      overflow,
      pre: this.pre,
      split: false,
      themeType: baseThemeType ?? themeType,
      themeStyles,
      totalLines: 0
    });
    pre.innerHTML = "";
    this.pre = pre;
    this.code = createCodeNode({ pre });
    this.abortController?.abort();
    this.abortController = new AbortController();
    const { onStreamStart, onStreamClose, onStreamAbort } = this.options;
    this.stream = stream;
    this.stream.pipeThrough(typeof theme === "string" ? new CodeToTokenTransformStream({
      ...this.options,
      theme,
      highlighter,
      allowRecalls: true,
      defaultColor: false,
      cssVariablePrefix: formatCSSVariablePrefix()
    }) : new CodeToTokenTransformStream({
      ...this.options,
      themes: theme,
      highlighter,
      allowRecalls: true,
      defaultColor: false,
      cssVariablePrefix: formatCSSVariablePrefix()
    })).pipeTo(new WritableStream({
      start(controller) {
        onStreamStart?.(controller);
      },
      close() {
        onStreamClose?.();
      },
      abort(reason) {
        onStreamAbort?.(reason);
      },
      write: this.handleWrite
    }), { signal: this.abortController.signal }).catch((error) => {
      if (error.name !== "AbortError") console.error("FileStream pipe error:", error);
    });
  }
  queuedTokens = [];
  handleWrite = (token) => {
    if ("recall" in token && this.queuedTokens.length >= token.recall) this.queuedTokens.length = this.queuedTokens.length - token.recall;
    else this.queuedTokens.push(token);
    queueRender(this.render);
    this.options.onStreamWrite?.(token);
  };
  currentLineIndex;
  currentLineElement;
  render = () => {
    this.options.onPreRender?.(this);
    const linesToAppend = [];
    for (const token of this.queuedTokens) if ("recall" in token) {
      if (this.currentLineElement == null) throw new Error("FileStream.render: no current line element, shouldnt be possible to get here");
      if (token.recall > this.currentLineElement.childNodes.length) throw new Error(`FileStream.render: Token recall exceed the current line, there's probably a bug...`);
      for (let i = 0; i < token.recall; i++) this.currentLineElement.lastChild?.remove();
    } else {
      const span = createSpanFromToken(token);
      if (this.currentLineElement == null) linesToAppend.push(this.createLine());
      this.currentLineElement?.appendChild(span);
      if (token.content === "\n") {
        this.currentLineIndex++;
        linesToAppend.push(this.createLine());
      }
    }
    for (const line of linesToAppend) this.code?.appendChild(line);
    this.queuedTokens.length = 0;
    this.options.onPostRender?.(this);
  };
  createLine() {
    const { row, content } = createRowNodes(this.currentLineIndex);
    this.currentLineElement = content;
    return row;
  }
  getOrCreateFileContainer(fileContainer) {
    if (fileContainer != null && fileContainer === this.fileContainer || fileContainer == null && this.fileContainer != null) return this.fileContainer;
    this.fileContainer = fileContainer ?? document.createElement(DIFFS_TAG_NAME);
    return this.fileContainer;
  }
};

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/areObjectsEqual.js
function areObjectsEqual(objA, objB, omitKeys) {
  if (objA === objB || objA == null || objB == null) return objA === objB;
  const omitSet = new Set(omitKeys);
  const keysA = Object.keys(objA);
  const keysBSet = new Set(Object.keys(objB));
  for (const key of keysA) {
    keysBSet.delete(key);
    if (omitSet.has(key)) continue;
    if (!(key in objB) || objA[key] !== objB[key]) return false;
  }
  for (const key of Array.from(keysBSet)) if (!omitSet.has(key)) return false;
  return true;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/areOptionsEqual.js
function areOptionsEqual(optionsA, optionsB) {
  return areThemesEqual(optionsA?.theme ?? DEFAULT_THEMES, optionsB?.theme ?? DEFAULT_THEMES) && areObjectsEqual(optionsA, optionsB, ["theme"]);
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/createStyleElement.js
function createStyleElement(content, isCoreCSS = false) {
  return createHastElement({
    tagName: "style",
    children: [createTextNodeElement(isCoreCSS ? wrapCoreCSS(content) : wrapUnsafeCSS(content))],
    properties: {
      [CORE_CSS_ATTRIBUTE]: isCoreCSS ? "" : void 0,
      [UNSAFE_CSS_ATTRIBUTE]: !isCoreCSS ? "" : void 0
    }
  });
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/diffAcceptRejectHunk.js
function diffAcceptRejectHunk(diff, hunkIndex, type) {
  diff = {
    ...diff,
    hunks: [...diff.hunks],
    oldLines: diff.oldLines != null ? [...diff.oldLines] : void 0,
    newLines: diff.newLines != null ? [...diff.newLines] : void 0,
    cacheKey: diff.cacheKey != null ? `${diff.cacheKey}:${type[0]}-${hunkIndex}` : void 0
  };
  const { newLines, oldLines } = diff;
  if (newLines != null && oldLines != null) {
    const hunk = diff.hunks[hunkIndex];
    if (hunk == null) {
      console.error({
        diff,
        hunkIndex
      });
      throw new Error(`diffResolveRejectHunk: Invalid hunk index: ${hunkIndex}`);
    }
    if (type === "reject") newLines.splice(hunk.additionStart - 1, hunk.additionCount, ...oldLines.slice(hunk.deletionStart - 1, hunk.deletionStart - 1 + hunk.deletionCount));
    else oldLines.splice(hunk.deletionStart - 1, hunk.deletionCount, ...newLines.slice(hunk.additionStart - 1, hunk.additionStart - 1 + hunk.additionCount));
  }
  let deletionOffset = 0;
  let additionOffset = 0;
  let splitOffset = 0;
  let unifiedOffset = 0;
  for (let i = hunkIndex; i < diff.hunks.length; i++) {
    let hunk = diff.hunks[i];
    if (hunk == null) {
      console.error({
        hunk,
        i,
        hunkIndex,
        diff
      });
      throw new Error("diffResolveRejectHunk: iterating through hunks, hunk doesnt exist...");
    }
    hunk = { ...hunk };
    diff.hunks[i] = hunk;
    if (i === hunkIndex) {
      const newContent = {
        type: "context",
        lines: [],
        noEOFCR: false
      };
      for (const content of hunk.hunkContent) if (content.type === "context") {
        newContent.lines.push(...content.lines);
        newContent.noEOFCR = content.noEOFCR;
      } else if (type === "accept") {
        newContent.lines.push(...content.additions);
        newContent.noEOFCR = content.noEOFCRAdditions;
      } else if (type === "reject") {
        newContent.lines.push(...content.deletions);
        newContent.noEOFCR = content.noEOFCRDeletions;
      }
      const lineCount = newContent.lines.length;
      hunk.hunkContent = [newContent];
      splitOffset = lineCount - hunk.splitLineCount;
      hunk.splitLineCount = lineCount;
      unifiedOffset = lineCount - hunk.unifiedLineCount;
      hunk.unifiedLineCount = lineCount;
      deletionOffset = lineCount - hunk.deletionCount;
      hunk.deletionCount = lineCount;
      hunk.deletionLines = 0;
      additionOffset = lineCount - hunk.additionCount;
      hunk.additionCount = lineCount;
      hunk.additionLines = 0;
      diff.splitLineCount += splitOffset;
      diff.unifiedLineCount += unifiedOffset;
    } else {
      hunk.splitLineStart += splitOffset;
      hunk.unifiedLineStart += unifiedOffset;
      hunk.additionStart += additionOffset;
      hunk.deletionStart += deletionOffset;
    }
  }
  return diff;
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getLineEndingType.js
function getLineEndingType(content) {
  if (content.includes("\r\n")) return "CRLF";
  if (content.includes("\r")) return "CR";
  if (content.includes("\n")) return "LF";
  return "none";
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/getSingularPatch.js
function getSingularPatch(patch) {
  const parsedPatches = parsePatchFiles(patch);
  if (parsedPatches.length !== 1) {
    console.error(parsedPatches);
    throw new Error("PatchDiff: Provided patch must include only 1 patch, with 1 diff");
  }
  const { files } = parsedPatches[0];
  if (files.length !== 1) {
    console.error(files);
    throw new Error("FileDiff: Provided patch must contain exactly 1 file diff");
  }
  return files[0];
}

// ../../node_modules/.bun/@pierre+diffs@1.0.2+67f6792bdf102c28/node_modules/@pierre/diffs/dist/utils/setLanguageOverride.js
function setLanguageOverride(fileOrDiff, lang) {
  return {
    ...fileOrDiff,
    lang
  };
}
export {
  ALTERNATE_FILE_NAMES_GIT,
  AttachedLanguages,
  AttachedThemes,
  COMMIT_METADATA_SPLIT,
  CORE_CSS_ATTRIBUTE,
  CodeToTokenTransformStream,
  DEFAULT_THEMES,
  DIFFS_TAG_NAME,
  DiffHunksRenderer,
  EXTENSION_TO_FILE_FORMAT,
  FILENAME_HEADER_REGEX,
  FILENAME_HEADER_REGEX_GIT,
  FILE_CONTEXT_BLOB,
  FILE_MODE_FROM_INDEX,
  File,
  FileDiff,
  FileRenderer,
  FileStream,
  GIT_DIFF_FILE_BREAK_REGEX,
  HEADER_METADATA_SLOT_ID,
  HUNK_HEADER,
  LineSelectionManager,
  MouseEventManager,
  RegisteredCustomThemes,
  ResizeManager,
  ResolvedLanguages,
  ResolvedThemes,
  ResolvingLanguages,
  ResolvingThemes,
  SPLIT_WITH_NEWLINES,
  SVGSpriteSheet,
  ScrollSyncManager,
  ShikiStreamTokenizer,
  UNIFIED_DIFF_FILE_BREAK_REGEX,
  UNSAFE_CSS_ATTRIBUTE,
  areFilesEqual,
  areLanguagesAttached,
  areObjectsEqual,
  areOptionsEqual,
  areSelectionsEqual,
  areThemesAttached,
  areThemesEqual,
  attachResolvedLanguages,
  attachResolvedThemes,
  cleanLastNewline,
  cleanUpResolvedLanguages,
  cleanUpResolvedThemes,
  codeToHtml,
  createAnnotationElement,
  createAnnotationWrapperNode,
  createCodeNode,
  createDiffSpanDecoration,
  createEmptyRowBuffer,
  createFileHeaderElement,
  createHastElement,
  createHoverContentNode,
  createIconElement,
  createNoNewlineElement,
  createPreElement,
  createPreWrapperProperties,
  createRowNodes,
  createSeparator,
  createSpanFromToken,
  createStyleElement,
  createTextNodeElement,
  createTransformerWithState,
  createUnsafeCSSStyleNode,
  diffAcceptRejectHunk,
  disposeHighlighter,
  extendFileFormatMap,
  findCodeElement,
  formatCSSVariablePrefix,
  getFiletypeFromFileName,
  getHighlighterIfLoaded,
  getHighlighterOptions,
  getHighlighterThemeStyles,
  getHunkSeparatorSlotName,
  getIconForType,
  getLineAnnotationName,
  getLineEndingType,
  getLineNodes,
  getResolvedLanguages,
  getResolvedOrResolveLanguage,
  getResolvedOrResolveTheme,
  getResolvedThemes,
  getSharedHighlighter,
  getSingularPatch,
  getThemes,
  getTotalLineCountFromHunks,
  hasResolvedLanguages,
  hasResolvedThemes,
  isHighlighterLoaded,
  isHighlighterLoading,
  isHighlighterNull,
  isWorkerContext,
  parseDiffFromFile,
  parseLineType,
  parsePatchFiles,
  pluckLineSelectionOptions,
  pluckMouseEventOptions,
  preloadHighlighter,
  prerenderHTMLIfNecessary,
  processLine,
  pushOrJoinSpan,
  queueRender,
  registerCustomTheme,
  renderDiffWithHighlighter,
  renderFileWithHighlighter,
  resolveLanguage,
  resolveLanguages,
  resolveTheme,
  resolveThemes,
  setLanguageOverride,
  setPreNodeProperties,
  wrapCoreCSS,
  wrapUnsafeCSS
};
//# sourceMappingURL=@pierre_diffs.js.map
